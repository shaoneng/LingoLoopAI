
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AuthSession
 * 
 */
export type AuthSession = $Result.DefaultSelection<Prisma.$AuthSessionPayload>
/**
 * Model AudioFile
 * 
 */
export type AudioFile = $Result.DefaultSelection<Prisma.$AudioFilePayload>
/**
 * Model TranscriptRun
 * 
 */
export type TranscriptRun = $Result.DefaultSelection<Prisma.$TranscriptRunPayload>
/**
 * Model TranscriptRevision
 * 
 */
export type TranscriptRevision = $Result.DefaultSelection<Prisma.$TranscriptRevisionPayload>
/**
 * Model Analysis
 * 
 */
export type Analysis = $Result.DefaultSelection<Prisma.$AnalysisPayload>
/**
 * Model Annotation
 * 
 */
export type Annotation = $Result.DefaultSelection<Prisma.$AnnotationPayload>
/**
 * Model AudioTag
 * 
 */
export type AudioTag = $Result.DefaultSelection<Prisma.$AudioTagPayload>
/**
 * Model UsageLog
 * 
 */
export type UsageLog = $Result.DefaultSelection<Prisma.$UsageLogPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SharedBbcResource
 * 
 */
export type SharedBbcResource = $Result.DefaultSelection<Prisma.$SharedBbcResourcePayload>
/**
 * Model LearningSession
 * 
 */
export type LearningSession = $Result.DefaultSelection<Prisma.$LearningSessionPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model TakedownRequest
 * 
 */
export type TakedownRequest = $Result.DefaultSelection<Prisma.$TakedownRequestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authSession`: Exposes CRUD operations for the **AuthSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthSessions
    * const authSessions = await prisma.authSession.findMany()
    * ```
    */
  get authSession(): Prisma.AuthSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioFile`: Exposes CRUD operations for the **AudioFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioFiles
    * const audioFiles = await prisma.audioFile.findMany()
    * ```
    */
  get audioFile(): Prisma.AudioFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcriptRun`: Exposes CRUD operations for the **TranscriptRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptRuns
    * const transcriptRuns = await prisma.transcriptRun.findMany()
    * ```
    */
  get transcriptRun(): Prisma.TranscriptRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcriptRevision`: Exposes CRUD operations for the **TranscriptRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptRevisions
    * const transcriptRevisions = await prisma.transcriptRevision.findMany()
    * ```
    */
  get transcriptRevision(): Prisma.TranscriptRevisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysis`: Exposes CRUD operations for the **Analysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analyses
    * const analyses = await prisma.analysis.findMany()
    * ```
    */
  get analysis(): Prisma.AnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.annotation`: Exposes CRUD operations for the **Annotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annotations
    * const annotations = await prisma.annotation.findMany()
    * ```
    */
  get annotation(): Prisma.AnnotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioTag`: Exposes CRUD operations for the **AudioTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioTags
    * const audioTags = await prisma.audioTag.findMany()
    * ```
    */
  get audioTag(): Prisma.AudioTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageLog`: Exposes CRUD operations for the **UsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageLogs
    * const usageLogs = await prisma.usageLog.findMany()
    * ```
    */
  get usageLog(): Prisma.UsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedBbcResource`: Exposes CRUD operations for the **SharedBbcResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedBbcResources
    * const sharedBbcResources = await prisma.sharedBbcResource.findMany()
    * ```
    */
  get sharedBbcResource(): Prisma.SharedBbcResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningSession`: Exposes CRUD operations for the **LearningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningSessions
    * const learningSessions = await prisma.learningSession.findMany()
    * ```
    */
  get learningSession(): Prisma.LearningSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.takedownRequest`: Exposes CRUD operations for the **TakedownRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TakedownRequests
    * const takedownRequests = await prisma.takedownRequest.findMany()
    * ```
    */
  get takedownRequest(): Prisma.TakedownRequestDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AuthSession: 'AuthSession',
    AudioFile: 'AudioFile',
    TranscriptRun: 'TranscriptRun',
    TranscriptRevision: 'TranscriptRevision',
    Analysis: 'Analysis',
    Annotation: 'Annotation',
    AudioTag: 'AudioTag',
    UsageLog: 'UsageLog',
    Job: 'Job',
    AuditLog: 'AuditLog',
    Subscription: 'Subscription',
    SharedBbcResource: 'SharedBbcResource',
    LearningSession: 'LearningSession',
    PasswordResetToken: 'PasswordResetToken',
    TakedownRequest: 'TakedownRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "authSession" | "audioFile" | "transcriptRun" | "transcriptRevision" | "analysis" | "annotation" | "audioTag" | "usageLog" | "job" | "auditLog" | "subscription" | "sharedBbcResource" | "learningSession" | "passwordResetToken" | "takedownRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AuthSession: {
        payload: Prisma.$AuthSessionPayload<ExtArgs>
        fields: Prisma.AuthSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findFirst: {
            args: Prisma.AuthSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findMany: {
            args: Prisma.AuthSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          create: {
            args: Prisma.AuthSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          createMany: {
            args: Prisma.AuthSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          delete: {
            args: Prisma.AuthSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          update: {
            args: Prisma.AuthSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          deleteMany: {
            args: Prisma.AuthSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          upsert: {
            args: Prisma.AuthSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          aggregate: {
            args: Prisma.AuthSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthSession>
          }
          groupBy: {
            args: Prisma.AuthSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionCountAggregateOutputType> | number
          }
        }
      }
      AudioFile: {
        payload: Prisma.$AudioFilePayload<ExtArgs>
        fields: Prisma.AudioFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>
          }
          findFirst: {
            args: Prisma.AudioFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>
          }
          findMany: {
            args: Prisma.AudioFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>[]
          }
          create: {
            args: Prisma.AudioFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>
          }
          createMany: {
            args: Prisma.AudioFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>[]
          }
          delete: {
            args: Prisma.AudioFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>
          }
          update: {
            args: Prisma.AudioFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>
          }
          deleteMany: {
            args: Prisma.AudioFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>[]
          }
          upsert: {
            args: Prisma.AudioFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioFilePayload>
          }
          aggregate: {
            args: Prisma.AudioFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioFile>
          }
          groupBy: {
            args: Prisma.AudioFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioFileCountArgs<ExtArgs>
            result: $Utils.Optional<AudioFileCountAggregateOutputType> | number
          }
        }
      }
      TranscriptRun: {
        payload: Prisma.$TranscriptRunPayload<ExtArgs>
        fields: Prisma.TranscriptRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>
          }
          findFirst: {
            args: Prisma.TranscriptRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>
          }
          findMany: {
            args: Prisma.TranscriptRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>[]
          }
          create: {
            args: Prisma.TranscriptRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>
          }
          createMany: {
            args: Prisma.TranscriptRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>[]
          }
          delete: {
            args: Prisma.TranscriptRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>
          }
          update: {
            args: Prisma.TranscriptRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranscriptRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>[]
          }
          upsert: {
            args: Prisma.TranscriptRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRunPayload>
          }
          aggregate: {
            args: Prisma.TranscriptRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscriptRun>
          }
          groupBy: {
            args: Prisma.TranscriptRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptRunCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptRunCountAggregateOutputType> | number
          }
        }
      }
      TranscriptRevision: {
        payload: Prisma.$TranscriptRevisionPayload<ExtArgs>
        fields: Prisma.TranscriptRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>
          }
          findFirst: {
            args: Prisma.TranscriptRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>
          }
          findMany: {
            args: Prisma.TranscriptRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>[]
          }
          create: {
            args: Prisma.TranscriptRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>
          }
          createMany: {
            args: Prisma.TranscriptRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranscriptRevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>[]
          }
          delete: {
            args: Prisma.TranscriptRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>
          }
          update: {
            args: Prisma.TranscriptRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TranscriptRevisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>[]
          }
          upsert: {
            args: Prisma.TranscriptRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptRevisionPayload>
          }
          aggregate: {
            args: Prisma.TranscriptRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscriptRevision>
          }
          groupBy: {
            args: Prisma.TranscriptRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptRevisionCountAggregateOutputType> | number
          }
        }
      }
      Analysis: {
        payload: Prisma.$AnalysisPayload<ExtArgs>
        fields: Prisma.AnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>
          }
          findFirst: {
            args: Prisma.AnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>
          }
          findMany: {
            args: Prisma.AnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>[]
          }
          create: {
            args: Prisma.AnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>
          }
          createMany: {
            args: Prisma.AnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>[]
          }
          delete: {
            args: Prisma.AnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>
          }
          update: {
            args: Prisma.AnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>
          }
          deleteMany: {
            args: Prisma.AnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>[]
          }
          upsert: {
            args: Prisma.AnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPayload>
          }
          aggregate: {
            args: Prisma.AnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysis>
          }
          groupBy: {
            args: Prisma.AnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisCountAggregateOutputType> | number
          }
        }
      }
      Annotation: {
        payload: Prisma.$AnnotationPayload<ExtArgs>
        fields: Prisma.AnnotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          findFirst: {
            args: Prisma.AnnotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          findMany: {
            args: Prisma.AnnotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          create: {
            args: Prisma.AnnotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          createMany: {
            args: Prisma.AnnotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          delete: {
            args: Prisma.AnnotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          update: {
            args: Prisma.AnnotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          deleteMany: {
            args: Prisma.AnnotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>[]
          }
          upsert: {
            args: Prisma.AnnotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnotationPayload>
          }
          aggregate: {
            args: Prisma.AnnotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnotation>
          }
          groupBy: {
            args: Prisma.AnnotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnotationCountArgs<ExtArgs>
            result: $Utils.Optional<AnnotationCountAggregateOutputType> | number
          }
        }
      }
      AudioTag: {
        payload: Prisma.$AudioTagPayload<ExtArgs>
        fields: Prisma.AudioTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>
          }
          findFirst: {
            args: Prisma.AudioTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>
          }
          findMany: {
            args: Prisma.AudioTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>[]
          }
          create: {
            args: Prisma.AudioTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>
          }
          createMany: {
            args: Prisma.AudioTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>[]
          }
          delete: {
            args: Prisma.AudioTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>
          }
          update: {
            args: Prisma.AudioTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>
          }
          deleteMany: {
            args: Prisma.AudioTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>[]
          }
          upsert: {
            args: Prisma.AudioTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTagPayload>
          }
          aggregate: {
            args: Prisma.AudioTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioTag>
          }
          groupBy: {
            args: Prisma.AudioTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioTagCountArgs<ExtArgs>
            result: $Utils.Optional<AudioTagCountAggregateOutputType> | number
          }
        }
      }
      UsageLog: {
        payload: Prisma.$UsageLogPayload<ExtArgs>
        fields: Prisma.UsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          findFirst: {
            args: Prisma.UsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          findMany: {
            args: Prisma.UsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          create: {
            args: Prisma.UsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          createMany: {
            args: Prisma.UsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          delete: {
            args: Prisma.UsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          update: {
            args: Prisma.UsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          deleteMany: {
            args: Prisma.UsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>[]
          }
          upsert: {
            args: Prisma.UsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageLogPayload>
          }
          aggregate: {
            args: Prisma.UsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageLog>
          }
          groupBy: {
            args: Prisma.UsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<UsageLogCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SharedBbcResource: {
        payload: Prisma.$SharedBbcResourcePayload<ExtArgs>
        fields: Prisma.SharedBbcResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedBbcResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedBbcResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>
          }
          findFirst: {
            args: Prisma.SharedBbcResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedBbcResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>
          }
          findMany: {
            args: Prisma.SharedBbcResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>[]
          }
          create: {
            args: Prisma.SharedBbcResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>
          }
          createMany: {
            args: Prisma.SharedBbcResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedBbcResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>[]
          }
          delete: {
            args: Prisma.SharedBbcResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>
          }
          update: {
            args: Prisma.SharedBbcResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>
          }
          deleteMany: {
            args: Prisma.SharedBbcResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedBbcResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedBbcResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>[]
          }
          upsert: {
            args: Prisma.SharedBbcResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedBbcResourcePayload>
          }
          aggregate: {
            args: Prisma.SharedBbcResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedBbcResource>
          }
          groupBy: {
            args: Prisma.SharedBbcResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedBbcResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedBbcResourceCountArgs<ExtArgs>
            result: $Utils.Optional<SharedBbcResourceCountAggregateOutputType> | number
          }
        }
      }
      LearningSession: {
        payload: Prisma.$LearningSessionPayload<ExtArgs>
        fields: Prisma.LearningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          findFirst: {
            args: Prisma.LearningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          findMany: {
            args: Prisma.LearningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          create: {
            args: Prisma.LearningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          createMany: {
            args: Prisma.LearningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          delete: {
            args: Prisma.LearningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          update: {
            args: Prisma.LearningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          deleteMany: {
            args: Prisma.LearningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          upsert: {
            args: Prisma.LearningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          aggregate: {
            args: Prisma.LearningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningSession>
          }
          groupBy: {
            args: Prisma.LearningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      TakedownRequest: {
        payload: Prisma.$TakedownRequestPayload<ExtArgs>
        fields: Prisma.TakedownRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TakedownRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TakedownRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>
          }
          findFirst: {
            args: Prisma.TakedownRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TakedownRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>
          }
          findMany: {
            args: Prisma.TakedownRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>[]
          }
          create: {
            args: Prisma.TakedownRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>
          }
          createMany: {
            args: Prisma.TakedownRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TakedownRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>[]
          }
          delete: {
            args: Prisma.TakedownRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>
          }
          update: {
            args: Prisma.TakedownRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>
          }
          deleteMany: {
            args: Prisma.TakedownRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TakedownRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TakedownRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>[]
          }
          upsert: {
            args: Prisma.TakedownRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TakedownRequestPayload>
          }
          aggregate: {
            args: Prisma.TakedownRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTakedownRequest>
          }
          groupBy: {
            args: Prisma.TakedownRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TakedownRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TakedownRequestCountArgs<ExtArgs>
            result: $Utils.Optional<TakedownRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    authSession?: AuthSessionOmit
    audioFile?: AudioFileOmit
    transcriptRun?: TranscriptRunOmit
    transcriptRevision?: TranscriptRevisionOmit
    analysis?: AnalysisOmit
    annotation?: AnnotationOmit
    audioTag?: AudioTagOmit
    usageLog?: UsageLogOmit
    job?: JobOmit
    auditLog?: AuditLogOmit
    subscription?: SubscriptionOmit
    sharedBbcResource?: SharedBbcResourceOmit
    learningSession?: LearningSessionOmit
    passwordResetToken?: PasswordResetTokenOmit
    takedownRequest?: TakedownRequestOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    audioFiles: number
    transcriptRuns: number
    annotations: number
    usageLogs: number
    authSessions: number
    auditLogs: number
    passwordResetTokens: number
    sharedBbcResources: number
    learningSessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioFiles?: boolean | UserCountOutputTypeCountAudioFilesArgs
    transcriptRuns?: boolean | UserCountOutputTypeCountTranscriptRunsArgs
    annotations?: boolean | UserCountOutputTypeCountAnnotationsArgs
    usageLogs?: boolean | UserCountOutputTypeCountUsageLogsArgs
    authSessions?: boolean | UserCountOutputTypeCountAuthSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    sharedBbcResources?: boolean | UserCountOutputTypeCountSharedBbcResourcesArgs
    learningSessions?: boolean | UserCountOutputTypeCountLearningSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAudioFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioFileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTranscriptRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedBbcResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedBbcResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
  }


  /**
   * Count Type AudioFileCountOutputType
   */

  export type AudioFileCountOutputType = {
    transcriptRuns: number
    tags: number
    Job: number
    learningSessions: number
  }

  export type AudioFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transcriptRuns?: boolean | AudioFileCountOutputTypeCountTranscriptRunsArgs
    tags?: boolean | AudioFileCountOutputTypeCountTagsArgs
    Job?: boolean | AudioFileCountOutputTypeCountJobArgs
    learningSessions?: boolean | AudioFileCountOutputTypeCountLearningSessionsArgs
  }

  // Custom InputTypes
  /**
   * AudioFileCountOutputType without action
   */
  export type AudioFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFileCountOutputType
     */
    select?: AudioFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioFileCountOutputType without action
   */
  export type AudioFileCountOutputTypeCountTranscriptRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptRunWhereInput
  }

  /**
   * AudioFileCountOutputType without action
   */
  export type AudioFileCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioTagWhereInput
  }

  /**
   * AudioFileCountOutputType without action
   */
  export type AudioFileCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * AudioFileCountOutputType without action
   */
  export type AudioFileCountOutputTypeCountLearningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
  }


  /**
   * Count Type TranscriptRunCountOutputType
   */

  export type TranscriptRunCountOutputType = {
    revisions: number
    annotations: number
    jobs: number
    analyses: number
    learningSessions: number
  }

  export type TranscriptRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    revisions?: boolean | TranscriptRunCountOutputTypeCountRevisionsArgs
    annotations?: boolean | TranscriptRunCountOutputTypeCountAnnotationsArgs
    jobs?: boolean | TranscriptRunCountOutputTypeCountJobsArgs
    analyses?: boolean | TranscriptRunCountOutputTypeCountAnalysesArgs
    learningSessions?: boolean | TranscriptRunCountOutputTypeCountLearningSessionsArgs
  }

  // Custom InputTypes
  /**
   * TranscriptRunCountOutputType without action
   */
  export type TranscriptRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRunCountOutputType
     */
    select?: TranscriptRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TranscriptRunCountOutputType without action
   */
  export type TranscriptRunCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptRevisionWhereInput
  }

  /**
   * TranscriptRunCountOutputType without action
   */
  export type TranscriptRunCountOutputTypeCountAnnotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
  }

  /**
   * TranscriptRunCountOutputType without action
   */
  export type TranscriptRunCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * TranscriptRunCountOutputType without action
   */
  export type TranscriptRunCountOutputTypeCountAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisWhereInput
  }

  /**
   * TranscriptRunCountOutputType without action
   */
  export type TranscriptRunCountOutputTypeCountLearningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
  }


  /**
   * Count Type SharedBbcResourceCountOutputType
   */

  export type SharedBbcResourceCountOutputType = {
    takedownRequests: number
  }

  export type SharedBbcResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    takedownRequests?: boolean | SharedBbcResourceCountOutputTypeCountTakedownRequestsArgs
  }

  // Custom InputTypes
  /**
   * SharedBbcResourceCountOutputType without action
   */
  export type SharedBbcResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResourceCountOutputType
     */
    select?: SharedBbcResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SharedBbcResourceCountOutputType without action
   */
  export type SharedBbcResourceCountOutputTypeCountTakedownRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakedownRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    avatarUrl: string | null
    emailVerified: boolean | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    avatarUrl: string | null
    emailVerified: boolean | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    displayName: number
    avatarUrl: number
    emailVerified: number
    settings: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatarUrl?: true
    emailVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatarUrl?: true
    emailVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    avatarUrl?: true
    emailVerified?: true
    settings?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    displayName: string | null
    avatarUrl: string | null
    emailVerified: boolean
    settings: JsonValue | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    emailVerified?: boolean
    settings?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    audioFiles?: boolean | User$audioFilesArgs<ExtArgs>
    transcriptRuns?: boolean | User$transcriptRunsArgs<ExtArgs>
    annotations?: boolean | User$annotationsArgs<ExtArgs>
    usageLogs?: boolean | User$usageLogsArgs<ExtArgs>
    authSessions?: boolean | User$authSessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    sharedBbcResources?: boolean | User$sharedBbcResourcesArgs<ExtArgs>
    learningSessions?: boolean | User$learningSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    emailVerified?: boolean
    settings?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    emailVerified?: boolean
    settings?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    emailVerified?: boolean
    settings?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "displayName" | "avatarUrl" | "emailVerified" | "settings" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    audioFiles?: boolean | User$audioFilesArgs<ExtArgs>
    transcriptRuns?: boolean | User$transcriptRunsArgs<ExtArgs>
    annotations?: boolean | User$annotationsArgs<ExtArgs>
    usageLogs?: boolean | User$usageLogsArgs<ExtArgs>
    authSessions?: boolean | User$authSessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    sharedBbcResources?: boolean | User$sharedBbcResourcesArgs<ExtArgs>
    learningSessions?: boolean | User$learningSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      audioFiles: Prisma.$AudioFilePayload<ExtArgs>[]
      transcriptRuns: Prisma.$TranscriptRunPayload<ExtArgs>[]
      annotations: Prisma.$AnnotationPayload<ExtArgs>[]
      usageLogs: Prisma.$UsageLogPayload<ExtArgs>[]
      authSessions: Prisma.$AuthSessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      sharedBbcResources: Prisma.$SharedBbcResourcePayload<ExtArgs>[]
      learningSessions: Prisma.$LearningSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      displayName: string | null
      avatarUrl: string | null
      emailVerified: boolean
      settings: Prisma.JsonValue | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audioFiles<T extends User$audioFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$audioFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcriptRuns<T extends User$transcriptRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$transcriptRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    annotations<T extends User$annotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$annotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends User$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authSessions<T extends User$authSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$authSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedBbcResources<T extends User$sharedBbcResourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedBbcResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningSessions<T extends User$learningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$learningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly settings: FieldRef<"User", 'Json'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.audioFiles
   */
  export type User$audioFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    where?: AudioFileWhereInput
    orderBy?: AudioFileOrderByWithRelationInput | AudioFileOrderByWithRelationInput[]
    cursor?: AudioFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioFileScalarFieldEnum | AudioFileScalarFieldEnum[]
  }

  /**
   * User.transcriptRuns
   */
  export type User$transcriptRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    where?: TranscriptRunWhereInput
    orderBy?: TranscriptRunOrderByWithRelationInput | TranscriptRunOrderByWithRelationInput[]
    cursor?: TranscriptRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptRunScalarFieldEnum | TranscriptRunScalarFieldEnum[]
  }

  /**
   * User.annotations
   */
  export type User$annotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * User.usageLogs
   */
  export type User$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    cursor?: UsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * User.authSessions
   */
  export type User$authSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    cursor?: AuthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.sharedBbcResources
   */
  export type User$sharedBbcResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    where?: SharedBbcResourceWhereInput
    orderBy?: SharedBbcResourceOrderByWithRelationInput | SharedBbcResourceOrderByWithRelationInput[]
    cursor?: SharedBbcResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedBbcResourceScalarFieldEnum | SharedBbcResourceScalarFieldEnum[]
  }

  /**
   * User.learningSessions
   */
  export type User$learningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    cursor?: LearningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AuthSession
   */

  export type AggregateAuthSession = {
    _count: AuthSessionCountAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  export type AuthSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AuthSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type AuthSessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type AuthSessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AuthSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type AuthSessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type AuthSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSession to aggregate.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthSessions
    **/
    _count?: true | AuthSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthSessionMaxAggregateInputType
  }

  export type GetAuthSessionAggregateType<T extends AuthSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthSession[P]>
      : GetScalarType<T[P], AggregateAuthSession[P]>
  }




  export type AuthSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithAggregationInput | AuthSessionOrderByWithAggregationInput[]
    by: AuthSessionScalarFieldEnum[] | AuthSessionScalarFieldEnum
    having?: AuthSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthSessionCountAggregateInputType | true
    _min?: AuthSessionMinAggregateInputType
    _max?: AuthSessionMaxAggregateInputType
  }

  export type AuthSessionGroupByOutputType = {
    id: string
    userId: string
    refreshToken: string
    expiresAt: Date
    createdAt: Date
    _count: AuthSessionCountAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  type GetAuthSessionGroupByPayload<T extends AuthSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
        }
      >
    >


  export type AuthSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type AuthSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "refreshToken" | "expiresAt" | "createdAt", ExtArgs["result"]["authSession"]>
  export type AuthSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshToken: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["authSession"]>
    composites: {}
  }

  type AuthSessionGetPayload<S extends boolean | null | undefined | AuthSessionDefaultArgs> = $Result.GetResult<Prisma.$AuthSessionPayload, S>

  type AuthSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthSessionCountAggregateInputType | true
    }

  export interface AuthSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthSession'], meta: { name: 'AuthSession' } }
    /**
     * Find zero or one AuthSession that matches the filter.
     * @param {AuthSessionFindUniqueArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthSessionFindUniqueArgs>(args: SelectSubset<T, AuthSessionFindUniqueArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthSessionFindUniqueOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthSessionFindFirstArgs>(args?: SelectSubset<T, AuthSessionFindFirstArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthSessions
     * const authSessions = await prisma.authSession.findMany()
     * 
     * // Get first 10 AuthSessions
     * const authSessions = await prisma.authSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authSessionWithIdOnly = await prisma.authSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthSessionFindManyArgs>(args?: SelectSubset<T, AuthSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthSession.
     * @param {AuthSessionCreateArgs} args - Arguments to create a AuthSession.
     * @example
     * // Create one AuthSession
     * const AuthSession = await prisma.authSession.create({
     *   data: {
     *     // ... data to create a AuthSession
     *   }
     * })
     * 
     */
    create<T extends AuthSessionCreateArgs>(args: SelectSubset<T, AuthSessionCreateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthSessions.
     * @param {AuthSessionCreateManyArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthSessionCreateManyArgs>(args?: SelectSubset<T, AuthSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthSessions and returns the data saved in the database.
     * @param {AuthSessionCreateManyAndReturnArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthSession.
     * @param {AuthSessionDeleteArgs} args - Arguments to delete one AuthSession.
     * @example
     * // Delete one AuthSession
     * const AuthSession = await prisma.authSession.delete({
     *   where: {
     *     // ... filter to delete one AuthSession
     *   }
     * })
     * 
     */
    delete<T extends AuthSessionDeleteArgs>(args: SelectSubset<T, AuthSessionDeleteArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthSession.
     * @param {AuthSessionUpdateArgs} args - Arguments to update one AuthSession.
     * @example
     * // Update one AuthSession
     * const authSession = await prisma.authSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthSessionUpdateArgs>(args: SelectSubset<T, AuthSessionUpdateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthSessions.
     * @param {AuthSessionDeleteManyArgs} args - Arguments to filter AuthSessions to delete.
     * @example
     * // Delete a few AuthSessions
     * const { count } = await prisma.authSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthSessionDeleteManyArgs>(args?: SelectSubset<T, AuthSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthSessionUpdateManyArgs>(args: SelectSubset<T, AuthSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions and returns the data updated in the database.
     * @param {AuthSessionUpdateManyAndReturnArgs} args - Arguments to update many AuthSessions.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthSession.
     * @param {AuthSessionUpsertArgs} args - Arguments to update or create a AuthSession.
     * @example
     * // Update or create a AuthSession
     * const authSession = await prisma.authSession.upsert({
     *   create: {
     *     // ... data to create a AuthSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthSession we want to update
     *   }
     * })
     */
    upsert<T extends AuthSessionUpsertArgs>(args: SelectSubset<T, AuthSessionUpsertArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionCountArgs} args - Arguments to filter AuthSessions to count.
     * @example
     * // Count the number of AuthSessions
     * const count = await prisma.authSession.count({
     *   where: {
     *     // ... the filter for the AuthSessions we want to count
     *   }
     * })
    **/
    count<T extends AuthSessionCountArgs>(
      args?: Subset<T, AuthSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthSessionAggregateArgs>(args: Subset<T, AuthSessionAggregateArgs>): Prisma.PrismaPromise<GetAuthSessionAggregateType<T>>

    /**
     * Group by AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthSessionGroupByArgs['orderBy'] }
        : { orderBy?: AuthSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthSession model
   */
  readonly fields: AuthSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthSession model
   */
  interface AuthSessionFieldRefs {
    readonly id: FieldRef<"AuthSession", 'String'>
    readonly userId: FieldRef<"AuthSession", 'String'>
    readonly refreshToken: FieldRef<"AuthSession", 'String'>
    readonly expiresAt: FieldRef<"AuthSession", 'DateTime'>
    readonly createdAt: FieldRef<"AuthSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthSession findUnique
   */
  export type AuthSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findUniqueOrThrow
   */
  export type AuthSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findFirst
   */
  export type AuthSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findFirstOrThrow
   */
  export type AuthSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findMany
   */
  export type AuthSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSessions to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession create
   */
  export type AuthSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthSession.
     */
    data: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
  }

  /**
   * AuthSession createMany
   */
  export type AuthSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthSession createManyAndReturn
   */
  export type AuthSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession update
   */
  export type AuthSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthSession.
     */
    data: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
    /**
     * Choose, which AuthSession to update.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession updateMany
   */
  export type AuthSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
  }

  /**
   * AuthSession updateManyAndReturn
   */
  export type AuthSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession upsert
   */
  export type AuthSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthSession to update in case it exists.
     */
    where: AuthSessionWhereUniqueInput
    /**
     * In case the AuthSession found by the `where` argument doesn't exist, create a new AuthSession with this data.
     */
    create: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
    /**
     * In case the AuthSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
  }

  /**
   * AuthSession delete
   */
  export type AuthSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter which AuthSession to delete.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession deleteMany
   */
  export type AuthSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSessions to delete
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to delete.
     */
    limit?: number
  }

  /**
   * AuthSession without action
   */
  export type AuthSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
  }


  /**
   * Model AudioFile
   */

  export type AggregateAudioFile = {
    _count: AudioFileCountAggregateOutputType | null
    _avg: AudioFileAvgAggregateOutputType | null
    _sum: AudioFileSumAggregateOutputType | null
    _min: AudioFileMinAggregateOutputType | null
    _max: AudioFileMaxAggregateOutputType | null
  }

  export type AudioFileAvgAggregateOutputType = {
    durationMs: number | null
    sizeBytes: number | null
    gapSec: number | null
  }

  export type AudioFileSumAggregateOutputType = {
    durationMs: number | null
    sizeBytes: bigint | null
    gapSec: number | null
  }

  export type AudioFileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gcsUri: string | null
    filename: string | null
    durationMs: number | null
    sizeBytes: bigint | null
    language: string | null
    mode: string | null
    gapSec: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AudioFileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gcsUri: string | null
    filename: string | null
    durationMs: number | null
    sizeBytes: bigint | null
    language: string | null
    mode: string | null
    gapSec: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AudioFileCountAggregateOutputType = {
    id: number
    userId: number
    gcsUri: number
    filename: number
    durationMs: number
    sizeBytes: number
    language: number
    mode: number
    gapSec: number
    status: number
    errorMessage: number
    meta: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AudioFileAvgAggregateInputType = {
    durationMs?: true
    sizeBytes?: true
    gapSec?: true
  }

  export type AudioFileSumAggregateInputType = {
    durationMs?: true
    sizeBytes?: true
    gapSec?: true
  }

  export type AudioFileMinAggregateInputType = {
    id?: true
    userId?: true
    gcsUri?: true
    filename?: true
    durationMs?: true
    sizeBytes?: true
    language?: true
    mode?: true
    gapSec?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AudioFileMaxAggregateInputType = {
    id?: true
    userId?: true
    gcsUri?: true
    filename?: true
    durationMs?: true
    sizeBytes?: true
    language?: true
    mode?: true
    gapSec?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AudioFileCountAggregateInputType = {
    id?: true
    userId?: true
    gcsUri?: true
    filename?: true
    durationMs?: true
    sizeBytes?: true
    language?: true
    mode?: true
    gapSec?: true
    status?: true
    errorMessage?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AudioFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioFile to aggregate.
     */
    where?: AudioFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioFiles to fetch.
     */
    orderBy?: AudioFileOrderByWithRelationInput | AudioFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioFiles
    **/
    _count?: true | AudioFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioFileMaxAggregateInputType
  }

  export type GetAudioFileAggregateType<T extends AudioFileAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioFile[P]>
      : GetScalarType<T[P], AggregateAudioFile[P]>
  }




  export type AudioFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioFileWhereInput
    orderBy?: AudioFileOrderByWithAggregationInput | AudioFileOrderByWithAggregationInput[]
    by: AudioFileScalarFieldEnum[] | AudioFileScalarFieldEnum
    having?: AudioFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioFileCountAggregateInputType | true
    _avg?: AudioFileAvgAggregateInputType
    _sum?: AudioFileSumAggregateInputType
    _min?: AudioFileMinAggregateInputType
    _max?: AudioFileMaxAggregateInputType
  }

  export type AudioFileGroupByOutputType = {
    id: string
    userId: string
    gcsUri: string
    filename: string
    durationMs: number | null
    sizeBytes: bigint | null
    language: string | null
    mode: string | null
    gapSec: number | null
    status: string
    errorMessage: string | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AudioFileCountAggregateOutputType | null
    _avg: AudioFileAvgAggregateOutputType | null
    _sum: AudioFileSumAggregateOutputType | null
    _min: AudioFileMinAggregateOutputType | null
    _max: AudioFileMaxAggregateOutputType | null
  }

  type GetAudioFileGroupByPayload<T extends AudioFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioFileGroupByOutputType[P]>
            : GetScalarType<T[P], AudioFileGroupByOutputType[P]>
        }
      >
    >


  export type AudioFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gcsUri?: boolean
    filename?: boolean
    durationMs?: boolean
    sizeBytes?: boolean
    language?: boolean
    mode?: boolean
    gapSec?: boolean
    status?: boolean
    errorMessage?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transcriptRuns?: boolean | AudioFile$transcriptRunsArgs<ExtArgs>
    tags?: boolean | AudioFile$tagsArgs<ExtArgs>
    Job?: boolean | AudioFile$JobArgs<ExtArgs>
    learningSessions?: boolean | AudioFile$learningSessionsArgs<ExtArgs>
    _count?: boolean | AudioFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioFile"]>

  export type AudioFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gcsUri?: boolean
    filename?: boolean
    durationMs?: boolean
    sizeBytes?: boolean
    language?: boolean
    mode?: boolean
    gapSec?: boolean
    status?: boolean
    errorMessage?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioFile"]>

  export type AudioFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gcsUri?: boolean
    filename?: boolean
    durationMs?: boolean
    sizeBytes?: boolean
    language?: boolean
    mode?: boolean
    gapSec?: boolean
    status?: boolean
    errorMessage?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioFile"]>

  export type AudioFileSelectScalar = {
    id?: boolean
    userId?: boolean
    gcsUri?: boolean
    filename?: boolean
    durationMs?: boolean
    sizeBytes?: boolean
    language?: boolean
    mode?: boolean
    gapSec?: boolean
    status?: boolean
    errorMessage?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AudioFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gcsUri" | "filename" | "durationMs" | "sizeBytes" | "language" | "mode" | "gapSec" | "status" | "errorMessage" | "meta" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["audioFile"]>
  export type AudioFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transcriptRuns?: boolean | AudioFile$transcriptRunsArgs<ExtArgs>
    tags?: boolean | AudioFile$tagsArgs<ExtArgs>
    Job?: boolean | AudioFile$JobArgs<ExtArgs>
    learningSessions?: boolean | AudioFile$learningSessionsArgs<ExtArgs>
    _count?: boolean | AudioFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudioFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AudioFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AudioFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioFile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transcriptRuns: Prisma.$TranscriptRunPayload<ExtArgs>[]
      tags: Prisma.$AudioTagPayload<ExtArgs>[]
      Job: Prisma.$JobPayload<ExtArgs>[]
      learningSessions: Prisma.$LearningSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gcsUri: string
      filename: string
      durationMs: number | null
      sizeBytes: bigint | null
      language: string | null
      mode: string | null
      gapSec: number | null
      status: string
      errorMessage: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["audioFile"]>
    composites: {}
  }

  type AudioFileGetPayload<S extends boolean | null | undefined | AudioFileDefaultArgs> = $Result.GetResult<Prisma.$AudioFilePayload, S>

  type AudioFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioFileCountAggregateInputType | true
    }

  export interface AudioFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioFile'], meta: { name: 'AudioFile' } }
    /**
     * Find zero or one AudioFile that matches the filter.
     * @param {AudioFileFindUniqueArgs} args - Arguments to find a AudioFile
     * @example
     * // Get one AudioFile
     * const audioFile = await prisma.audioFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioFileFindUniqueArgs>(args: SelectSubset<T, AudioFileFindUniqueArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioFileFindUniqueOrThrowArgs} args - Arguments to find a AudioFile
     * @example
     * // Get one AudioFile
     * const audioFile = await prisma.audioFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioFileFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileFindFirstArgs} args - Arguments to find a AudioFile
     * @example
     * // Get one AudioFile
     * const audioFile = await prisma.audioFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioFileFindFirstArgs>(args?: SelectSubset<T, AudioFileFindFirstArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileFindFirstOrThrowArgs} args - Arguments to find a AudioFile
     * @example
     * // Get one AudioFile
     * const audioFile = await prisma.audioFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioFileFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioFiles
     * const audioFiles = await prisma.audioFile.findMany()
     * 
     * // Get first 10 AudioFiles
     * const audioFiles = await prisma.audioFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioFileWithIdOnly = await prisma.audioFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioFileFindManyArgs>(args?: SelectSubset<T, AudioFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioFile.
     * @param {AudioFileCreateArgs} args - Arguments to create a AudioFile.
     * @example
     * // Create one AudioFile
     * const AudioFile = await prisma.audioFile.create({
     *   data: {
     *     // ... data to create a AudioFile
     *   }
     * })
     * 
     */
    create<T extends AudioFileCreateArgs>(args: SelectSubset<T, AudioFileCreateArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioFiles.
     * @param {AudioFileCreateManyArgs} args - Arguments to create many AudioFiles.
     * @example
     * // Create many AudioFiles
     * const audioFile = await prisma.audioFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioFileCreateManyArgs>(args?: SelectSubset<T, AudioFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioFiles and returns the data saved in the database.
     * @param {AudioFileCreateManyAndReturnArgs} args - Arguments to create many AudioFiles.
     * @example
     * // Create many AudioFiles
     * const audioFile = await prisma.audioFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioFiles and only return the `id`
     * const audioFileWithIdOnly = await prisma.audioFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioFileCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioFile.
     * @param {AudioFileDeleteArgs} args - Arguments to delete one AudioFile.
     * @example
     * // Delete one AudioFile
     * const AudioFile = await prisma.audioFile.delete({
     *   where: {
     *     // ... filter to delete one AudioFile
     *   }
     * })
     * 
     */
    delete<T extends AudioFileDeleteArgs>(args: SelectSubset<T, AudioFileDeleteArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioFile.
     * @param {AudioFileUpdateArgs} args - Arguments to update one AudioFile.
     * @example
     * // Update one AudioFile
     * const audioFile = await prisma.audioFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioFileUpdateArgs>(args: SelectSubset<T, AudioFileUpdateArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioFiles.
     * @param {AudioFileDeleteManyArgs} args - Arguments to filter AudioFiles to delete.
     * @example
     * // Delete a few AudioFiles
     * const { count } = await prisma.audioFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioFileDeleteManyArgs>(args?: SelectSubset<T, AudioFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioFiles
     * const audioFile = await prisma.audioFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioFileUpdateManyArgs>(args: SelectSubset<T, AudioFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioFiles and returns the data updated in the database.
     * @param {AudioFileUpdateManyAndReturnArgs} args - Arguments to update many AudioFiles.
     * @example
     * // Update many AudioFiles
     * const audioFile = await prisma.audioFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioFiles and only return the `id`
     * const audioFileWithIdOnly = await prisma.audioFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioFileUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioFile.
     * @param {AudioFileUpsertArgs} args - Arguments to update or create a AudioFile.
     * @example
     * // Update or create a AudioFile
     * const audioFile = await prisma.audioFile.upsert({
     *   create: {
     *     // ... data to create a AudioFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioFile we want to update
     *   }
     * })
     */
    upsert<T extends AudioFileUpsertArgs>(args: SelectSubset<T, AudioFileUpsertArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileCountArgs} args - Arguments to filter AudioFiles to count.
     * @example
     * // Count the number of AudioFiles
     * const count = await prisma.audioFile.count({
     *   where: {
     *     // ... the filter for the AudioFiles we want to count
     *   }
     * })
    **/
    count<T extends AudioFileCountArgs>(
      args?: Subset<T, AudioFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioFileAggregateArgs>(args: Subset<T, AudioFileAggregateArgs>): Prisma.PrismaPromise<GetAudioFileAggregateType<T>>

    /**
     * Group by AudioFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioFileGroupByArgs['orderBy'] }
        : { orderBy?: AudioFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioFile model
   */
  readonly fields: AudioFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transcriptRuns<T extends AudioFile$transcriptRunsArgs<ExtArgs> = {}>(args?: Subset<T, AudioFile$transcriptRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends AudioFile$tagsArgs<ExtArgs> = {}>(args?: Subset<T, AudioFile$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Job<T extends AudioFile$JobArgs<ExtArgs> = {}>(args?: Subset<T, AudioFile$JobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningSessions<T extends AudioFile$learningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, AudioFile$learningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioFile model
   */
  interface AudioFileFieldRefs {
    readonly id: FieldRef<"AudioFile", 'String'>
    readonly userId: FieldRef<"AudioFile", 'String'>
    readonly gcsUri: FieldRef<"AudioFile", 'String'>
    readonly filename: FieldRef<"AudioFile", 'String'>
    readonly durationMs: FieldRef<"AudioFile", 'Int'>
    readonly sizeBytes: FieldRef<"AudioFile", 'BigInt'>
    readonly language: FieldRef<"AudioFile", 'String'>
    readonly mode: FieldRef<"AudioFile", 'String'>
    readonly gapSec: FieldRef<"AudioFile", 'Float'>
    readonly status: FieldRef<"AudioFile", 'String'>
    readonly errorMessage: FieldRef<"AudioFile", 'String'>
    readonly meta: FieldRef<"AudioFile", 'Json'>
    readonly createdAt: FieldRef<"AudioFile", 'DateTime'>
    readonly updatedAt: FieldRef<"AudioFile", 'DateTime'>
    readonly deletedAt: FieldRef<"AudioFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioFile findUnique
   */
  export type AudioFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * Filter, which AudioFile to fetch.
     */
    where: AudioFileWhereUniqueInput
  }

  /**
   * AudioFile findUniqueOrThrow
   */
  export type AudioFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * Filter, which AudioFile to fetch.
     */
    where: AudioFileWhereUniqueInput
  }

  /**
   * AudioFile findFirst
   */
  export type AudioFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * Filter, which AudioFile to fetch.
     */
    where?: AudioFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioFiles to fetch.
     */
    orderBy?: AudioFileOrderByWithRelationInput | AudioFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioFiles.
     */
    cursor?: AudioFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioFiles.
     */
    distinct?: AudioFileScalarFieldEnum | AudioFileScalarFieldEnum[]
  }

  /**
   * AudioFile findFirstOrThrow
   */
  export type AudioFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * Filter, which AudioFile to fetch.
     */
    where?: AudioFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioFiles to fetch.
     */
    orderBy?: AudioFileOrderByWithRelationInput | AudioFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioFiles.
     */
    cursor?: AudioFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioFiles.
     */
    distinct?: AudioFileScalarFieldEnum | AudioFileScalarFieldEnum[]
  }

  /**
   * AudioFile findMany
   */
  export type AudioFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * Filter, which AudioFiles to fetch.
     */
    where?: AudioFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioFiles to fetch.
     */
    orderBy?: AudioFileOrderByWithRelationInput | AudioFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioFiles.
     */
    cursor?: AudioFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioFiles.
     */
    skip?: number
    distinct?: AudioFileScalarFieldEnum | AudioFileScalarFieldEnum[]
  }

  /**
   * AudioFile create
   */
  export type AudioFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioFile.
     */
    data: XOR<AudioFileCreateInput, AudioFileUncheckedCreateInput>
  }

  /**
   * AudioFile createMany
   */
  export type AudioFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioFiles.
     */
    data: AudioFileCreateManyInput | AudioFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioFile createManyAndReturn
   */
  export type AudioFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * The data used to create many AudioFiles.
     */
    data: AudioFileCreateManyInput | AudioFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioFile update
   */
  export type AudioFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioFile.
     */
    data: XOR<AudioFileUpdateInput, AudioFileUncheckedUpdateInput>
    /**
     * Choose, which AudioFile to update.
     */
    where: AudioFileWhereUniqueInput
  }

  /**
   * AudioFile updateMany
   */
  export type AudioFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioFiles.
     */
    data: XOR<AudioFileUpdateManyMutationInput, AudioFileUncheckedUpdateManyInput>
    /**
     * Filter which AudioFiles to update
     */
    where?: AudioFileWhereInput
    /**
     * Limit how many AudioFiles to update.
     */
    limit?: number
  }

  /**
   * AudioFile updateManyAndReturn
   */
  export type AudioFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * The data used to update AudioFiles.
     */
    data: XOR<AudioFileUpdateManyMutationInput, AudioFileUncheckedUpdateManyInput>
    /**
     * Filter which AudioFiles to update
     */
    where?: AudioFileWhereInput
    /**
     * Limit how many AudioFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioFile upsert
   */
  export type AudioFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioFile to update in case it exists.
     */
    where: AudioFileWhereUniqueInput
    /**
     * In case the AudioFile found by the `where` argument doesn't exist, create a new AudioFile with this data.
     */
    create: XOR<AudioFileCreateInput, AudioFileUncheckedCreateInput>
    /**
     * In case the AudioFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioFileUpdateInput, AudioFileUncheckedUpdateInput>
  }

  /**
   * AudioFile delete
   */
  export type AudioFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    /**
     * Filter which AudioFile to delete.
     */
    where: AudioFileWhereUniqueInput
  }

  /**
   * AudioFile deleteMany
   */
  export type AudioFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioFiles to delete
     */
    where?: AudioFileWhereInput
    /**
     * Limit how many AudioFiles to delete.
     */
    limit?: number
  }

  /**
   * AudioFile.transcriptRuns
   */
  export type AudioFile$transcriptRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    where?: TranscriptRunWhereInput
    orderBy?: TranscriptRunOrderByWithRelationInput | TranscriptRunOrderByWithRelationInput[]
    cursor?: TranscriptRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptRunScalarFieldEnum | TranscriptRunScalarFieldEnum[]
  }

  /**
   * AudioFile.tags
   */
  export type AudioFile$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    where?: AudioTagWhereInput
    orderBy?: AudioTagOrderByWithRelationInput | AudioTagOrderByWithRelationInput[]
    cursor?: AudioTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioTagScalarFieldEnum | AudioTagScalarFieldEnum[]
  }

  /**
   * AudioFile.Job
   */
  export type AudioFile$JobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * AudioFile.learningSessions
   */
  export type AudioFile$learningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    cursor?: LearningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * AudioFile without action
   */
  export type AudioFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
  }


  /**
   * Model TranscriptRun
   */

  export type AggregateTranscriptRun = {
    _count: TranscriptRunCountAggregateOutputType | null
    _avg: TranscriptRunAvgAggregateOutputType | null
    _sum: TranscriptRunSumAggregateOutputType | null
    _min: TranscriptRunMinAggregateOutputType | null
    _max: TranscriptRunMaxAggregateOutputType | null
  }

  export type TranscriptRunAvgAggregateOutputType = {
    version: number | null
    speakerCount: number | null
    confidence: number | null
  }

  export type TranscriptRunSumAggregateOutputType = {
    version: number | null
    speakerCount: number | null
    confidence: number | null
  }

  export type TranscriptRunMinAggregateOutputType = {
    id: string | null
    audioId: string | null
    authorId: string | null
    version: number | null
    engine: string | null
    paramsHash: string | null
    status: string | null
    error: string | null
    text: string | null
    speakerCount: number | null
    confidence: number | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type TranscriptRunMaxAggregateOutputType = {
    id: string | null
    audioId: string | null
    authorId: string | null
    version: number | null
    engine: string | null
    paramsHash: string | null
    status: string | null
    error: string | null
    text: string | null
    speakerCount: number | null
    confidence: number | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type TranscriptRunCountAggregateOutputType = {
    id: number
    audioId: number
    authorId: number
    version: number
    engine: number
    params: number
    paramsHash: number
    status: number
    error: number
    text: number
    segments: number
    speakerCount: number
    confidence: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type TranscriptRunAvgAggregateInputType = {
    version?: true
    speakerCount?: true
    confidence?: true
  }

  export type TranscriptRunSumAggregateInputType = {
    version?: true
    speakerCount?: true
    confidence?: true
  }

  export type TranscriptRunMinAggregateInputType = {
    id?: true
    audioId?: true
    authorId?: true
    version?: true
    engine?: true
    paramsHash?: true
    status?: true
    error?: true
    text?: true
    speakerCount?: true
    confidence?: true
    createdAt?: true
    completedAt?: true
  }

  export type TranscriptRunMaxAggregateInputType = {
    id?: true
    audioId?: true
    authorId?: true
    version?: true
    engine?: true
    paramsHash?: true
    status?: true
    error?: true
    text?: true
    speakerCount?: true
    confidence?: true
    createdAt?: true
    completedAt?: true
  }

  export type TranscriptRunCountAggregateInputType = {
    id?: true
    audioId?: true
    authorId?: true
    version?: true
    engine?: true
    params?: true
    paramsHash?: true
    status?: true
    error?: true
    text?: true
    segments?: true
    speakerCount?: true
    confidence?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type TranscriptRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptRun to aggregate.
     */
    where?: TranscriptRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRuns to fetch.
     */
    orderBy?: TranscriptRunOrderByWithRelationInput | TranscriptRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptRuns
    **/
    _count?: true | TranscriptRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptRunMaxAggregateInputType
  }

  export type GetTranscriptRunAggregateType<T extends TranscriptRunAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptRun[P]>
      : GetScalarType<T[P], AggregateTranscriptRun[P]>
  }




  export type TranscriptRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptRunWhereInput
    orderBy?: TranscriptRunOrderByWithAggregationInput | TranscriptRunOrderByWithAggregationInput[]
    by: TranscriptRunScalarFieldEnum[] | TranscriptRunScalarFieldEnum
    having?: TranscriptRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptRunCountAggregateInputType | true
    _avg?: TranscriptRunAvgAggregateInputType
    _sum?: TranscriptRunSumAggregateInputType
    _min?: TranscriptRunMinAggregateInputType
    _max?: TranscriptRunMaxAggregateInputType
  }

  export type TranscriptRunGroupByOutputType = {
    id: string
    audioId: string
    authorId: string | null
    version: number
    engine: string
    params: JsonValue | null
    paramsHash: string
    status: string
    error: string | null
    text: string | null
    segments: JsonValue | null
    speakerCount: number | null
    confidence: number | null
    createdAt: Date
    completedAt: Date | null
    _count: TranscriptRunCountAggregateOutputType | null
    _avg: TranscriptRunAvgAggregateOutputType | null
    _sum: TranscriptRunSumAggregateOutputType | null
    _min: TranscriptRunMinAggregateOutputType | null
    _max: TranscriptRunMaxAggregateOutputType | null
  }

  type GetTranscriptRunGroupByPayload<T extends TranscriptRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptRunGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptRunGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    authorId?: boolean
    version?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    error?: boolean
    text?: boolean
    segments?: boolean
    speakerCount?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
    author?: boolean | TranscriptRun$authorArgs<ExtArgs>
    revisions?: boolean | TranscriptRun$revisionsArgs<ExtArgs>
    annotations?: boolean | TranscriptRun$annotationsArgs<ExtArgs>
    jobs?: boolean | TranscriptRun$jobsArgs<ExtArgs>
    analyses?: boolean | TranscriptRun$analysesArgs<ExtArgs>
    learningSessions?: boolean | TranscriptRun$learningSessionsArgs<ExtArgs>
    _count?: boolean | TranscriptRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptRun"]>

  export type TranscriptRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    authorId?: boolean
    version?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    error?: boolean
    text?: boolean
    segments?: boolean
    speakerCount?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
    author?: boolean | TranscriptRun$authorArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptRun"]>

  export type TranscriptRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    authorId?: boolean
    version?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    error?: boolean
    text?: boolean
    segments?: boolean
    speakerCount?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
    author?: boolean | TranscriptRun$authorArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptRun"]>

  export type TranscriptRunSelectScalar = {
    id?: boolean
    audioId?: boolean
    authorId?: boolean
    version?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    error?: boolean
    text?: boolean
    segments?: boolean
    speakerCount?: boolean
    confidence?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type TranscriptRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "audioId" | "authorId" | "version" | "engine" | "params" | "paramsHash" | "status" | "error" | "text" | "segments" | "speakerCount" | "confidence" | "createdAt" | "completedAt", ExtArgs["result"]["transcriptRun"]>
  export type TranscriptRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
    author?: boolean | TranscriptRun$authorArgs<ExtArgs>
    revisions?: boolean | TranscriptRun$revisionsArgs<ExtArgs>
    annotations?: boolean | TranscriptRun$annotationsArgs<ExtArgs>
    jobs?: boolean | TranscriptRun$jobsArgs<ExtArgs>
    analyses?: boolean | TranscriptRun$analysesArgs<ExtArgs>
    learningSessions?: boolean | TranscriptRun$learningSessionsArgs<ExtArgs>
    _count?: boolean | TranscriptRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TranscriptRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
    author?: boolean | TranscriptRun$authorArgs<ExtArgs>
  }
  export type TranscriptRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
    author?: boolean | TranscriptRun$authorArgs<ExtArgs>
  }

  export type $TranscriptRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranscriptRun"
    objects: {
      audio: Prisma.$AudioFilePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs> | null
      revisions: Prisma.$TranscriptRevisionPayload<ExtArgs>[]
      annotations: Prisma.$AnnotationPayload<ExtArgs>[]
      jobs: Prisma.$JobPayload<ExtArgs>[]
      analyses: Prisma.$AnalysisPayload<ExtArgs>[]
      learningSessions: Prisma.$LearningSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      audioId: string
      authorId: string | null
      version: number
      engine: string
      params: Prisma.JsonValue | null
      paramsHash: string
      status: string
      error: string | null
      text: string | null
      segments: Prisma.JsonValue | null
      speakerCount: number | null
      confidence: number | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["transcriptRun"]>
    composites: {}
  }

  type TranscriptRunGetPayload<S extends boolean | null | undefined | TranscriptRunDefaultArgs> = $Result.GetResult<Prisma.$TranscriptRunPayload, S>

  type TranscriptRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptRunCountAggregateInputType | true
    }

  export interface TranscriptRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranscriptRun'], meta: { name: 'TranscriptRun' } }
    /**
     * Find zero or one TranscriptRun that matches the filter.
     * @param {TranscriptRunFindUniqueArgs} args - Arguments to find a TranscriptRun
     * @example
     * // Get one TranscriptRun
     * const transcriptRun = await prisma.transcriptRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptRunFindUniqueArgs>(args: SelectSubset<T, TranscriptRunFindUniqueArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TranscriptRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptRunFindUniqueOrThrowArgs} args - Arguments to find a TranscriptRun
     * @example
     * // Get one TranscriptRun
     * const transcriptRun = await prisma.transcriptRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptRunFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunFindFirstArgs} args - Arguments to find a TranscriptRun
     * @example
     * // Get one TranscriptRun
     * const transcriptRun = await prisma.transcriptRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptRunFindFirstArgs>(args?: SelectSubset<T, TranscriptRunFindFirstArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunFindFirstOrThrowArgs} args - Arguments to find a TranscriptRun
     * @example
     * // Get one TranscriptRun
     * const transcriptRun = await prisma.transcriptRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptRunFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TranscriptRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptRuns
     * const transcriptRuns = await prisma.transcriptRun.findMany()
     * 
     * // Get first 10 TranscriptRuns
     * const transcriptRuns = await prisma.transcriptRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptRunWithIdOnly = await prisma.transcriptRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptRunFindManyArgs>(args?: SelectSubset<T, TranscriptRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TranscriptRun.
     * @param {TranscriptRunCreateArgs} args - Arguments to create a TranscriptRun.
     * @example
     * // Create one TranscriptRun
     * const TranscriptRun = await prisma.transcriptRun.create({
     *   data: {
     *     // ... data to create a TranscriptRun
     *   }
     * })
     * 
     */
    create<T extends TranscriptRunCreateArgs>(args: SelectSubset<T, TranscriptRunCreateArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TranscriptRuns.
     * @param {TranscriptRunCreateManyArgs} args - Arguments to create many TranscriptRuns.
     * @example
     * // Create many TranscriptRuns
     * const transcriptRun = await prisma.transcriptRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptRunCreateManyArgs>(args?: SelectSubset<T, TranscriptRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranscriptRuns and returns the data saved in the database.
     * @param {TranscriptRunCreateManyAndReturnArgs} args - Arguments to create many TranscriptRuns.
     * @example
     * // Create many TranscriptRuns
     * const transcriptRun = await prisma.transcriptRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranscriptRuns and only return the `id`
     * const transcriptRunWithIdOnly = await prisma.transcriptRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptRunCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TranscriptRun.
     * @param {TranscriptRunDeleteArgs} args - Arguments to delete one TranscriptRun.
     * @example
     * // Delete one TranscriptRun
     * const TranscriptRun = await prisma.transcriptRun.delete({
     *   where: {
     *     // ... filter to delete one TranscriptRun
     *   }
     * })
     * 
     */
    delete<T extends TranscriptRunDeleteArgs>(args: SelectSubset<T, TranscriptRunDeleteArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TranscriptRun.
     * @param {TranscriptRunUpdateArgs} args - Arguments to update one TranscriptRun.
     * @example
     * // Update one TranscriptRun
     * const transcriptRun = await prisma.transcriptRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptRunUpdateArgs>(args: SelectSubset<T, TranscriptRunUpdateArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TranscriptRuns.
     * @param {TranscriptRunDeleteManyArgs} args - Arguments to filter TranscriptRuns to delete.
     * @example
     * // Delete a few TranscriptRuns
     * const { count } = await prisma.transcriptRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptRunDeleteManyArgs>(args?: SelectSubset<T, TranscriptRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptRuns
     * const transcriptRun = await prisma.transcriptRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptRunUpdateManyArgs>(args: SelectSubset<T, TranscriptRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptRuns and returns the data updated in the database.
     * @param {TranscriptRunUpdateManyAndReturnArgs} args - Arguments to update many TranscriptRuns.
     * @example
     * // Update many TranscriptRuns
     * const transcriptRun = await prisma.transcriptRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TranscriptRuns and only return the `id`
     * const transcriptRunWithIdOnly = await prisma.transcriptRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranscriptRunUpdateManyAndReturnArgs>(args: SelectSubset<T, TranscriptRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TranscriptRun.
     * @param {TranscriptRunUpsertArgs} args - Arguments to update or create a TranscriptRun.
     * @example
     * // Update or create a TranscriptRun
     * const transcriptRun = await prisma.transcriptRun.upsert({
     *   create: {
     *     // ... data to create a TranscriptRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptRun we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptRunUpsertArgs>(args: SelectSubset<T, TranscriptRunUpsertArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TranscriptRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunCountArgs} args - Arguments to filter TranscriptRuns to count.
     * @example
     * // Count the number of TranscriptRuns
     * const count = await prisma.transcriptRun.count({
     *   where: {
     *     // ... the filter for the TranscriptRuns we want to count
     *   }
     * })
    **/
    count<T extends TranscriptRunCountArgs>(
      args?: Subset<T, TranscriptRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptRunAggregateArgs>(args: Subset<T, TranscriptRunAggregateArgs>): Prisma.PrismaPromise<GetTranscriptRunAggregateType<T>>

    /**
     * Group by TranscriptRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptRunGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranscriptRun model
   */
  readonly fields: TranscriptRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audio<T extends AudioFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioFileDefaultArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends TranscriptRun$authorArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRun$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    revisions<T extends TranscriptRun$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRun$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    annotations<T extends TranscriptRun$annotationsArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRun$annotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends TranscriptRun$jobsArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRun$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analyses<T extends TranscriptRun$analysesArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRun$analysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningSessions<T extends TranscriptRun$learningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRun$learningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranscriptRun model
   */
  interface TranscriptRunFieldRefs {
    readonly id: FieldRef<"TranscriptRun", 'String'>
    readonly audioId: FieldRef<"TranscriptRun", 'String'>
    readonly authorId: FieldRef<"TranscriptRun", 'String'>
    readonly version: FieldRef<"TranscriptRun", 'Int'>
    readonly engine: FieldRef<"TranscriptRun", 'String'>
    readonly params: FieldRef<"TranscriptRun", 'Json'>
    readonly paramsHash: FieldRef<"TranscriptRun", 'String'>
    readonly status: FieldRef<"TranscriptRun", 'String'>
    readonly error: FieldRef<"TranscriptRun", 'String'>
    readonly text: FieldRef<"TranscriptRun", 'String'>
    readonly segments: FieldRef<"TranscriptRun", 'Json'>
    readonly speakerCount: FieldRef<"TranscriptRun", 'Int'>
    readonly confidence: FieldRef<"TranscriptRun", 'Float'>
    readonly createdAt: FieldRef<"TranscriptRun", 'DateTime'>
    readonly completedAt: FieldRef<"TranscriptRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TranscriptRun findUnique
   */
  export type TranscriptRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRun to fetch.
     */
    where: TranscriptRunWhereUniqueInput
  }

  /**
   * TranscriptRun findUniqueOrThrow
   */
  export type TranscriptRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRun to fetch.
     */
    where: TranscriptRunWhereUniqueInput
  }

  /**
   * TranscriptRun findFirst
   */
  export type TranscriptRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRun to fetch.
     */
    where?: TranscriptRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRuns to fetch.
     */
    orderBy?: TranscriptRunOrderByWithRelationInput | TranscriptRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptRuns.
     */
    cursor?: TranscriptRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptRuns.
     */
    distinct?: TranscriptRunScalarFieldEnum | TranscriptRunScalarFieldEnum[]
  }

  /**
   * TranscriptRun findFirstOrThrow
   */
  export type TranscriptRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRun to fetch.
     */
    where?: TranscriptRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRuns to fetch.
     */
    orderBy?: TranscriptRunOrderByWithRelationInput | TranscriptRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptRuns.
     */
    cursor?: TranscriptRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptRuns.
     */
    distinct?: TranscriptRunScalarFieldEnum | TranscriptRunScalarFieldEnum[]
  }

  /**
   * TranscriptRun findMany
   */
  export type TranscriptRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRuns to fetch.
     */
    where?: TranscriptRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRuns to fetch.
     */
    orderBy?: TranscriptRunOrderByWithRelationInput | TranscriptRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptRuns.
     */
    cursor?: TranscriptRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRuns.
     */
    skip?: number
    distinct?: TranscriptRunScalarFieldEnum | TranscriptRunScalarFieldEnum[]
  }

  /**
   * TranscriptRun create
   */
  export type TranscriptRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * The data needed to create a TranscriptRun.
     */
    data: XOR<TranscriptRunCreateInput, TranscriptRunUncheckedCreateInput>
  }

  /**
   * TranscriptRun createMany
   */
  export type TranscriptRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranscriptRuns.
     */
    data: TranscriptRunCreateManyInput | TranscriptRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranscriptRun createManyAndReturn
   */
  export type TranscriptRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * The data used to create many TranscriptRuns.
     */
    data: TranscriptRunCreateManyInput | TranscriptRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptRun update
   */
  export type TranscriptRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * The data needed to update a TranscriptRun.
     */
    data: XOR<TranscriptRunUpdateInput, TranscriptRunUncheckedUpdateInput>
    /**
     * Choose, which TranscriptRun to update.
     */
    where: TranscriptRunWhereUniqueInput
  }

  /**
   * TranscriptRun updateMany
   */
  export type TranscriptRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranscriptRuns.
     */
    data: XOR<TranscriptRunUpdateManyMutationInput, TranscriptRunUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptRuns to update
     */
    where?: TranscriptRunWhereInput
    /**
     * Limit how many TranscriptRuns to update.
     */
    limit?: number
  }

  /**
   * TranscriptRun updateManyAndReturn
   */
  export type TranscriptRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * The data used to update TranscriptRuns.
     */
    data: XOR<TranscriptRunUpdateManyMutationInput, TranscriptRunUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptRuns to update
     */
    where?: TranscriptRunWhereInput
    /**
     * Limit how many TranscriptRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptRun upsert
   */
  export type TranscriptRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * The filter to search for the TranscriptRun to update in case it exists.
     */
    where: TranscriptRunWhereUniqueInput
    /**
     * In case the TranscriptRun found by the `where` argument doesn't exist, create a new TranscriptRun with this data.
     */
    create: XOR<TranscriptRunCreateInput, TranscriptRunUncheckedCreateInput>
    /**
     * In case the TranscriptRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptRunUpdateInput, TranscriptRunUncheckedUpdateInput>
  }

  /**
   * TranscriptRun delete
   */
  export type TranscriptRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    /**
     * Filter which TranscriptRun to delete.
     */
    where: TranscriptRunWhereUniqueInput
  }

  /**
   * TranscriptRun deleteMany
   */
  export type TranscriptRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptRuns to delete
     */
    where?: TranscriptRunWhereInput
    /**
     * Limit how many TranscriptRuns to delete.
     */
    limit?: number
  }

  /**
   * TranscriptRun.author
   */
  export type TranscriptRun$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TranscriptRun.revisions
   */
  export type TranscriptRun$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    where?: TranscriptRevisionWhereInput
    orderBy?: TranscriptRevisionOrderByWithRelationInput | TranscriptRevisionOrderByWithRelationInput[]
    cursor?: TranscriptRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptRevisionScalarFieldEnum | TranscriptRevisionScalarFieldEnum[]
  }

  /**
   * TranscriptRun.annotations
   */
  export type TranscriptRun$annotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    cursor?: AnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * TranscriptRun.jobs
   */
  export type TranscriptRun$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * TranscriptRun.analyses
   */
  export type TranscriptRun$analysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    where?: AnalysisWhereInput
    orderBy?: AnalysisOrderByWithRelationInput | AnalysisOrderByWithRelationInput[]
    cursor?: AnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisScalarFieldEnum | AnalysisScalarFieldEnum[]
  }

  /**
   * TranscriptRun.learningSessions
   */
  export type TranscriptRun$learningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    cursor?: LearningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * TranscriptRun without action
   */
  export type TranscriptRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
  }


  /**
   * Model TranscriptRevision
   */

  export type AggregateTranscriptRevision = {
    _count: TranscriptRevisionCountAggregateOutputType | null
    _min: TranscriptRevisionMinAggregateOutputType | null
    _max: TranscriptRevisionMaxAggregateOutputType | null
  }

  export type TranscriptRevisionMinAggregateOutputType = {
    id: string | null
    runId: string | null
    title: string | null
    text: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TranscriptRevisionMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    title: string | null
    text: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TranscriptRevisionCountAggregateOutputType = {
    id: number
    runId: number
    title: number
    text: number
    segments: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type TranscriptRevisionMinAggregateInputType = {
    id?: true
    runId?: true
    title?: true
    text?: true
    createdBy?: true
    createdAt?: true
  }

  export type TranscriptRevisionMaxAggregateInputType = {
    id?: true
    runId?: true
    title?: true
    text?: true
    createdBy?: true
    createdAt?: true
  }

  export type TranscriptRevisionCountAggregateInputType = {
    id?: true
    runId?: true
    title?: true
    text?: true
    segments?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type TranscriptRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptRevision to aggregate.
     */
    where?: TranscriptRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRevisions to fetch.
     */
    orderBy?: TranscriptRevisionOrderByWithRelationInput | TranscriptRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptRevisions
    **/
    _count?: true | TranscriptRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptRevisionMaxAggregateInputType
  }

  export type GetTranscriptRevisionAggregateType<T extends TranscriptRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptRevision[P]>
      : GetScalarType<T[P], AggregateTranscriptRevision[P]>
  }




  export type TranscriptRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptRevisionWhereInput
    orderBy?: TranscriptRevisionOrderByWithAggregationInput | TranscriptRevisionOrderByWithAggregationInput[]
    by: TranscriptRevisionScalarFieldEnum[] | TranscriptRevisionScalarFieldEnum
    having?: TranscriptRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptRevisionCountAggregateInputType | true
    _min?: TranscriptRevisionMinAggregateInputType
    _max?: TranscriptRevisionMaxAggregateInputType
  }

  export type TranscriptRevisionGroupByOutputType = {
    id: string
    runId: string
    title: string | null
    text: string
    segments: JsonValue | null
    createdBy: string | null
    createdAt: Date
    _count: TranscriptRevisionCountAggregateOutputType | null
    _min: TranscriptRevisionMinAggregateOutputType | null
    _max: TranscriptRevisionMaxAggregateOutputType | null
  }

  type GetTranscriptRevisionGroupByPayload<T extends TranscriptRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptRevisionGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    title?: boolean
    text?: boolean
    segments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptRevision"]>

  export type TranscriptRevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    title?: boolean
    text?: boolean
    segments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptRevision"]>

  export type TranscriptRevisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    title?: boolean
    text?: boolean
    segments?: boolean
    createdBy?: boolean
    createdAt?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptRevision"]>

  export type TranscriptRevisionSelectScalar = {
    id?: boolean
    runId?: boolean
    title?: boolean
    text?: boolean
    segments?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type TranscriptRevisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "title" | "text" | "segments" | "createdBy" | "createdAt", ExtArgs["result"]["transcriptRevision"]>
  export type TranscriptRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }
  export type TranscriptRevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }
  export type TranscriptRevisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }

  export type $TranscriptRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranscriptRevision"
    objects: {
      run: Prisma.$TranscriptRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      title: string | null
      text: string
      segments: Prisma.JsonValue | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["transcriptRevision"]>
    composites: {}
  }

  type TranscriptRevisionGetPayload<S extends boolean | null | undefined | TranscriptRevisionDefaultArgs> = $Result.GetResult<Prisma.$TranscriptRevisionPayload, S>

  type TranscriptRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptRevisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptRevisionCountAggregateInputType | true
    }

  export interface TranscriptRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranscriptRevision'], meta: { name: 'TranscriptRevision' } }
    /**
     * Find zero or one TranscriptRevision that matches the filter.
     * @param {TranscriptRevisionFindUniqueArgs} args - Arguments to find a TranscriptRevision
     * @example
     * // Get one TranscriptRevision
     * const transcriptRevision = await prisma.transcriptRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptRevisionFindUniqueArgs>(args: SelectSubset<T, TranscriptRevisionFindUniqueArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TranscriptRevision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptRevisionFindUniqueOrThrowArgs} args - Arguments to find a TranscriptRevision
     * @example
     * // Get one TranscriptRevision
     * const transcriptRevision = await prisma.transcriptRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionFindFirstArgs} args - Arguments to find a TranscriptRevision
     * @example
     * // Get one TranscriptRevision
     * const transcriptRevision = await prisma.transcriptRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptRevisionFindFirstArgs>(args?: SelectSubset<T, TranscriptRevisionFindFirstArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionFindFirstOrThrowArgs} args - Arguments to find a TranscriptRevision
     * @example
     * // Get one TranscriptRevision
     * const transcriptRevision = await prisma.transcriptRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TranscriptRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptRevisions
     * const transcriptRevisions = await prisma.transcriptRevision.findMany()
     * 
     * // Get first 10 TranscriptRevisions
     * const transcriptRevisions = await prisma.transcriptRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptRevisionWithIdOnly = await prisma.transcriptRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptRevisionFindManyArgs>(args?: SelectSubset<T, TranscriptRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TranscriptRevision.
     * @param {TranscriptRevisionCreateArgs} args - Arguments to create a TranscriptRevision.
     * @example
     * // Create one TranscriptRevision
     * const TranscriptRevision = await prisma.transcriptRevision.create({
     *   data: {
     *     // ... data to create a TranscriptRevision
     *   }
     * })
     * 
     */
    create<T extends TranscriptRevisionCreateArgs>(args: SelectSubset<T, TranscriptRevisionCreateArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TranscriptRevisions.
     * @param {TranscriptRevisionCreateManyArgs} args - Arguments to create many TranscriptRevisions.
     * @example
     * // Create many TranscriptRevisions
     * const transcriptRevision = await prisma.transcriptRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptRevisionCreateManyArgs>(args?: SelectSubset<T, TranscriptRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TranscriptRevisions and returns the data saved in the database.
     * @param {TranscriptRevisionCreateManyAndReturnArgs} args - Arguments to create many TranscriptRevisions.
     * @example
     * // Create many TranscriptRevisions
     * const transcriptRevision = await prisma.transcriptRevision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TranscriptRevisions and only return the `id`
     * const transcriptRevisionWithIdOnly = await prisma.transcriptRevision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranscriptRevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, TranscriptRevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TranscriptRevision.
     * @param {TranscriptRevisionDeleteArgs} args - Arguments to delete one TranscriptRevision.
     * @example
     * // Delete one TranscriptRevision
     * const TranscriptRevision = await prisma.transcriptRevision.delete({
     *   where: {
     *     // ... filter to delete one TranscriptRevision
     *   }
     * })
     * 
     */
    delete<T extends TranscriptRevisionDeleteArgs>(args: SelectSubset<T, TranscriptRevisionDeleteArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TranscriptRevision.
     * @param {TranscriptRevisionUpdateArgs} args - Arguments to update one TranscriptRevision.
     * @example
     * // Update one TranscriptRevision
     * const transcriptRevision = await prisma.transcriptRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptRevisionUpdateArgs>(args: SelectSubset<T, TranscriptRevisionUpdateArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TranscriptRevisions.
     * @param {TranscriptRevisionDeleteManyArgs} args - Arguments to filter TranscriptRevisions to delete.
     * @example
     * // Delete a few TranscriptRevisions
     * const { count } = await prisma.transcriptRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptRevisionDeleteManyArgs>(args?: SelectSubset<T, TranscriptRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptRevisions
     * const transcriptRevision = await prisma.transcriptRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptRevisionUpdateManyArgs>(args: SelectSubset<T, TranscriptRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptRevisions and returns the data updated in the database.
     * @param {TranscriptRevisionUpdateManyAndReturnArgs} args - Arguments to update many TranscriptRevisions.
     * @example
     * // Update many TranscriptRevisions
     * const transcriptRevision = await prisma.transcriptRevision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TranscriptRevisions and only return the `id`
     * const transcriptRevisionWithIdOnly = await prisma.transcriptRevision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TranscriptRevisionUpdateManyAndReturnArgs>(args: SelectSubset<T, TranscriptRevisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TranscriptRevision.
     * @param {TranscriptRevisionUpsertArgs} args - Arguments to update or create a TranscriptRevision.
     * @example
     * // Update or create a TranscriptRevision
     * const transcriptRevision = await prisma.transcriptRevision.upsert({
     *   create: {
     *     // ... data to create a TranscriptRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptRevision we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptRevisionUpsertArgs>(args: SelectSubset<T, TranscriptRevisionUpsertArgs<ExtArgs>>): Prisma__TranscriptRevisionClient<$Result.GetResult<Prisma.$TranscriptRevisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TranscriptRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionCountArgs} args - Arguments to filter TranscriptRevisions to count.
     * @example
     * // Count the number of TranscriptRevisions
     * const count = await prisma.transcriptRevision.count({
     *   where: {
     *     // ... the filter for the TranscriptRevisions we want to count
     *   }
     * })
    **/
    count<T extends TranscriptRevisionCountArgs>(
      args?: Subset<T, TranscriptRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptRevisionAggregateArgs>(args: Subset<T, TranscriptRevisionAggregateArgs>): Prisma.PrismaPromise<GetTranscriptRevisionAggregateType<T>>

    /**
     * Group by TranscriptRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptRevisionGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranscriptRevision model
   */
  readonly fields: TranscriptRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends TranscriptRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRunDefaultArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranscriptRevision model
   */
  interface TranscriptRevisionFieldRefs {
    readonly id: FieldRef<"TranscriptRevision", 'String'>
    readonly runId: FieldRef<"TranscriptRevision", 'String'>
    readonly title: FieldRef<"TranscriptRevision", 'String'>
    readonly text: FieldRef<"TranscriptRevision", 'String'>
    readonly segments: FieldRef<"TranscriptRevision", 'Json'>
    readonly createdBy: FieldRef<"TranscriptRevision", 'String'>
    readonly createdAt: FieldRef<"TranscriptRevision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TranscriptRevision findUnique
   */
  export type TranscriptRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRevision to fetch.
     */
    where: TranscriptRevisionWhereUniqueInput
  }

  /**
   * TranscriptRevision findUniqueOrThrow
   */
  export type TranscriptRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRevision to fetch.
     */
    where: TranscriptRevisionWhereUniqueInput
  }

  /**
   * TranscriptRevision findFirst
   */
  export type TranscriptRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRevision to fetch.
     */
    where?: TranscriptRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRevisions to fetch.
     */
    orderBy?: TranscriptRevisionOrderByWithRelationInput | TranscriptRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptRevisions.
     */
    cursor?: TranscriptRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptRevisions.
     */
    distinct?: TranscriptRevisionScalarFieldEnum | TranscriptRevisionScalarFieldEnum[]
  }

  /**
   * TranscriptRevision findFirstOrThrow
   */
  export type TranscriptRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRevision to fetch.
     */
    where?: TranscriptRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRevisions to fetch.
     */
    orderBy?: TranscriptRevisionOrderByWithRelationInput | TranscriptRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptRevisions.
     */
    cursor?: TranscriptRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptRevisions.
     */
    distinct?: TranscriptRevisionScalarFieldEnum | TranscriptRevisionScalarFieldEnum[]
  }

  /**
   * TranscriptRevision findMany
   */
  export type TranscriptRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptRevisions to fetch.
     */
    where?: TranscriptRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptRevisions to fetch.
     */
    orderBy?: TranscriptRevisionOrderByWithRelationInput | TranscriptRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptRevisions.
     */
    cursor?: TranscriptRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptRevisions.
     */
    skip?: number
    distinct?: TranscriptRevisionScalarFieldEnum | TranscriptRevisionScalarFieldEnum[]
  }

  /**
   * TranscriptRevision create
   */
  export type TranscriptRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a TranscriptRevision.
     */
    data: XOR<TranscriptRevisionCreateInput, TranscriptRevisionUncheckedCreateInput>
  }

  /**
   * TranscriptRevision createMany
   */
  export type TranscriptRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranscriptRevisions.
     */
    data: TranscriptRevisionCreateManyInput | TranscriptRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranscriptRevision createManyAndReturn
   */
  export type TranscriptRevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * The data used to create many TranscriptRevisions.
     */
    data: TranscriptRevisionCreateManyInput | TranscriptRevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptRevision update
   */
  export type TranscriptRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a TranscriptRevision.
     */
    data: XOR<TranscriptRevisionUpdateInput, TranscriptRevisionUncheckedUpdateInput>
    /**
     * Choose, which TranscriptRevision to update.
     */
    where: TranscriptRevisionWhereUniqueInput
  }

  /**
   * TranscriptRevision updateMany
   */
  export type TranscriptRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranscriptRevisions.
     */
    data: XOR<TranscriptRevisionUpdateManyMutationInput, TranscriptRevisionUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptRevisions to update
     */
    where?: TranscriptRevisionWhereInput
    /**
     * Limit how many TranscriptRevisions to update.
     */
    limit?: number
  }

  /**
   * TranscriptRevision updateManyAndReturn
   */
  export type TranscriptRevisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * The data used to update TranscriptRevisions.
     */
    data: XOR<TranscriptRevisionUpdateManyMutationInput, TranscriptRevisionUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptRevisions to update
     */
    where?: TranscriptRevisionWhereInput
    /**
     * Limit how many TranscriptRevisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TranscriptRevision upsert
   */
  export type TranscriptRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the TranscriptRevision to update in case it exists.
     */
    where: TranscriptRevisionWhereUniqueInput
    /**
     * In case the TranscriptRevision found by the `where` argument doesn't exist, create a new TranscriptRevision with this data.
     */
    create: XOR<TranscriptRevisionCreateInput, TranscriptRevisionUncheckedCreateInput>
    /**
     * In case the TranscriptRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptRevisionUpdateInput, TranscriptRevisionUncheckedUpdateInput>
  }

  /**
   * TranscriptRevision delete
   */
  export type TranscriptRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
    /**
     * Filter which TranscriptRevision to delete.
     */
    where: TranscriptRevisionWhereUniqueInput
  }

  /**
   * TranscriptRevision deleteMany
   */
  export type TranscriptRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptRevisions to delete
     */
    where?: TranscriptRevisionWhereInput
    /**
     * Limit how many TranscriptRevisions to delete.
     */
    limit?: number
  }

  /**
   * TranscriptRevision without action
   */
  export type TranscriptRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRevision
     */
    select?: TranscriptRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRevision
     */
    omit?: TranscriptRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRevisionInclude<ExtArgs> | null
  }


  /**
   * Model Analysis
   */

  export type AggregateAnalysis = {
    _count: AnalysisCountAggregateOutputType | null
    _avg: AnalysisAvgAggregateOutputType | null
    _sum: AnalysisSumAggregateOutputType | null
    _min: AnalysisMinAggregateOutputType | null
    _max: AnalysisMaxAggregateOutputType | null
  }

  export type AnalysisAvgAggregateOutputType = {
    segmentIndex: number | null
    score: number | null
  }

  export type AnalysisSumAggregateOutputType = {
    segmentIndex: number | null
    score: number | null
  }

  export type AnalysisMinAggregateOutputType = {
    id: string | null
    runId: string | null
    segmentIndex: number | null
    kind: string | null
    engine: string | null
    paramsHash: string | null
    status: string | null
    summary: string | null
    score: number | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type AnalysisMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    segmentIndex: number | null
    kind: string | null
    engine: string | null
    paramsHash: string | null
    status: string | null
    summary: string | null
    score: number | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type AnalysisCountAggregateOutputType = {
    id: number
    runId: number
    segmentIndex: number
    kind: number
    engine: number
    params: number
    paramsHash: number
    status: number
    summary: number
    score: number
    result: number
    error: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type AnalysisAvgAggregateInputType = {
    segmentIndex?: true
    score?: true
  }

  export type AnalysisSumAggregateInputType = {
    segmentIndex?: true
    score?: true
  }

  export type AnalysisMinAggregateInputType = {
    id?: true
    runId?: true
    segmentIndex?: true
    kind?: true
    engine?: true
    paramsHash?: true
    status?: true
    summary?: true
    score?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type AnalysisMaxAggregateInputType = {
    id?: true
    runId?: true
    segmentIndex?: true
    kind?: true
    engine?: true
    paramsHash?: true
    status?: true
    summary?: true
    score?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type AnalysisCountAggregateInputType = {
    id?: true
    runId?: true
    segmentIndex?: true
    kind?: true
    engine?: true
    params?: true
    paramsHash?: true
    status?: true
    summary?: true
    score?: true
    result?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type AnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analysis to aggregate.
     */
    where?: AnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analyses to fetch.
     */
    orderBy?: AnalysisOrderByWithRelationInput | AnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analyses
    **/
    _count?: true | AnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisMaxAggregateInputType
  }

  export type GetAnalysisAggregateType<T extends AnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysis[P]>
      : GetScalarType<T[P], AggregateAnalysis[P]>
  }




  export type AnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisWhereInput
    orderBy?: AnalysisOrderByWithAggregationInput | AnalysisOrderByWithAggregationInput[]
    by: AnalysisScalarFieldEnum[] | AnalysisScalarFieldEnum
    having?: AnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisCountAggregateInputType | true
    _avg?: AnalysisAvgAggregateInputType
    _sum?: AnalysisSumAggregateInputType
    _min?: AnalysisMinAggregateInputType
    _max?: AnalysisMaxAggregateInputType
  }

  export type AnalysisGroupByOutputType = {
    id: string
    runId: string
    segmentIndex: number | null
    kind: string
    engine: string
    params: JsonValue | null
    paramsHash: string
    status: string
    summary: string | null
    score: number | null
    result: JsonValue | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: AnalysisCountAggregateOutputType | null
    _avg: AnalysisAvgAggregateOutputType | null
    _sum: AnalysisSumAggregateOutputType | null
    _min: AnalysisMinAggregateOutputType | null
    _max: AnalysisMaxAggregateOutputType | null
  }

  type GetAnalysisGroupByPayload<T extends AnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    segmentIndex?: boolean
    kind?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    summary?: boolean
    score?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysis"]>

  export type AnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    segmentIndex?: boolean
    kind?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    summary?: boolean
    score?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysis"]>

  export type AnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    segmentIndex?: boolean
    kind?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    summary?: boolean
    score?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysis"]>

  export type AnalysisSelectScalar = {
    id?: boolean
    runId?: boolean
    segmentIndex?: boolean
    kind?: boolean
    engine?: boolean
    params?: boolean
    paramsHash?: boolean
    status?: boolean
    summary?: boolean
    score?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type AnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "segmentIndex" | "kind" | "engine" | "params" | "paramsHash" | "status" | "summary" | "score" | "result" | "error" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["analysis"]>
  export type AnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }
  export type AnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }
  export type AnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }

  export type $AnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analysis"
    objects: {
      run: Prisma.$TranscriptRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      segmentIndex: number | null
      kind: string
      engine: string
      params: Prisma.JsonValue | null
      paramsHash: string
      status: string
      summary: string | null
      score: number | null
      result: Prisma.JsonValue | null
      error: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["analysis"]>
    composites: {}
  }

  type AnalysisGetPayload<S extends boolean | null | undefined | AnalysisDefaultArgs> = $Result.GetResult<Prisma.$AnalysisPayload, S>

  type AnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisCountAggregateInputType | true
    }

  export interface AnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analysis'], meta: { name: 'Analysis' } }
    /**
     * Find zero or one Analysis that matches the filter.
     * @param {AnalysisFindUniqueArgs} args - Arguments to find a Analysis
     * @example
     * // Get one Analysis
     * const analysis = await prisma.analysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisFindUniqueArgs>(args: SelectSubset<T, AnalysisFindUniqueArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Analysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisFindUniqueOrThrowArgs} args - Arguments to find a Analysis
     * @example
     * // Get one Analysis
     * const analysis = await prisma.analysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFindFirstArgs} args - Arguments to find a Analysis
     * @example
     * // Get one Analysis
     * const analysis = await prisma.analysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisFindFirstArgs>(args?: SelectSubset<T, AnalysisFindFirstArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFindFirstOrThrowArgs} args - Arguments to find a Analysis
     * @example
     * // Get one Analysis
     * const analysis = await prisma.analysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Analyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analyses
     * const analyses = await prisma.analysis.findMany()
     * 
     * // Get first 10 Analyses
     * const analyses = await prisma.analysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisWithIdOnly = await prisma.analysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisFindManyArgs>(args?: SelectSubset<T, AnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Analysis.
     * @param {AnalysisCreateArgs} args - Arguments to create a Analysis.
     * @example
     * // Create one Analysis
     * const Analysis = await prisma.analysis.create({
     *   data: {
     *     // ... data to create a Analysis
     *   }
     * })
     * 
     */
    create<T extends AnalysisCreateArgs>(args: SelectSubset<T, AnalysisCreateArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Analyses.
     * @param {AnalysisCreateManyArgs} args - Arguments to create many Analyses.
     * @example
     * // Create many Analyses
     * const analysis = await prisma.analysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisCreateManyArgs>(args?: SelectSubset<T, AnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analyses and returns the data saved in the database.
     * @param {AnalysisCreateManyAndReturnArgs} args - Arguments to create many Analyses.
     * @example
     * // Create many Analyses
     * const analysis = await prisma.analysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analyses and only return the `id`
     * const analysisWithIdOnly = await prisma.analysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Analysis.
     * @param {AnalysisDeleteArgs} args - Arguments to delete one Analysis.
     * @example
     * // Delete one Analysis
     * const Analysis = await prisma.analysis.delete({
     *   where: {
     *     // ... filter to delete one Analysis
     *   }
     * })
     * 
     */
    delete<T extends AnalysisDeleteArgs>(args: SelectSubset<T, AnalysisDeleteArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Analysis.
     * @param {AnalysisUpdateArgs} args - Arguments to update one Analysis.
     * @example
     * // Update one Analysis
     * const analysis = await prisma.analysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisUpdateArgs>(args: SelectSubset<T, AnalysisUpdateArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Analyses.
     * @param {AnalysisDeleteManyArgs} args - Arguments to filter Analyses to delete.
     * @example
     * // Delete a few Analyses
     * const { count } = await prisma.analysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisDeleteManyArgs>(args?: SelectSubset<T, AnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analyses
     * const analysis = await prisma.analysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisUpdateManyArgs>(args: SelectSubset<T, AnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analyses and returns the data updated in the database.
     * @param {AnalysisUpdateManyAndReturnArgs} args - Arguments to update many Analyses.
     * @example
     * // Update many Analyses
     * const analysis = await prisma.analysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Analyses and only return the `id`
     * const analysisWithIdOnly = await prisma.analysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Analysis.
     * @param {AnalysisUpsertArgs} args - Arguments to update or create a Analysis.
     * @example
     * // Update or create a Analysis
     * const analysis = await prisma.analysis.upsert({
     *   create: {
     *     // ... data to create a Analysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analysis we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisUpsertArgs>(args: SelectSubset<T, AnalysisUpsertArgs<ExtArgs>>): Prisma__AnalysisClient<$Result.GetResult<Prisma.$AnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Analyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisCountArgs} args - Arguments to filter Analyses to count.
     * @example
     * // Count the number of Analyses
     * const count = await prisma.analysis.count({
     *   where: {
     *     // ... the filter for the Analyses we want to count
     *   }
     * })
    **/
    count<T extends AnalysisCountArgs>(
      args?: Subset<T, AnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisAggregateArgs>(args: Subset<T, AnalysisAggregateArgs>): Prisma.PrismaPromise<GetAnalysisAggregateType<T>>

    /**
     * Group by Analysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analysis model
   */
  readonly fields: AnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends TranscriptRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRunDefaultArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analysis model
   */
  interface AnalysisFieldRefs {
    readonly id: FieldRef<"Analysis", 'String'>
    readonly runId: FieldRef<"Analysis", 'String'>
    readonly segmentIndex: FieldRef<"Analysis", 'Int'>
    readonly kind: FieldRef<"Analysis", 'String'>
    readonly engine: FieldRef<"Analysis", 'String'>
    readonly params: FieldRef<"Analysis", 'Json'>
    readonly paramsHash: FieldRef<"Analysis", 'String'>
    readonly status: FieldRef<"Analysis", 'String'>
    readonly summary: FieldRef<"Analysis", 'String'>
    readonly score: FieldRef<"Analysis", 'Float'>
    readonly result: FieldRef<"Analysis", 'Json'>
    readonly error: FieldRef<"Analysis", 'String'>
    readonly createdAt: FieldRef<"Analysis", 'DateTime'>
    readonly updatedAt: FieldRef<"Analysis", 'DateTime'>
    readonly completedAt: FieldRef<"Analysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analysis findUnique
   */
  export type AnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * Filter, which Analysis to fetch.
     */
    where: AnalysisWhereUniqueInput
  }

  /**
   * Analysis findUniqueOrThrow
   */
  export type AnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * Filter, which Analysis to fetch.
     */
    where: AnalysisWhereUniqueInput
  }

  /**
   * Analysis findFirst
   */
  export type AnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * Filter, which Analysis to fetch.
     */
    where?: AnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analyses to fetch.
     */
    orderBy?: AnalysisOrderByWithRelationInput | AnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analyses.
     */
    cursor?: AnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analyses.
     */
    distinct?: AnalysisScalarFieldEnum | AnalysisScalarFieldEnum[]
  }

  /**
   * Analysis findFirstOrThrow
   */
  export type AnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * Filter, which Analysis to fetch.
     */
    where?: AnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analyses to fetch.
     */
    orderBy?: AnalysisOrderByWithRelationInput | AnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analyses.
     */
    cursor?: AnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analyses.
     */
    distinct?: AnalysisScalarFieldEnum | AnalysisScalarFieldEnum[]
  }

  /**
   * Analysis findMany
   */
  export type AnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * Filter, which Analyses to fetch.
     */
    where?: AnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analyses to fetch.
     */
    orderBy?: AnalysisOrderByWithRelationInput | AnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analyses.
     */
    cursor?: AnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analyses.
     */
    skip?: number
    distinct?: AnalysisScalarFieldEnum | AnalysisScalarFieldEnum[]
  }

  /**
   * Analysis create
   */
  export type AnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a Analysis.
     */
    data: XOR<AnalysisCreateInput, AnalysisUncheckedCreateInput>
  }

  /**
   * Analysis createMany
   */
  export type AnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analyses.
     */
    data: AnalysisCreateManyInput | AnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analysis createManyAndReturn
   */
  export type AnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many Analyses.
     */
    data: AnalysisCreateManyInput | AnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analysis update
   */
  export type AnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a Analysis.
     */
    data: XOR<AnalysisUpdateInput, AnalysisUncheckedUpdateInput>
    /**
     * Choose, which Analysis to update.
     */
    where: AnalysisWhereUniqueInput
  }

  /**
   * Analysis updateMany
   */
  export type AnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analyses.
     */
    data: XOR<AnalysisUpdateManyMutationInput, AnalysisUncheckedUpdateManyInput>
    /**
     * Filter which Analyses to update
     */
    where?: AnalysisWhereInput
    /**
     * Limit how many Analyses to update.
     */
    limit?: number
  }

  /**
   * Analysis updateManyAndReturn
   */
  export type AnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * The data used to update Analyses.
     */
    data: XOR<AnalysisUpdateManyMutationInput, AnalysisUncheckedUpdateManyInput>
    /**
     * Filter which Analyses to update
     */
    where?: AnalysisWhereInput
    /**
     * Limit how many Analyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analysis upsert
   */
  export type AnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the Analysis to update in case it exists.
     */
    where: AnalysisWhereUniqueInput
    /**
     * In case the Analysis found by the `where` argument doesn't exist, create a new Analysis with this data.
     */
    create: XOR<AnalysisCreateInput, AnalysisUncheckedCreateInput>
    /**
     * In case the Analysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisUpdateInput, AnalysisUncheckedUpdateInput>
  }

  /**
   * Analysis delete
   */
  export type AnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
    /**
     * Filter which Analysis to delete.
     */
    where: AnalysisWhereUniqueInput
  }

  /**
   * Analysis deleteMany
   */
  export type AnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analyses to delete
     */
    where?: AnalysisWhereInput
    /**
     * Limit how many Analyses to delete.
     */
    limit?: number
  }

  /**
   * Analysis without action
   */
  export type AnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analysis
     */
    select?: AnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analysis
     */
    omit?: AnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Annotation
   */

  export type AggregateAnnotation = {
    _count: AnnotationCountAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  export type AnnotationMinAggregateOutputType = {
    id: string | null
    runId: string | null
    userId: string | null
    content: string | null
    anchorType: string | null
    anchorValue: string | null
    createdAt: Date | null
    isDeleted: boolean | null
  }

  export type AnnotationMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    userId: string | null
    content: string | null
    anchorType: string | null
    anchorValue: string | null
    createdAt: Date | null
    isDeleted: boolean | null
  }

  export type AnnotationCountAggregateOutputType = {
    id: number
    runId: number
    userId: number
    content: number
    anchorType: number
    anchorValue: number
    createdAt: number
    isDeleted: number
    _all: number
  }


  export type AnnotationMinAggregateInputType = {
    id?: true
    runId?: true
    userId?: true
    content?: true
    anchorType?: true
    anchorValue?: true
    createdAt?: true
    isDeleted?: true
  }

  export type AnnotationMaxAggregateInputType = {
    id?: true
    runId?: true
    userId?: true
    content?: true
    anchorType?: true
    anchorValue?: true
    createdAt?: true
    isDeleted?: true
  }

  export type AnnotationCountAggregateInputType = {
    id?: true
    runId?: true
    userId?: true
    content?: true
    anchorType?: true
    anchorValue?: true
    createdAt?: true
    isDeleted?: true
    _all?: true
  }

  export type AnnotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annotation to aggregate.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Annotations
    **/
    _count?: true | AnnotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnotationMaxAggregateInputType
  }

  export type GetAnnotationAggregateType<T extends AnnotationAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnotation[P]>
      : GetScalarType<T[P], AggregateAnnotation[P]>
  }




  export type AnnotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnotationWhereInput
    orderBy?: AnnotationOrderByWithAggregationInput | AnnotationOrderByWithAggregationInput[]
    by: AnnotationScalarFieldEnum[] | AnnotationScalarFieldEnum
    having?: AnnotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnotationCountAggregateInputType | true
    _min?: AnnotationMinAggregateInputType
    _max?: AnnotationMaxAggregateInputType
  }

  export type AnnotationGroupByOutputType = {
    id: string
    runId: string
    userId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt: Date
    isDeleted: boolean
    _count: AnnotationCountAggregateOutputType | null
    _min: AnnotationMinAggregateOutputType | null
    _max: AnnotationMaxAggregateOutputType | null
  }

  type GetAnnotationGroupByPayload<T extends AnnotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
            : GetScalarType<T[P], AnnotationGroupByOutputType[P]>
        }
      >
    >


  export type AnnotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    userId?: boolean
    content?: boolean
    anchorType?: boolean
    anchorValue?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    userId?: boolean
    content?: boolean
    anchorType?: boolean
    anchorValue?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    userId?: boolean
    content?: boolean
    anchorType?: boolean
    anchorValue?: boolean
    createdAt?: boolean
    isDeleted?: boolean
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annotation"]>

  export type AnnotationSelectScalar = {
    id?: boolean
    runId?: boolean
    userId?: boolean
    content?: boolean
    anchorType?: boolean
    anchorValue?: boolean
    createdAt?: boolean
    isDeleted?: boolean
  }

  export type AnnotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "userId" | "content" | "anchorType" | "anchorValue" | "createdAt" | "isDeleted", ExtArgs["result"]["annotation"]>
  export type AnnotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Annotation"
    objects: {
      run: Prisma.$TranscriptRunPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      userId: string
      content: string
      anchorType: string
      anchorValue: string
      createdAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["annotation"]>
    composites: {}
  }

  type AnnotationGetPayload<S extends boolean | null | undefined | AnnotationDefaultArgs> = $Result.GetResult<Prisma.$AnnotationPayload, S>

  type AnnotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnotationCountAggregateInputType | true
    }

  export interface AnnotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Annotation'], meta: { name: 'Annotation' } }
    /**
     * Find zero or one Annotation that matches the filter.
     * @param {AnnotationFindUniqueArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnotationFindUniqueArgs>(args: SelectSubset<T, AnnotationFindUniqueArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Annotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnotationFindUniqueOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnotationFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Annotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnotationFindFirstArgs>(args?: SelectSubset<T, AnnotationFindFirstArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Annotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindFirstOrThrowArgs} args - Arguments to find a Annotation
     * @example
     * // Get one Annotation
     * const annotation = await prisma.annotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnotationFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Annotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annotations
     * const annotations = await prisma.annotation.findMany()
     * 
     * // Get first 10 Annotations
     * const annotations = await prisma.annotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annotationWithIdOnly = await prisma.annotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnotationFindManyArgs>(args?: SelectSubset<T, AnnotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Annotation.
     * @param {AnnotationCreateArgs} args - Arguments to create a Annotation.
     * @example
     * // Create one Annotation
     * const Annotation = await prisma.annotation.create({
     *   data: {
     *     // ... data to create a Annotation
     *   }
     * })
     * 
     */
    create<T extends AnnotationCreateArgs>(args: SelectSubset<T, AnnotationCreateArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Annotations.
     * @param {AnnotationCreateManyArgs} args - Arguments to create many Annotations.
     * @example
     * // Create many Annotations
     * const annotation = await prisma.annotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnotationCreateManyArgs>(args?: SelectSubset<T, AnnotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Annotations and returns the data saved in the database.
     * @param {AnnotationCreateManyAndReturnArgs} args - Arguments to create many Annotations.
     * @example
     * // Create many Annotations
     * const annotation = await prisma.annotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Annotations and only return the `id`
     * const annotationWithIdOnly = await prisma.annotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnotationCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Annotation.
     * @param {AnnotationDeleteArgs} args - Arguments to delete one Annotation.
     * @example
     * // Delete one Annotation
     * const Annotation = await prisma.annotation.delete({
     *   where: {
     *     // ... filter to delete one Annotation
     *   }
     * })
     * 
     */
    delete<T extends AnnotationDeleteArgs>(args: SelectSubset<T, AnnotationDeleteArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Annotation.
     * @param {AnnotationUpdateArgs} args - Arguments to update one Annotation.
     * @example
     * // Update one Annotation
     * const annotation = await prisma.annotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnotationUpdateArgs>(args: SelectSubset<T, AnnotationUpdateArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Annotations.
     * @param {AnnotationDeleteManyArgs} args - Arguments to filter Annotations to delete.
     * @example
     * // Delete a few Annotations
     * const { count } = await prisma.annotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnotationDeleteManyArgs>(args?: SelectSubset<T, AnnotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annotations
     * const annotation = await prisma.annotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnotationUpdateManyArgs>(args: SelectSubset<T, AnnotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annotations and returns the data updated in the database.
     * @param {AnnotationUpdateManyAndReturnArgs} args - Arguments to update many Annotations.
     * @example
     * // Update many Annotations
     * const annotation = await prisma.annotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Annotations and only return the `id`
     * const annotationWithIdOnly = await prisma.annotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnotationUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Annotation.
     * @param {AnnotationUpsertArgs} args - Arguments to update or create a Annotation.
     * @example
     * // Update or create a Annotation
     * const annotation = await prisma.annotation.upsert({
     *   create: {
     *     // ... data to create a Annotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annotation we want to update
     *   }
     * })
     */
    upsert<T extends AnnotationUpsertArgs>(args: SelectSubset<T, AnnotationUpsertArgs<ExtArgs>>): Prisma__AnnotationClient<$Result.GetResult<Prisma.$AnnotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Annotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationCountArgs} args - Arguments to filter Annotations to count.
     * @example
     * // Count the number of Annotations
     * const count = await prisma.annotation.count({
     *   where: {
     *     // ... the filter for the Annotations we want to count
     *   }
     * })
    **/
    count<T extends AnnotationCountArgs>(
      args?: Subset<T, AnnotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnotationAggregateArgs>(args: Subset<T, AnnotationAggregateArgs>): Prisma.PrismaPromise<GetAnnotationAggregateType<T>>

    /**
     * Group by Annotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnotationGroupByArgs['orderBy'] }
        : { orderBy?: AnnotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Annotation model
   */
  readonly fields: AnnotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Annotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends TranscriptRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRunDefaultArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Annotation model
   */
  interface AnnotationFieldRefs {
    readonly id: FieldRef<"Annotation", 'String'>
    readonly runId: FieldRef<"Annotation", 'String'>
    readonly userId: FieldRef<"Annotation", 'String'>
    readonly content: FieldRef<"Annotation", 'String'>
    readonly anchorType: FieldRef<"Annotation", 'String'>
    readonly anchorValue: FieldRef<"Annotation", 'String'>
    readonly createdAt: FieldRef<"Annotation", 'DateTime'>
    readonly isDeleted: FieldRef<"Annotation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Annotation findUnique
   */
  export type AnnotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findUniqueOrThrow
   */
  export type AnnotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation findFirst
   */
  export type AnnotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation findFirstOrThrow
   */
  export type AnnotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotation to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annotations.
     */
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation findMany
   */
  export type AnnotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter, which Annotations to fetch.
     */
    where?: AnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annotations to fetch.
     */
    orderBy?: AnnotationOrderByWithRelationInput | AnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Annotations.
     */
    cursor?: AnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annotations.
     */
    skip?: number
    distinct?: AnnotationScalarFieldEnum | AnnotationScalarFieldEnum[]
  }

  /**
   * Annotation create
   */
  export type AnnotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Annotation.
     */
    data: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
  }

  /**
   * Annotation createMany
   */
  export type AnnotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Annotations.
     */
    data: AnnotationCreateManyInput | AnnotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Annotation createManyAndReturn
   */
  export type AnnotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * The data used to create many Annotations.
     */
    data: AnnotationCreateManyInput | AnnotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Annotation update
   */
  export type AnnotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Annotation.
     */
    data: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
    /**
     * Choose, which Annotation to update.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation updateMany
   */
  export type AnnotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Annotations.
     */
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyInput>
    /**
     * Filter which Annotations to update
     */
    where?: AnnotationWhereInput
    /**
     * Limit how many Annotations to update.
     */
    limit?: number
  }

  /**
   * Annotation updateManyAndReturn
   */
  export type AnnotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * The data used to update Annotations.
     */
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyInput>
    /**
     * Filter which Annotations to update
     */
    where?: AnnotationWhereInput
    /**
     * Limit how many Annotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Annotation upsert
   */
  export type AnnotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Annotation to update in case it exists.
     */
    where: AnnotationWhereUniqueInput
    /**
     * In case the Annotation found by the `where` argument doesn't exist, create a new Annotation with this data.
     */
    create: XOR<AnnotationCreateInput, AnnotationUncheckedCreateInput>
    /**
     * In case the Annotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnotationUpdateInput, AnnotationUncheckedUpdateInput>
  }

  /**
   * Annotation delete
   */
  export type AnnotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
    /**
     * Filter which Annotation to delete.
     */
    where: AnnotationWhereUniqueInput
  }

  /**
   * Annotation deleteMany
   */
  export type AnnotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annotations to delete
     */
    where?: AnnotationWhereInput
    /**
     * Limit how many Annotations to delete.
     */
    limit?: number
  }

  /**
   * Annotation without action
   */
  export type AnnotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annotation
     */
    select?: AnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Annotation
     */
    omit?: AnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnotationInclude<ExtArgs> | null
  }


  /**
   * Model AudioTag
   */

  export type AggregateAudioTag = {
    _count: AudioTagCountAggregateOutputType | null
    _min: AudioTagMinAggregateOutputType | null
    _max: AudioTagMaxAggregateOutputType | null
  }

  export type AudioTagMinAggregateOutputType = {
    id: string | null
    audioId: string | null
    key: string | null
    createdAt: Date | null
  }

  export type AudioTagMaxAggregateOutputType = {
    id: string | null
    audioId: string | null
    key: string | null
    createdAt: Date | null
  }

  export type AudioTagCountAggregateOutputType = {
    id: number
    audioId: number
    key: number
    createdAt: number
    _all: number
  }


  export type AudioTagMinAggregateInputType = {
    id?: true
    audioId?: true
    key?: true
    createdAt?: true
  }

  export type AudioTagMaxAggregateInputType = {
    id?: true
    audioId?: true
    key?: true
    createdAt?: true
  }

  export type AudioTagCountAggregateInputType = {
    id?: true
    audioId?: true
    key?: true
    createdAt?: true
    _all?: true
  }

  export type AudioTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTag to aggregate.
     */
    where?: AudioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTags to fetch.
     */
    orderBy?: AudioTagOrderByWithRelationInput | AudioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioTags
    **/
    _count?: true | AudioTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioTagMaxAggregateInputType
  }

  export type GetAudioTagAggregateType<T extends AudioTagAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioTag[P]>
      : GetScalarType<T[P], AggregateAudioTag[P]>
  }




  export type AudioTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioTagWhereInput
    orderBy?: AudioTagOrderByWithAggregationInput | AudioTagOrderByWithAggregationInput[]
    by: AudioTagScalarFieldEnum[] | AudioTagScalarFieldEnum
    having?: AudioTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioTagCountAggregateInputType | true
    _min?: AudioTagMinAggregateInputType
    _max?: AudioTagMaxAggregateInputType
  }

  export type AudioTagGroupByOutputType = {
    id: string
    audioId: string
    key: string
    createdAt: Date
    _count: AudioTagCountAggregateOutputType | null
    _min: AudioTagMinAggregateOutputType | null
    _max: AudioTagMaxAggregateOutputType | null
  }

  type GetAudioTagGroupByPayload<T extends AudioTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioTagGroupByOutputType[P]>
            : GetScalarType<T[P], AudioTagGroupByOutputType[P]>
        }
      >
    >


  export type AudioTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    key?: boolean
    createdAt?: boolean
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTag"]>

  export type AudioTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    key?: boolean
    createdAt?: boolean
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTag"]>

  export type AudioTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    key?: boolean
    createdAt?: boolean
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTag"]>

  export type AudioTagSelectScalar = {
    id?: boolean
    audioId?: boolean
    key?: boolean
    createdAt?: boolean
  }

  export type AudioTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "audioId" | "key" | "createdAt", ExtArgs["result"]["audioTag"]>
  export type AudioTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
  }
  export type AudioTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
  }
  export type AudioTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | AudioFileDefaultArgs<ExtArgs>
  }

  export type $AudioTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioTag"
    objects: {
      audio: Prisma.$AudioFilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      audioId: string
      key: string
      createdAt: Date
    }, ExtArgs["result"]["audioTag"]>
    composites: {}
  }

  type AudioTagGetPayload<S extends boolean | null | undefined | AudioTagDefaultArgs> = $Result.GetResult<Prisma.$AudioTagPayload, S>

  type AudioTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioTagCountAggregateInputType | true
    }

  export interface AudioTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioTag'], meta: { name: 'AudioTag' } }
    /**
     * Find zero or one AudioTag that matches the filter.
     * @param {AudioTagFindUniqueArgs} args - Arguments to find a AudioTag
     * @example
     * // Get one AudioTag
     * const audioTag = await prisma.audioTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioTagFindUniqueArgs>(args: SelectSubset<T, AudioTagFindUniqueArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioTagFindUniqueOrThrowArgs} args - Arguments to find a AudioTag
     * @example
     * // Get one AudioTag
     * const audioTag = await prisma.audioTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioTagFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagFindFirstArgs} args - Arguments to find a AudioTag
     * @example
     * // Get one AudioTag
     * const audioTag = await prisma.audioTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioTagFindFirstArgs>(args?: SelectSubset<T, AudioTagFindFirstArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagFindFirstOrThrowArgs} args - Arguments to find a AudioTag
     * @example
     * // Get one AudioTag
     * const audioTag = await prisma.audioTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioTagFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioTags
     * const audioTags = await prisma.audioTag.findMany()
     * 
     * // Get first 10 AudioTags
     * const audioTags = await prisma.audioTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioTagWithIdOnly = await prisma.audioTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioTagFindManyArgs>(args?: SelectSubset<T, AudioTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioTag.
     * @param {AudioTagCreateArgs} args - Arguments to create a AudioTag.
     * @example
     * // Create one AudioTag
     * const AudioTag = await prisma.audioTag.create({
     *   data: {
     *     // ... data to create a AudioTag
     *   }
     * })
     * 
     */
    create<T extends AudioTagCreateArgs>(args: SelectSubset<T, AudioTagCreateArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioTags.
     * @param {AudioTagCreateManyArgs} args - Arguments to create many AudioTags.
     * @example
     * // Create many AudioTags
     * const audioTag = await prisma.audioTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioTagCreateManyArgs>(args?: SelectSubset<T, AudioTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioTags and returns the data saved in the database.
     * @param {AudioTagCreateManyAndReturnArgs} args - Arguments to create many AudioTags.
     * @example
     * // Create many AudioTags
     * const audioTag = await prisma.audioTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioTags and only return the `id`
     * const audioTagWithIdOnly = await prisma.audioTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioTagCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioTag.
     * @param {AudioTagDeleteArgs} args - Arguments to delete one AudioTag.
     * @example
     * // Delete one AudioTag
     * const AudioTag = await prisma.audioTag.delete({
     *   where: {
     *     // ... filter to delete one AudioTag
     *   }
     * })
     * 
     */
    delete<T extends AudioTagDeleteArgs>(args: SelectSubset<T, AudioTagDeleteArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioTag.
     * @param {AudioTagUpdateArgs} args - Arguments to update one AudioTag.
     * @example
     * // Update one AudioTag
     * const audioTag = await prisma.audioTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioTagUpdateArgs>(args: SelectSubset<T, AudioTagUpdateArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioTags.
     * @param {AudioTagDeleteManyArgs} args - Arguments to filter AudioTags to delete.
     * @example
     * // Delete a few AudioTags
     * const { count } = await prisma.audioTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioTagDeleteManyArgs>(args?: SelectSubset<T, AudioTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioTags
     * const audioTag = await prisma.audioTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioTagUpdateManyArgs>(args: SelectSubset<T, AudioTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTags and returns the data updated in the database.
     * @param {AudioTagUpdateManyAndReturnArgs} args - Arguments to update many AudioTags.
     * @example
     * // Update many AudioTags
     * const audioTag = await prisma.audioTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioTags and only return the `id`
     * const audioTagWithIdOnly = await prisma.audioTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioTagUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioTag.
     * @param {AudioTagUpsertArgs} args - Arguments to update or create a AudioTag.
     * @example
     * // Update or create a AudioTag
     * const audioTag = await prisma.audioTag.upsert({
     *   create: {
     *     // ... data to create a AudioTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioTag we want to update
     *   }
     * })
     */
    upsert<T extends AudioTagUpsertArgs>(args: SelectSubset<T, AudioTagUpsertArgs<ExtArgs>>): Prisma__AudioTagClient<$Result.GetResult<Prisma.$AudioTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagCountArgs} args - Arguments to filter AudioTags to count.
     * @example
     * // Count the number of AudioTags
     * const count = await prisma.audioTag.count({
     *   where: {
     *     // ... the filter for the AudioTags we want to count
     *   }
     * })
    **/
    count<T extends AudioTagCountArgs>(
      args?: Subset<T, AudioTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioTagAggregateArgs>(args: Subset<T, AudioTagAggregateArgs>): Prisma.PrismaPromise<GetAudioTagAggregateType<T>>

    /**
     * Group by AudioTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioTagGroupByArgs['orderBy'] }
        : { orderBy?: AudioTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioTag model
   */
  readonly fields: AudioTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audio<T extends AudioFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioFileDefaultArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioTag model
   */
  interface AudioTagFieldRefs {
    readonly id: FieldRef<"AudioTag", 'String'>
    readonly audioId: FieldRef<"AudioTag", 'String'>
    readonly key: FieldRef<"AudioTag", 'String'>
    readonly createdAt: FieldRef<"AudioTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioTag findUnique
   */
  export type AudioTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * Filter, which AudioTag to fetch.
     */
    where: AudioTagWhereUniqueInput
  }

  /**
   * AudioTag findUniqueOrThrow
   */
  export type AudioTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * Filter, which AudioTag to fetch.
     */
    where: AudioTagWhereUniqueInput
  }

  /**
   * AudioTag findFirst
   */
  export type AudioTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * Filter, which AudioTag to fetch.
     */
    where?: AudioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTags to fetch.
     */
    orderBy?: AudioTagOrderByWithRelationInput | AudioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTags.
     */
    cursor?: AudioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTags.
     */
    distinct?: AudioTagScalarFieldEnum | AudioTagScalarFieldEnum[]
  }

  /**
   * AudioTag findFirstOrThrow
   */
  export type AudioTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * Filter, which AudioTag to fetch.
     */
    where?: AudioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTags to fetch.
     */
    orderBy?: AudioTagOrderByWithRelationInput | AudioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTags.
     */
    cursor?: AudioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTags.
     */
    distinct?: AudioTagScalarFieldEnum | AudioTagScalarFieldEnum[]
  }

  /**
   * AudioTag findMany
   */
  export type AudioTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * Filter, which AudioTags to fetch.
     */
    where?: AudioTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTags to fetch.
     */
    orderBy?: AudioTagOrderByWithRelationInput | AudioTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioTags.
     */
    cursor?: AudioTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTags.
     */
    skip?: number
    distinct?: AudioTagScalarFieldEnum | AudioTagScalarFieldEnum[]
  }

  /**
   * AudioTag create
   */
  export type AudioTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioTag.
     */
    data: XOR<AudioTagCreateInput, AudioTagUncheckedCreateInput>
  }

  /**
   * AudioTag createMany
   */
  export type AudioTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioTags.
     */
    data: AudioTagCreateManyInput | AudioTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioTag createManyAndReturn
   */
  export type AudioTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * The data used to create many AudioTags.
     */
    data: AudioTagCreateManyInput | AudioTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTag update
   */
  export type AudioTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioTag.
     */
    data: XOR<AudioTagUpdateInput, AudioTagUncheckedUpdateInput>
    /**
     * Choose, which AudioTag to update.
     */
    where: AudioTagWhereUniqueInput
  }

  /**
   * AudioTag updateMany
   */
  export type AudioTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioTags.
     */
    data: XOR<AudioTagUpdateManyMutationInput, AudioTagUncheckedUpdateManyInput>
    /**
     * Filter which AudioTags to update
     */
    where?: AudioTagWhereInput
    /**
     * Limit how many AudioTags to update.
     */
    limit?: number
  }

  /**
   * AudioTag updateManyAndReturn
   */
  export type AudioTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * The data used to update AudioTags.
     */
    data: XOR<AudioTagUpdateManyMutationInput, AudioTagUncheckedUpdateManyInput>
    /**
     * Filter which AudioTags to update
     */
    where?: AudioTagWhereInput
    /**
     * Limit how many AudioTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTag upsert
   */
  export type AudioTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioTag to update in case it exists.
     */
    where: AudioTagWhereUniqueInput
    /**
     * In case the AudioTag found by the `where` argument doesn't exist, create a new AudioTag with this data.
     */
    create: XOR<AudioTagCreateInput, AudioTagUncheckedCreateInput>
    /**
     * In case the AudioTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioTagUpdateInput, AudioTagUncheckedUpdateInput>
  }

  /**
   * AudioTag delete
   */
  export type AudioTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
    /**
     * Filter which AudioTag to delete.
     */
    where: AudioTagWhereUniqueInput
  }

  /**
   * AudioTag deleteMany
   */
  export type AudioTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTags to delete
     */
    where?: AudioTagWhereInput
    /**
     * Limit how many AudioTags to delete.
     */
    limit?: number
  }

  /**
   * AudioTag without action
   */
  export type AudioTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTag
     */
    select?: AudioTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTag
     */
    omit?: AudioTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTagInclude<ExtArgs> | null
  }


  /**
   * Model UsageLog
   */

  export type AggregateUsageLog = {
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  export type UsageLogAvgAggregateOutputType = {
    uploadCount: number | null
    durationMs: number | null
  }

  export type UsageLogSumAggregateOutputType = {
    uploadCount: number | null
    durationMs: number | null
  }

  export type UsageLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    day: Date | null
    uploadCount: number | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type UsageLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    day: Date | null
    uploadCount: number | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type UsageLogCountAggregateOutputType = {
    id: number
    userId: number
    day: number
    uploadCount: number
    durationMs: number
    createdAt: number
    _all: number
  }


  export type UsageLogAvgAggregateInputType = {
    uploadCount?: true
    durationMs?: true
  }

  export type UsageLogSumAggregateInputType = {
    uploadCount?: true
    durationMs?: true
  }

  export type UsageLogMinAggregateInputType = {
    id?: true
    userId?: true
    day?: true
    uploadCount?: true
    durationMs?: true
    createdAt?: true
  }

  export type UsageLogMaxAggregateInputType = {
    id?: true
    userId?: true
    day?: true
    uploadCount?: true
    durationMs?: true
    createdAt?: true
  }

  export type UsageLogCountAggregateInputType = {
    id?: true
    userId?: true
    day?: true
    uploadCount?: true
    durationMs?: true
    createdAt?: true
    _all?: true
  }

  export type UsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLog to aggregate.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageLogs
    **/
    _count?: true | UsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageLogMaxAggregateInputType
  }

  export type GetUsageLogAggregateType<T extends UsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageLog[P]>
      : GetScalarType<T[P], AggregateUsageLog[P]>
  }




  export type UsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithAggregationInput | UsageLogOrderByWithAggregationInput[]
    by: UsageLogScalarFieldEnum[] | UsageLogScalarFieldEnum
    having?: UsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageLogCountAggregateInputType | true
    _avg?: UsageLogAvgAggregateInputType
    _sum?: UsageLogSumAggregateInputType
    _min?: UsageLogMinAggregateInputType
    _max?: UsageLogMaxAggregateInputType
  }

  export type UsageLogGroupByOutputType = {
    id: string
    userId: string
    day: Date
    uploadCount: number
    durationMs: number
    createdAt: Date
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  type GetUsageLogGroupByPayload<T extends UsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
        }
      >
    >


  export type UsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    day?: boolean
    uploadCount?: boolean
    durationMs?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    day?: boolean
    uploadCount?: boolean
    durationMs?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    day?: boolean
    uploadCount?: boolean
    durationMs?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectScalar = {
    id?: boolean
    userId?: boolean
    day?: boolean
    uploadCount?: boolean
    durationMs?: boolean
    createdAt?: boolean
  }

  export type UsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "day" | "uploadCount" | "durationMs" | "createdAt", ExtArgs["result"]["usageLog"]>
  export type UsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      day: Date
      uploadCount: number
      durationMs: number
      createdAt: Date
    }, ExtArgs["result"]["usageLog"]>
    composites: {}
  }

  type UsageLogGetPayload<S extends boolean | null | undefined | UsageLogDefaultArgs> = $Result.GetResult<Prisma.$UsageLogPayload, S>

  type UsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageLogCountAggregateInputType | true
    }

  export interface UsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageLog'], meta: { name: 'UsageLog' } }
    /**
     * Find zero or one UsageLog that matches the filter.
     * @param {UsageLogFindUniqueArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageLogFindUniqueArgs>(args: SelectSubset<T, UsageLogFindUniqueArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageLogFindUniqueOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageLogFindFirstArgs>(args?: SelectSubset<T, UsageLogFindFirstArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageLogs
     * const usageLogs = await prisma.usageLog.findMany()
     * 
     * // Get first 10 UsageLogs
     * const usageLogs = await prisma.usageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageLogFindManyArgs>(args?: SelectSubset<T, UsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageLog.
     * @param {UsageLogCreateArgs} args - Arguments to create a UsageLog.
     * @example
     * // Create one UsageLog
     * const UsageLog = await prisma.usageLog.create({
     *   data: {
     *     // ... data to create a UsageLog
     *   }
     * })
     * 
     */
    create<T extends UsageLogCreateArgs>(args: SelectSubset<T, UsageLogCreateArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageLogs.
     * @param {UsageLogCreateManyArgs} args - Arguments to create many UsageLogs.
     * @example
     * // Create many UsageLogs
     * const usageLog = await prisma.usageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageLogCreateManyArgs>(args?: SelectSubset<T, UsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageLogs and returns the data saved in the database.
     * @param {UsageLogCreateManyAndReturnArgs} args - Arguments to create many UsageLogs.
     * @example
     * // Create many UsageLogs
     * const usageLog = await prisma.usageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageLogs and only return the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageLog.
     * @param {UsageLogDeleteArgs} args - Arguments to delete one UsageLog.
     * @example
     * // Delete one UsageLog
     * const UsageLog = await prisma.usageLog.delete({
     *   where: {
     *     // ... filter to delete one UsageLog
     *   }
     * })
     * 
     */
    delete<T extends UsageLogDeleteArgs>(args: SelectSubset<T, UsageLogDeleteArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageLog.
     * @param {UsageLogUpdateArgs} args - Arguments to update one UsageLog.
     * @example
     * // Update one UsageLog
     * const usageLog = await prisma.usageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageLogUpdateArgs>(args: SelectSubset<T, UsageLogUpdateArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageLogs.
     * @param {UsageLogDeleteManyArgs} args - Arguments to filter UsageLogs to delete.
     * @example
     * // Delete a few UsageLogs
     * const { count } = await prisma.usageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageLogDeleteManyArgs>(args?: SelectSubset<T, UsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageLogs
     * const usageLog = await prisma.usageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageLogUpdateManyArgs>(args: SelectSubset<T, UsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLogs and returns the data updated in the database.
     * @param {UsageLogUpdateManyAndReturnArgs} args - Arguments to update many UsageLogs.
     * @example
     * // Update many UsageLogs
     * const usageLog = await prisma.usageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageLogs and only return the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageLog.
     * @param {UsageLogUpsertArgs} args - Arguments to update or create a UsageLog.
     * @example
     * // Update or create a UsageLog
     * const usageLog = await prisma.usageLog.upsert({
     *   create: {
     *     // ... data to create a UsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageLog we want to update
     *   }
     * })
     */
    upsert<T extends UsageLogUpsertArgs>(args: SelectSubset<T, UsageLogUpsertArgs<ExtArgs>>): Prisma__UsageLogClient<$Result.GetResult<Prisma.$UsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogCountArgs} args - Arguments to filter UsageLogs to count.
     * @example
     * // Count the number of UsageLogs
     * const count = await prisma.usageLog.count({
     *   where: {
     *     // ... the filter for the UsageLogs we want to count
     *   }
     * })
    **/
    count<T extends UsageLogCountArgs>(
      args?: Subset<T, UsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageLogAggregateArgs>(args: Subset<T, UsageLogAggregateArgs>): Prisma.PrismaPromise<GetUsageLogAggregateType<T>>

    /**
     * Group by UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageLogGroupByArgs['orderBy'] }
        : { orderBy?: UsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageLog model
   */
  readonly fields: UsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageLog model
   */
  interface UsageLogFieldRefs {
    readonly id: FieldRef<"UsageLog", 'String'>
    readonly userId: FieldRef<"UsageLog", 'String'>
    readonly day: FieldRef<"UsageLog", 'DateTime'>
    readonly uploadCount: FieldRef<"UsageLog", 'Int'>
    readonly durationMs: FieldRef<"UsageLog", 'Int'>
    readonly createdAt: FieldRef<"UsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageLog findUnique
   */
  export type UsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog findUniqueOrThrow
   */
  export type UsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog findFirst
   */
  export type UsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog findFirstOrThrow
   */
  export type UsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog findMany
   */
  export type UsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLogs to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }

  /**
   * UsageLog create
   */
  export type UsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageLog.
     */
    data: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
  }

  /**
   * UsageLog createMany
   */
  export type UsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageLog createManyAndReturn
   */
  export type UsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageLog update
   */
  export type UsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageLog.
     */
    data: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
    /**
     * Choose, which UsageLog to update.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog updateMany
   */
  export type UsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageLogs.
     */
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyInput>
    /**
     * Filter which UsageLogs to update
     */
    where?: UsageLogWhereInput
    /**
     * Limit how many UsageLogs to update.
     */
    limit?: number
  }

  /**
   * UsageLog updateManyAndReturn
   */
  export type UsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * The data used to update UsageLogs.
     */
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyInput>
    /**
     * Filter which UsageLogs to update
     */
    where?: UsageLogWhereInput
    /**
     * Limit how many UsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageLog upsert
   */
  export type UsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageLog to update in case it exists.
     */
    where: UsageLogWhereUniqueInput
    /**
     * In case the UsageLog found by the `where` argument doesn't exist, create a new UsageLog with this data.
     */
    create: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
    /**
     * In case the UsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
  }

  /**
   * UsageLog delete
   */
  export type UsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter which UsageLog to delete.
     */
    where: UsageLogWhereUniqueInput
  }

  /**
   * UsageLog deleteMany
   */
  export type UsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLogs to delete
     */
    where?: UsageLogWhereInput
    /**
     * Limit how many UsageLogs to delete.
     */
    limit?: number
  }

  /**
   * UsageLog without action
   */
  export type UsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageLog
     */
    omit?: UsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageLogInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type JobSumAggregateOutputType = {
    retryCount: number | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    audioId: string | null
    runId: string | null
    jobType: string | null
    providerJobId: string | null
    status: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    audioId: string | null
    runId: string | null
    jobType: string | null
    providerJobId: string | null
    status: string | null
    retryCount: number | null
    nextRetryAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    audioId: number
    runId: number
    jobType: number
    providerJobId: number
    status: number
    retryCount: number
    nextRetryAt: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    retryCount?: true
  }

  export type JobSumAggregateInputType = {
    retryCount?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    audioId?: true
    runId?: true
    jobType?: true
    providerJobId?: true
    status?: true
    retryCount?: true
    nextRetryAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    audioId?: true
    runId?: true
    jobType?: true
    providerJobId?: true
    status?: true
    retryCount?: true
    nextRetryAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    audioId?: true
    runId?: true
    jobType?: true
    providerJobId?: true
    status?: true
    retryCount?: true
    nextRetryAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    audioId: string | null
    runId: string
    jobType: string
    providerJobId: string | null
    status: string
    retryCount: number
    nextRetryAt: Date | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    runId?: boolean
    jobType?: boolean
    providerJobId?: boolean
    status?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audio?: boolean | Job$audioArgs<ExtArgs>
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    runId?: boolean
    jobType?: boolean
    providerJobId?: boolean
    status?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audio?: boolean | Job$audioArgs<ExtArgs>
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    audioId?: boolean
    runId?: boolean
    jobType?: boolean
    providerJobId?: boolean
    status?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audio?: boolean | Job$audioArgs<ExtArgs>
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    audioId?: boolean
    runId?: boolean
    jobType?: boolean
    providerJobId?: boolean
    status?: boolean
    retryCount?: boolean
    nextRetryAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "audioId" | "runId" | "jobType" | "providerJobId" | "status" | "retryCount" | "nextRetryAt" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | Job$audioArgs<ExtArgs>
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | Job$audioArgs<ExtArgs>
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audio?: boolean | Job$audioArgs<ExtArgs>
    run?: boolean | TranscriptRunDefaultArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      audio: Prisma.$AudioFilePayload<ExtArgs> | null
      run: Prisma.$TranscriptRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      audioId: string | null
      runId: string
      jobType: string
      providerJobId: string | null
      status: string
      retryCount: number
      nextRetryAt: Date | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audio<T extends Job$audioArgs<ExtArgs> = {}>(args?: Subset<T, Job$audioArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    run<T extends TranscriptRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptRunDefaultArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly audioId: FieldRef<"Job", 'String'>
    readonly runId: FieldRef<"Job", 'String'>
    readonly jobType: FieldRef<"Job", 'String'>
    readonly providerJobId: FieldRef<"Job", 'String'>
    readonly status: FieldRef<"Job", 'String'>
    readonly retryCount: FieldRef<"Job", 'Int'>
    readonly nextRetryAt: FieldRef<"Job", 'DateTime'>
    readonly errorMessage: FieldRef<"Job", 'String'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job.audio
   */
  export type Job$audioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioFile
     */
    select?: AudioFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioFile
     */
    omit?: AudioFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioFileInclude<ExtArgs> | null
    where?: AudioFileWhereInput
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    kind: string | null
    targetId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    kind: string | null
    targetId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    kind: number
    targetId: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    kind?: true
    targetId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    kind?: true
    targetId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    kind?: true
    targetId?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    kind: string
    targetId: string | null
    meta: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    kind?: boolean
    targetId?: boolean
    meta?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    kind?: boolean
    targetId?: boolean
    meta?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    kind?: boolean
    targetId?: boolean
    meta?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    kind?: boolean
    targetId?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "kind" | "targetId" | "meta" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      kind: string
      targetId: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly kind: FieldRef<"AuditLog", 'String'>
    readonly targetId: FieldRef<"AuditLog", 'String'>
    readonly meta: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.SubscriptionStatus | null
    planType: string | null
    startedAt: Date | null
    expiresAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.SubscriptionStatus | null
    planType: string | null
    startedAt: Date | null
    expiresAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    planType: number
    startedAt: number
    expiresAt: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    planType?: true
    startedAt?: true
    expiresAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    planType?: true
    startedAt?: true
    expiresAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    planType?: true
    startedAt?: true
    expiresAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.SubscriptionStatus
    planType: string
    startedAt: Date
    expiresAt: Date
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    planType?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    planType?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    planType?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    planType?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "planType" | "startedAt" | "expiresAt" | "cancelledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.SubscriptionStatus
      planType: string
      startedAt: Date
      expiresAt: Date
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly planType: FieldRef<"Subscription", 'String'>
    readonly startedAt: FieldRef<"Subscription", 'DateTime'>
    readonly expiresAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SharedBbcResource
   */

  export type AggregateSharedBbcResource = {
    _count: SharedBbcResourceCountAggregateOutputType | null
    _avg: SharedBbcResourceAvgAggregateOutputType | null
    _sum: SharedBbcResourceSumAggregateOutputType | null
    _min: SharedBbcResourceMinAggregateOutputType | null
    _max: SharedBbcResourceMaxAggregateOutputType | null
  }

  export type SharedBbcResourceAvgAggregateOutputType = {
    durationMs: number | null
    episodeNumber: number | null
    seasonNumber: number | null
  }

  export type SharedBbcResourceSumAggregateOutputType = {
    durationMs: number | null
    episodeNumber: number | null
    seasonNumber: number | null
  }

  export type SharedBbcResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    externalUrl: string | null
    durationMs: number | null
    transcript: string | null
    uploadedById: string | null
    isPublished: boolean | null
    publishDate: Date | null
    episodeNumber: number | null
    seasonNumber: number | null
    bbcUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sourceType: string | null
    licenseInfo: string | null
  }

  export type SharedBbcResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    externalUrl: string | null
    durationMs: number | null
    transcript: string | null
    uploadedById: string | null
    isPublished: boolean | null
    publishDate: Date | null
    episodeNumber: number | null
    seasonNumber: number | null
    bbcUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sourceType: string | null
    licenseInfo: string | null
  }

  export type SharedBbcResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    externalUrl: number
    durationMs: number
    transcript: number
    segments: number
    uploadedById: number
    isPublished: number
    publishDate: number
    episodeNumber: number
    seasonNumber: number
    bbcUrl: number
    createdAt: number
    updatedAt: number
    sourceType: number
    licenseInfo: number
    _all: number
  }


  export type SharedBbcResourceAvgAggregateInputType = {
    durationMs?: true
    episodeNumber?: true
    seasonNumber?: true
  }

  export type SharedBbcResourceSumAggregateInputType = {
    durationMs?: true
    episodeNumber?: true
    seasonNumber?: true
  }

  export type SharedBbcResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    externalUrl?: true
    durationMs?: true
    transcript?: true
    uploadedById?: true
    isPublished?: true
    publishDate?: true
    episodeNumber?: true
    seasonNumber?: true
    bbcUrl?: true
    createdAt?: true
    updatedAt?: true
    sourceType?: true
    licenseInfo?: true
  }

  export type SharedBbcResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    externalUrl?: true
    durationMs?: true
    transcript?: true
    uploadedById?: true
    isPublished?: true
    publishDate?: true
    episodeNumber?: true
    seasonNumber?: true
    bbcUrl?: true
    createdAt?: true
    updatedAt?: true
    sourceType?: true
    licenseInfo?: true
  }

  export type SharedBbcResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    externalUrl?: true
    durationMs?: true
    transcript?: true
    segments?: true
    uploadedById?: true
    isPublished?: true
    publishDate?: true
    episodeNumber?: true
    seasonNumber?: true
    bbcUrl?: true
    createdAt?: true
    updatedAt?: true
    sourceType?: true
    licenseInfo?: true
    _all?: true
  }

  export type SharedBbcResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedBbcResource to aggregate.
     */
    where?: SharedBbcResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedBbcResources to fetch.
     */
    orderBy?: SharedBbcResourceOrderByWithRelationInput | SharedBbcResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedBbcResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedBbcResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedBbcResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedBbcResources
    **/
    _count?: true | SharedBbcResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharedBbcResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharedBbcResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedBbcResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedBbcResourceMaxAggregateInputType
  }

  export type GetSharedBbcResourceAggregateType<T extends SharedBbcResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedBbcResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedBbcResource[P]>
      : GetScalarType<T[P], AggregateSharedBbcResource[P]>
  }




  export type SharedBbcResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedBbcResourceWhereInput
    orderBy?: SharedBbcResourceOrderByWithAggregationInput | SharedBbcResourceOrderByWithAggregationInput[]
    by: SharedBbcResourceScalarFieldEnum[] | SharedBbcResourceScalarFieldEnum
    having?: SharedBbcResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedBbcResourceCountAggregateInputType | true
    _avg?: SharedBbcResourceAvgAggregateInputType
    _sum?: SharedBbcResourceSumAggregateInputType
    _min?: SharedBbcResourceMinAggregateInputType
    _max?: SharedBbcResourceMaxAggregateInputType
  }

  export type SharedBbcResourceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    externalUrl: string | null
    durationMs: number | null
    transcript: string | null
    segments: JsonValue | null
    uploadedById: string
    isPublished: boolean
    publishDate: Date | null
    episodeNumber: number | null
    seasonNumber: number | null
    bbcUrl: string | null
    createdAt: Date
    updatedAt: Date
    sourceType: string
    licenseInfo: string | null
    _count: SharedBbcResourceCountAggregateOutputType | null
    _avg: SharedBbcResourceAvgAggregateOutputType | null
    _sum: SharedBbcResourceSumAggregateOutputType | null
    _min: SharedBbcResourceMinAggregateOutputType | null
    _max: SharedBbcResourceMaxAggregateOutputType | null
  }

  type GetSharedBbcResourceGroupByPayload<T extends SharedBbcResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedBbcResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedBbcResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedBbcResourceGroupByOutputType[P]>
            : GetScalarType<T[P], SharedBbcResourceGroupByOutputType[P]>
        }
      >
    >


  export type SharedBbcResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    externalUrl?: boolean
    durationMs?: boolean
    transcript?: boolean
    segments?: boolean
    uploadedById?: boolean
    isPublished?: boolean
    publishDate?: boolean
    episodeNumber?: boolean
    seasonNumber?: boolean
    bbcUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceType?: boolean
    licenseInfo?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    takedownRequests?: boolean | SharedBbcResource$takedownRequestsArgs<ExtArgs>
    _count?: boolean | SharedBbcResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedBbcResource"]>

  export type SharedBbcResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    externalUrl?: boolean
    durationMs?: boolean
    transcript?: boolean
    segments?: boolean
    uploadedById?: boolean
    isPublished?: boolean
    publishDate?: boolean
    episodeNumber?: boolean
    seasonNumber?: boolean
    bbcUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceType?: boolean
    licenseInfo?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedBbcResource"]>

  export type SharedBbcResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    externalUrl?: boolean
    durationMs?: boolean
    transcript?: boolean
    segments?: boolean
    uploadedById?: boolean
    isPublished?: boolean
    publishDate?: boolean
    episodeNumber?: boolean
    seasonNumber?: boolean
    bbcUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceType?: boolean
    licenseInfo?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedBbcResource"]>

  export type SharedBbcResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    externalUrl?: boolean
    durationMs?: boolean
    transcript?: boolean
    segments?: boolean
    uploadedById?: boolean
    isPublished?: boolean
    publishDate?: boolean
    episodeNumber?: boolean
    seasonNumber?: boolean
    bbcUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceType?: boolean
    licenseInfo?: boolean
  }

  export type SharedBbcResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "externalUrl" | "durationMs" | "transcript" | "segments" | "uploadedById" | "isPublished" | "publishDate" | "episodeNumber" | "seasonNumber" | "bbcUrl" | "createdAt" | "updatedAt" | "sourceType" | "licenseInfo", ExtArgs["result"]["sharedBbcResource"]>
  export type SharedBbcResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    takedownRequests?: boolean | SharedBbcResource$takedownRequestsArgs<ExtArgs>
    _count?: boolean | SharedBbcResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SharedBbcResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SharedBbcResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SharedBbcResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedBbcResource"
    objects: {
      uploadedBy: Prisma.$UserPayload<ExtArgs>
      takedownRequests: Prisma.$TakedownRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      externalUrl: string | null
      durationMs: number | null
      transcript: string | null
      segments: Prisma.JsonValue | null
      uploadedById: string
      isPublished: boolean
      publishDate: Date | null
      episodeNumber: number | null
      seasonNumber: number | null
      bbcUrl: string | null
      createdAt: Date
      updatedAt: Date
      sourceType: string
      licenseInfo: string | null
    }, ExtArgs["result"]["sharedBbcResource"]>
    composites: {}
  }

  type SharedBbcResourceGetPayload<S extends boolean | null | undefined | SharedBbcResourceDefaultArgs> = $Result.GetResult<Prisma.$SharedBbcResourcePayload, S>

  type SharedBbcResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedBbcResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedBbcResourceCountAggregateInputType | true
    }

  export interface SharedBbcResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedBbcResource'], meta: { name: 'SharedBbcResource' } }
    /**
     * Find zero or one SharedBbcResource that matches the filter.
     * @param {SharedBbcResourceFindUniqueArgs} args - Arguments to find a SharedBbcResource
     * @example
     * // Get one SharedBbcResource
     * const sharedBbcResource = await prisma.sharedBbcResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedBbcResourceFindUniqueArgs>(args: SelectSubset<T, SharedBbcResourceFindUniqueArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedBbcResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedBbcResourceFindUniqueOrThrowArgs} args - Arguments to find a SharedBbcResource
     * @example
     * // Get one SharedBbcResource
     * const sharedBbcResource = await prisma.sharedBbcResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedBbcResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedBbcResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedBbcResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceFindFirstArgs} args - Arguments to find a SharedBbcResource
     * @example
     * // Get one SharedBbcResource
     * const sharedBbcResource = await prisma.sharedBbcResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedBbcResourceFindFirstArgs>(args?: SelectSubset<T, SharedBbcResourceFindFirstArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedBbcResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceFindFirstOrThrowArgs} args - Arguments to find a SharedBbcResource
     * @example
     * // Get one SharedBbcResource
     * const sharedBbcResource = await prisma.sharedBbcResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedBbcResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedBbcResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedBbcResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedBbcResources
     * const sharedBbcResources = await prisma.sharedBbcResource.findMany()
     * 
     * // Get first 10 SharedBbcResources
     * const sharedBbcResources = await prisma.sharedBbcResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedBbcResourceWithIdOnly = await prisma.sharedBbcResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedBbcResourceFindManyArgs>(args?: SelectSubset<T, SharedBbcResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedBbcResource.
     * @param {SharedBbcResourceCreateArgs} args - Arguments to create a SharedBbcResource.
     * @example
     * // Create one SharedBbcResource
     * const SharedBbcResource = await prisma.sharedBbcResource.create({
     *   data: {
     *     // ... data to create a SharedBbcResource
     *   }
     * })
     * 
     */
    create<T extends SharedBbcResourceCreateArgs>(args: SelectSubset<T, SharedBbcResourceCreateArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedBbcResources.
     * @param {SharedBbcResourceCreateManyArgs} args - Arguments to create many SharedBbcResources.
     * @example
     * // Create many SharedBbcResources
     * const sharedBbcResource = await prisma.sharedBbcResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedBbcResourceCreateManyArgs>(args?: SelectSubset<T, SharedBbcResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedBbcResources and returns the data saved in the database.
     * @param {SharedBbcResourceCreateManyAndReturnArgs} args - Arguments to create many SharedBbcResources.
     * @example
     * // Create many SharedBbcResources
     * const sharedBbcResource = await prisma.sharedBbcResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedBbcResources and only return the `id`
     * const sharedBbcResourceWithIdOnly = await prisma.sharedBbcResource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedBbcResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedBbcResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedBbcResource.
     * @param {SharedBbcResourceDeleteArgs} args - Arguments to delete one SharedBbcResource.
     * @example
     * // Delete one SharedBbcResource
     * const SharedBbcResource = await prisma.sharedBbcResource.delete({
     *   where: {
     *     // ... filter to delete one SharedBbcResource
     *   }
     * })
     * 
     */
    delete<T extends SharedBbcResourceDeleteArgs>(args: SelectSubset<T, SharedBbcResourceDeleteArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedBbcResource.
     * @param {SharedBbcResourceUpdateArgs} args - Arguments to update one SharedBbcResource.
     * @example
     * // Update one SharedBbcResource
     * const sharedBbcResource = await prisma.sharedBbcResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedBbcResourceUpdateArgs>(args: SelectSubset<T, SharedBbcResourceUpdateArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedBbcResources.
     * @param {SharedBbcResourceDeleteManyArgs} args - Arguments to filter SharedBbcResources to delete.
     * @example
     * // Delete a few SharedBbcResources
     * const { count } = await prisma.sharedBbcResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedBbcResourceDeleteManyArgs>(args?: SelectSubset<T, SharedBbcResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedBbcResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedBbcResources
     * const sharedBbcResource = await prisma.sharedBbcResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedBbcResourceUpdateManyArgs>(args: SelectSubset<T, SharedBbcResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedBbcResources and returns the data updated in the database.
     * @param {SharedBbcResourceUpdateManyAndReturnArgs} args - Arguments to update many SharedBbcResources.
     * @example
     * // Update many SharedBbcResources
     * const sharedBbcResource = await prisma.sharedBbcResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedBbcResources and only return the `id`
     * const sharedBbcResourceWithIdOnly = await prisma.sharedBbcResource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedBbcResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedBbcResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedBbcResource.
     * @param {SharedBbcResourceUpsertArgs} args - Arguments to update or create a SharedBbcResource.
     * @example
     * // Update or create a SharedBbcResource
     * const sharedBbcResource = await prisma.sharedBbcResource.upsert({
     *   create: {
     *     // ... data to create a SharedBbcResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedBbcResource we want to update
     *   }
     * })
     */
    upsert<T extends SharedBbcResourceUpsertArgs>(args: SelectSubset<T, SharedBbcResourceUpsertArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedBbcResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceCountArgs} args - Arguments to filter SharedBbcResources to count.
     * @example
     * // Count the number of SharedBbcResources
     * const count = await prisma.sharedBbcResource.count({
     *   where: {
     *     // ... the filter for the SharedBbcResources we want to count
     *   }
     * })
    **/
    count<T extends SharedBbcResourceCountArgs>(
      args?: Subset<T, SharedBbcResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedBbcResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedBbcResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedBbcResourceAggregateArgs>(args: Subset<T, SharedBbcResourceAggregateArgs>): Prisma.PrismaPromise<GetSharedBbcResourceAggregateType<T>>

    /**
     * Group by SharedBbcResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedBbcResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedBbcResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedBbcResourceGroupByArgs['orderBy'] }
        : { orderBy?: SharedBbcResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedBbcResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedBbcResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedBbcResource model
   */
  readonly fields: SharedBbcResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedBbcResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedBbcResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    takedownRequests<T extends SharedBbcResource$takedownRequestsArgs<ExtArgs> = {}>(args?: Subset<T, SharedBbcResource$takedownRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedBbcResource model
   */
  interface SharedBbcResourceFieldRefs {
    readonly id: FieldRef<"SharedBbcResource", 'String'>
    readonly title: FieldRef<"SharedBbcResource", 'String'>
    readonly description: FieldRef<"SharedBbcResource", 'String'>
    readonly externalUrl: FieldRef<"SharedBbcResource", 'String'>
    readonly durationMs: FieldRef<"SharedBbcResource", 'Int'>
    readonly transcript: FieldRef<"SharedBbcResource", 'String'>
    readonly segments: FieldRef<"SharedBbcResource", 'Json'>
    readonly uploadedById: FieldRef<"SharedBbcResource", 'String'>
    readonly isPublished: FieldRef<"SharedBbcResource", 'Boolean'>
    readonly publishDate: FieldRef<"SharedBbcResource", 'DateTime'>
    readonly episodeNumber: FieldRef<"SharedBbcResource", 'Int'>
    readonly seasonNumber: FieldRef<"SharedBbcResource", 'Int'>
    readonly bbcUrl: FieldRef<"SharedBbcResource", 'String'>
    readonly createdAt: FieldRef<"SharedBbcResource", 'DateTime'>
    readonly updatedAt: FieldRef<"SharedBbcResource", 'DateTime'>
    readonly sourceType: FieldRef<"SharedBbcResource", 'String'>
    readonly licenseInfo: FieldRef<"SharedBbcResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SharedBbcResource findUnique
   */
  export type SharedBbcResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * Filter, which SharedBbcResource to fetch.
     */
    where: SharedBbcResourceWhereUniqueInput
  }

  /**
   * SharedBbcResource findUniqueOrThrow
   */
  export type SharedBbcResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * Filter, which SharedBbcResource to fetch.
     */
    where: SharedBbcResourceWhereUniqueInput
  }

  /**
   * SharedBbcResource findFirst
   */
  export type SharedBbcResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * Filter, which SharedBbcResource to fetch.
     */
    where?: SharedBbcResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedBbcResources to fetch.
     */
    orderBy?: SharedBbcResourceOrderByWithRelationInput | SharedBbcResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedBbcResources.
     */
    cursor?: SharedBbcResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedBbcResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedBbcResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedBbcResources.
     */
    distinct?: SharedBbcResourceScalarFieldEnum | SharedBbcResourceScalarFieldEnum[]
  }

  /**
   * SharedBbcResource findFirstOrThrow
   */
  export type SharedBbcResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * Filter, which SharedBbcResource to fetch.
     */
    where?: SharedBbcResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedBbcResources to fetch.
     */
    orderBy?: SharedBbcResourceOrderByWithRelationInput | SharedBbcResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedBbcResources.
     */
    cursor?: SharedBbcResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedBbcResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedBbcResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedBbcResources.
     */
    distinct?: SharedBbcResourceScalarFieldEnum | SharedBbcResourceScalarFieldEnum[]
  }

  /**
   * SharedBbcResource findMany
   */
  export type SharedBbcResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * Filter, which SharedBbcResources to fetch.
     */
    where?: SharedBbcResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedBbcResources to fetch.
     */
    orderBy?: SharedBbcResourceOrderByWithRelationInput | SharedBbcResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedBbcResources.
     */
    cursor?: SharedBbcResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedBbcResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedBbcResources.
     */
    skip?: number
    distinct?: SharedBbcResourceScalarFieldEnum | SharedBbcResourceScalarFieldEnum[]
  }

  /**
   * SharedBbcResource create
   */
  export type SharedBbcResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedBbcResource.
     */
    data: XOR<SharedBbcResourceCreateInput, SharedBbcResourceUncheckedCreateInput>
  }

  /**
   * SharedBbcResource createMany
   */
  export type SharedBbcResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedBbcResources.
     */
    data: SharedBbcResourceCreateManyInput | SharedBbcResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedBbcResource createManyAndReturn
   */
  export type SharedBbcResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * The data used to create many SharedBbcResources.
     */
    data: SharedBbcResourceCreateManyInput | SharedBbcResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedBbcResource update
   */
  export type SharedBbcResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedBbcResource.
     */
    data: XOR<SharedBbcResourceUpdateInput, SharedBbcResourceUncheckedUpdateInput>
    /**
     * Choose, which SharedBbcResource to update.
     */
    where: SharedBbcResourceWhereUniqueInput
  }

  /**
   * SharedBbcResource updateMany
   */
  export type SharedBbcResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedBbcResources.
     */
    data: XOR<SharedBbcResourceUpdateManyMutationInput, SharedBbcResourceUncheckedUpdateManyInput>
    /**
     * Filter which SharedBbcResources to update
     */
    where?: SharedBbcResourceWhereInput
    /**
     * Limit how many SharedBbcResources to update.
     */
    limit?: number
  }

  /**
   * SharedBbcResource updateManyAndReturn
   */
  export type SharedBbcResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * The data used to update SharedBbcResources.
     */
    data: XOR<SharedBbcResourceUpdateManyMutationInput, SharedBbcResourceUncheckedUpdateManyInput>
    /**
     * Filter which SharedBbcResources to update
     */
    where?: SharedBbcResourceWhereInput
    /**
     * Limit how many SharedBbcResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedBbcResource upsert
   */
  export type SharedBbcResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedBbcResource to update in case it exists.
     */
    where: SharedBbcResourceWhereUniqueInput
    /**
     * In case the SharedBbcResource found by the `where` argument doesn't exist, create a new SharedBbcResource with this data.
     */
    create: XOR<SharedBbcResourceCreateInput, SharedBbcResourceUncheckedCreateInput>
    /**
     * In case the SharedBbcResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedBbcResourceUpdateInput, SharedBbcResourceUncheckedUpdateInput>
  }

  /**
   * SharedBbcResource delete
   */
  export type SharedBbcResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
    /**
     * Filter which SharedBbcResource to delete.
     */
    where: SharedBbcResourceWhereUniqueInput
  }

  /**
   * SharedBbcResource deleteMany
   */
  export type SharedBbcResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedBbcResources to delete
     */
    where?: SharedBbcResourceWhereInput
    /**
     * Limit how many SharedBbcResources to delete.
     */
    limit?: number
  }

  /**
   * SharedBbcResource.takedownRequests
   */
  export type SharedBbcResource$takedownRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    where?: TakedownRequestWhereInput
    orderBy?: TakedownRequestOrderByWithRelationInput | TakedownRequestOrderByWithRelationInput[]
    cursor?: TakedownRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TakedownRequestScalarFieldEnum | TakedownRequestScalarFieldEnum[]
  }

  /**
   * SharedBbcResource without action
   */
  export type SharedBbcResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedBbcResource
     */
    select?: SharedBbcResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedBbcResource
     */
    omit?: SharedBbcResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedBbcResourceInclude<ExtArgs> | null
  }


  /**
   * Model LearningSession
   */

  export type AggregateLearningSession = {
    _count: LearningSessionCountAggregateOutputType | null
    _avg: LearningSessionAvgAggregateOutputType | null
    _sum: LearningSessionSumAggregateOutputType | null
    _min: LearningSessionMinAggregateOutputType | null
    _max: LearningSessionMaxAggregateOutputType | null
  }

  export type LearningSessionAvgAggregateOutputType = {
    completedSegments: number | null
    totalSegments: number | null
    listeningTimeMs: number | null
    practiceTimeMs: number | null
    loopCount: number | null
    recordingCount: number | null
    score: number | null
  }

  export type LearningSessionSumAggregateOutputType = {
    completedSegments: number | null
    totalSegments: number | null
    listeningTimeMs: number | null
    practiceTimeMs: number | null
    loopCount: number | null
    recordingCount: number | null
    score: number | null
  }

  export type LearningSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    audioId: string | null
    transcriptRunId: string | null
    completedSegments: number | null
    totalSegments: number | null
    listeningTimeMs: number | null
    practiceTimeMs: number | null
    loopCount: number | null
    recordingCount: number | null
    score: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LearningSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    audioId: string | null
    transcriptRunId: string | null
    completedSegments: number | null
    totalSegments: number | null
    listeningTimeMs: number | null
    practiceTimeMs: number | null
    loopCount: number | null
    recordingCount: number | null
    score: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LearningSessionCountAggregateOutputType = {
    id: number
    userId: number
    audioId: number
    transcriptRunId: number
    completedSegments: number
    totalSegments: number
    listeningTimeMs: number
    practiceTimeMs: number
    loopCount: number
    recordingCount: number
    score: number
    completedAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LearningSessionAvgAggregateInputType = {
    completedSegments?: true
    totalSegments?: true
    listeningTimeMs?: true
    practiceTimeMs?: true
    loopCount?: true
    recordingCount?: true
    score?: true
  }

  export type LearningSessionSumAggregateInputType = {
    completedSegments?: true
    totalSegments?: true
    listeningTimeMs?: true
    practiceTimeMs?: true
    loopCount?: true
    recordingCount?: true
    score?: true
  }

  export type LearningSessionMinAggregateInputType = {
    id?: true
    userId?: true
    audioId?: true
    transcriptRunId?: true
    completedSegments?: true
    totalSegments?: true
    listeningTimeMs?: true
    practiceTimeMs?: true
    loopCount?: true
    recordingCount?: true
    score?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LearningSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    audioId?: true
    transcriptRunId?: true
    completedSegments?: true
    totalSegments?: true
    listeningTimeMs?: true
    practiceTimeMs?: true
    loopCount?: true
    recordingCount?: true
    score?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LearningSessionCountAggregateInputType = {
    id?: true
    userId?: true
    audioId?: true
    transcriptRunId?: true
    completedSegments?: true
    totalSegments?: true
    listeningTimeMs?: true
    practiceTimeMs?: true
    loopCount?: true
    recordingCount?: true
    score?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LearningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSession to aggregate.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningSessions
    **/
    _count?: true | LearningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningSessionMaxAggregateInputType
  }

  export type GetLearningSessionAggregateType<T extends LearningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningSession[P]>
      : GetScalarType<T[P], AggregateLearningSession[P]>
  }




  export type LearningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithAggregationInput | LearningSessionOrderByWithAggregationInput[]
    by: LearningSessionScalarFieldEnum[] | LearningSessionScalarFieldEnum
    having?: LearningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningSessionCountAggregateInputType | true
    _avg?: LearningSessionAvgAggregateInputType
    _sum?: LearningSessionSumAggregateInputType
    _min?: LearningSessionMinAggregateInputType
    _max?: LearningSessionMaxAggregateInputType
  }

  export type LearningSessionGroupByOutputType = {
    id: string
    userId: string
    audioId: string
    transcriptRunId: string | null
    completedSegments: number
    totalSegments: number
    listeningTimeMs: number
    practiceTimeMs: number
    loopCount: number
    recordingCount: number
    score: number | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: LearningSessionCountAggregateOutputType | null
    _avg: LearningSessionAvgAggregateOutputType | null
    _sum: LearningSessionSumAggregateOutputType | null
    _min: LearningSessionMinAggregateOutputType | null
    _max: LearningSessionMaxAggregateOutputType | null
  }

  type GetLearningSessionGroupByPayload<T extends LearningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], LearningSessionGroupByOutputType[P]>
        }
      >
    >


  export type LearningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    audioId?: boolean
    transcriptRunId?: boolean
    completedSegments?: boolean
    totalSegments?: boolean
    listeningTimeMs?: boolean
    practiceTimeMs?: boolean
    loopCount?: boolean
    recordingCount?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    audioFile?: boolean | AudioFileDefaultArgs<ExtArgs>
    transcriptRun?: boolean | LearningSession$transcriptRunArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    audioId?: boolean
    transcriptRunId?: boolean
    completedSegments?: boolean
    totalSegments?: boolean
    listeningTimeMs?: boolean
    practiceTimeMs?: boolean
    loopCount?: boolean
    recordingCount?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    audioFile?: boolean | AudioFileDefaultArgs<ExtArgs>
    transcriptRun?: boolean | LearningSession$transcriptRunArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    audioId?: boolean
    transcriptRunId?: boolean
    completedSegments?: boolean
    totalSegments?: boolean
    listeningTimeMs?: boolean
    practiceTimeMs?: boolean
    loopCount?: boolean
    recordingCount?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    audioFile?: boolean | AudioFileDefaultArgs<ExtArgs>
    transcriptRun?: boolean | LearningSession$transcriptRunArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    audioId?: boolean
    transcriptRunId?: boolean
    completedSegments?: boolean
    totalSegments?: boolean
    listeningTimeMs?: boolean
    practiceTimeMs?: boolean
    loopCount?: boolean
    recordingCount?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LearningSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "audioId" | "transcriptRunId" | "completedSegments" | "totalSegments" | "listeningTimeMs" | "practiceTimeMs" | "loopCount" | "recordingCount" | "score" | "completedAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["learningSession"]>
  export type LearningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    audioFile?: boolean | AudioFileDefaultArgs<ExtArgs>
    transcriptRun?: boolean | LearningSession$transcriptRunArgs<ExtArgs>
  }
  export type LearningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    audioFile?: boolean | AudioFileDefaultArgs<ExtArgs>
    transcriptRun?: boolean | LearningSession$transcriptRunArgs<ExtArgs>
  }
  export type LearningSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    audioFile?: boolean | AudioFileDefaultArgs<ExtArgs>
    transcriptRun?: boolean | LearningSession$transcriptRunArgs<ExtArgs>
  }

  export type $LearningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      audioFile: Prisma.$AudioFilePayload<ExtArgs>
      transcriptRun: Prisma.$TranscriptRunPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      audioId: string
      transcriptRunId: string | null
      completedSegments: number
      totalSegments: number
      listeningTimeMs: number
      practiceTimeMs: number
      loopCount: number
      recordingCount: number
      score: number | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["learningSession"]>
    composites: {}
  }

  type LearningSessionGetPayload<S extends boolean | null | undefined | LearningSessionDefaultArgs> = $Result.GetResult<Prisma.$LearningSessionPayload, S>

  type LearningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningSessionCountAggregateInputType | true
    }

  export interface LearningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningSession'], meta: { name: 'LearningSession' } }
    /**
     * Find zero or one LearningSession that matches the filter.
     * @param {LearningSessionFindUniqueArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningSessionFindUniqueArgs>(args: SelectSubset<T, LearningSessionFindUniqueArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningSessionFindUniqueOrThrowArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindFirstArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningSessionFindFirstArgs>(args?: SelectSubset<T, LearningSessionFindFirstArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindFirstOrThrowArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningSessions
     * const learningSessions = await prisma.learningSession.findMany()
     * 
     * // Get first 10 LearningSessions
     * const learningSessions = await prisma.learningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningSessionFindManyArgs>(args?: SelectSubset<T, LearningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningSession.
     * @param {LearningSessionCreateArgs} args - Arguments to create a LearningSession.
     * @example
     * // Create one LearningSession
     * const LearningSession = await prisma.learningSession.create({
     *   data: {
     *     // ... data to create a LearningSession
     *   }
     * })
     * 
     */
    create<T extends LearningSessionCreateArgs>(args: SelectSubset<T, LearningSessionCreateArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningSessions.
     * @param {LearningSessionCreateManyArgs} args - Arguments to create many LearningSessions.
     * @example
     * // Create many LearningSessions
     * const learningSession = await prisma.learningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningSessionCreateManyArgs>(args?: SelectSubset<T, LearningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningSessions and returns the data saved in the database.
     * @param {LearningSessionCreateManyAndReturnArgs} args - Arguments to create many LearningSessions.
     * @example
     * // Create many LearningSessions
     * const learningSession = await prisma.learningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningSessions and only return the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningSession.
     * @param {LearningSessionDeleteArgs} args - Arguments to delete one LearningSession.
     * @example
     * // Delete one LearningSession
     * const LearningSession = await prisma.learningSession.delete({
     *   where: {
     *     // ... filter to delete one LearningSession
     *   }
     * })
     * 
     */
    delete<T extends LearningSessionDeleteArgs>(args: SelectSubset<T, LearningSessionDeleteArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningSession.
     * @param {LearningSessionUpdateArgs} args - Arguments to update one LearningSession.
     * @example
     * // Update one LearningSession
     * const learningSession = await prisma.learningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningSessionUpdateArgs>(args: SelectSubset<T, LearningSessionUpdateArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningSessions.
     * @param {LearningSessionDeleteManyArgs} args - Arguments to filter LearningSessions to delete.
     * @example
     * // Delete a few LearningSessions
     * const { count } = await prisma.learningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningSessionDeleteManyArgs>(args?: SelectSubset<T, LearningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningSessions
     * const learningSession = await prisma.learningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningSessionUpdateManyArgs>(args: SelectSubset<T, LearningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningSessions and returns the data updated in the database.
     * @param {LearningSessionUpdateManyAndReturnArgs} args - Arguments to update many LearningSessions.
     * @example
     * // Update many LearningSessions
     * const learningSession = await prisma.learningSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningSessions and only return the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningSession.
     * @param {LearningSessionUpsertArgs} args - Arguments to update or create a LearningSession.
     * @example
     * // Update or create a LearningSession
     * const learningSession = await prisma.learningSession.upsert({
     *   create: {
     *     // ... data to create a LearningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningSession we want to update
     *   }
     * })
     */
    upsert<T extends LearningSessionUpsertArgs>(args: SelectSubset<T, LearningSessionUpsertArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionCountArgs} args - Arguments to filter LearningSessions to count.
     * @example
     * // Count the number of LearningSessions
     * const count = await prisma.learningSession.count({
     *   where: {
     *     // ... the filter for the LearningSessions we want to count
     *   }
     * })
    **/
    count<T extends LearningSessionCountArgs>(
      args?: Subset<T, LearningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningSessionAggregateArgs>(args: Subset<T, LearningSessionAggregateArgs>): Prisma.PrismaPromise<GetLearningSessionAggregateType<T>>

    /**
     * Group by LearningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningSessionGroupByArgs['orderBy'] }
        : { orderBy?: LearningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningSession model
   */
  readonly fields: LearningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    audioFile<T extends AudioFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudioFileDefaultArgs<ExtArgs>>): Prisma__AudioFileClient<$Result.GetResult<Prisma.$AudioFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transcriptRun<T extends LearningSession$transcriptRunArgs<ExtArgs> = {}>(args?: Subset<T, LearningSession$transcriptRunArgs<ExtArgs>>): Prisma__TranscriptRunClient<$Result.GetResult<Prisma.$TranscriptRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningSession model
   */
  interface LearningSessionFieldRefs {
    readonly id: FieldRef<"LearningSession", 'String'>
    readonly userId: FieldRef<"LearningSession", 'String'>
    readonly audioId: FieldRef<"LearningSession", 'String'>
    readonly transcriptRunId: FieldRef<"LearningSession", 'String'>
    readonly completedSegments: FieldRef<"LearningSession", 'Int'>
    readonly totalSegments: FieldRef<"LearningSession", 'Int'>
    readonly listeningTimeMs: FieldRef<"LearningSession", 'Int'>
    readonly practiceTimeMs: FieldRef<"LearningSession", 'Int'>
    readonly loopCount: FieldRef<"LearningSession", 'Int'>
    readonly recordingCount: FieldRef<"LearningSession", 'Int'>
    readonly score: FieldRef<"LearningSession", 'Float'>
    readonly completedAt: FieldRef<"LearningSession", 'DateTime'>
    readonly createdAt: FieldRef<"LearningSession", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningSession", 'DateTime'>
    readonly deletedAt: FieldRef<"LearningSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningSession findUnique
   */
  export type LearningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession findUniqueOrThrow
   */
  export type LearningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession findFirst
   */
  export type LearningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessions.
     */
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession findFirstOrThrow
   */
  export type LearningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessions.
     */
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession findMany
   */
  export type LearningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessions to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession create
   */
  export type LearningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningSession.
     */
    data: XOR<LearningSessionCreateInput, LearningSessionUncheckedCreateInput>
  }

  /**
   * LearningSession createMany
   */
  export type LearningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningSessions.
     */
    data: LearningSessionCreateManyInput | LearningSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningSession createManyAndReturn
   */
  export type LearningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * The data used to create many LearningSessions.
     */
    data: LearningSessionCreateManyInput | LearningSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningSession update
   */
  export type LearningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningSession.
     */
    data: XOR<LearningSessionUpdateInput, LearningSessionUncheckedUpdateInput>
    /**
     * Choose, which LearningSession to update.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession updateMany
   */
  export type LearningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningSessions.
     */
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyInput>
    /**
     * Filter which LearningSessions to update
     */
    where?: LearningSessionWhereInput
    /**
     * Limit how many LearningSessions to update.
     */
    limit?: number
  }

  /**
   * LearningSession updateManyAndReturn
   */
  export type LearningSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * The data used to update LearningSessions.
     */
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyInput>
    /**
     * Filter which LearningSessions to update
     */
    where?: LearningSessionWhereInput
    /**
     * Limit how many LearningSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningSession upsert
   */
  export type LearningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningSession to update in case it exists.
     */
    where: LearningSessionWhereUniqueInput
    /**
     * In case the LearningSession found by the `where` argument doesn't exist, create a new LearningSession with this data.
     */
    create: XOR<LearningSessionCreateInput, LearningSessionUncheckedCreateInput>
    /**
     * In case the LearningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningSessionUpdateInput, LearningSessionUncheckedUpdateInput>
  }

  /**
   * LearningSession delete
   */
  export type LearningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter which LearningSession to delete.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession deleteMany
   */
  export type LearningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSessions to delete
     */
    where?: LearningSessionWhereInput
    /**
     * Limit how many LearningSessions to delete.
     */
    limit?: number
  }

  /**
   * LearningSession.transcriptRun
   */
  export type LearningSession$transcriptRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptRun
     */
    select?: TranscriptRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptRun
     */
    omit?: TranscriptRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptRunInclude<ExtArgs> | null
    where?: TranscriptRunWhereInput
  }

  /**
   * LearningSession without action
   */
  export type LearningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokenHash" | "expiresAt" | "usedAt" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly tokenHash: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model TakedownRequest
   */

  export type AggregateTakedownRequest = {
    _count: TakedownRequestCountAggregateOutputType | null
    _min: TakedownRequestMinAggregateOutputType | null
    _max: TakedownRequestMaxAggregateOutputType | null
  }

  export type TakedownRequestMinAggregateOutputType = {
    id: string | null
    resourceId: string | null
    reason: string | null
    contactInfo: string | null
    additionalInfo: string | null
    requestType: string | null
    status: string | null
    adminNotes: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TakedownRequestMaxAggregateOutputType = {
    id: string | null
    resourceId: string | null
    reason: string | null
    contactInfo: string | null
    additionalInfo: string | null
    requestType: string | null
    status: string | null
    adminNotes: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TakedownRequestCountAggregateOutputType = {
    id: number
    resourceId: number
    reason: number
    contactInfo: number
    additionalInfo: number
    requestType: number
    status: number
    adminNotes: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TakedownRequestMinAggregateInputType = {
    id?: true
    resourceId?: true
    reason?: true
    contactInfo?: true
    additionalInfo?: true
    requestType?: true
    status?: true
    adminNotes?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TakedownRequestMaxAggregateInputType = {
    id?: true
    resourceId?: true
    reason?: true
    contactInfo?: true
    additionalInfo?: true
    requestType?: true
    status?: true
    adminNotes?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TakedownRequestCountAggregateInputType = {
    id?: true
    resourceId?: true
    reason?: true
    contactInfo?: true
    additionalInfo?: true
    requestType?: true
    status?: true
    adminNotes?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TakedownRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakedownRequest to aggregate.
     */
    where?: TakedownRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakedownRequests to fetch.
     */
    orderBy?: TakedownRequestOrderByWithRelationInput | TakedownRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TakedownRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakedownRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakedownRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TakedownRequests
    **/
    _count?: true | TakedownRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TakedownRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TakedownRequestMaxAggregateInputType
  }

  export type GetTakedownRequestAggregateType<T extends TakedownRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateTakedownRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTakedownRequest[P]>
      : GetScalarType<T[P], AggregateTakedownRequest[P]>
  }




  export type TakedownRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TakedownRequestWhereInput
    orderBy?: TakedownRequestOrderByWithAggregationInput | TakedownRequestOrderByWithAggregationInput[]
    by: TakedownRequestScalarFieldEnum[] | TakedownRequestScalarFieldEnum
    having?: TakedownRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TakedownRequestCountAggregateInputType | true
    _min?: TakedownRequestMinAggregateInputType
    _max?: TakedownRequestMaxAggregateInputType
  }

  export type TakedownRequestGroupByOutputType = {
    id: string
    resourceId: string
    reason: string
    contactInfo: string
    additionalInfo: string | null
    requestType: string
    status: string
    adminNotes: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TakedownRequestCountAggregateOutputType | null
    _min: TakedownRequestMinAggregateOutputType | null
    _max: TakedownRequestMaxAggregateOutputType | null
  }

  type GetTakedownRequestGroupByPayload<T extends TakedownRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TakedownRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TakedownRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TakedownRequestGroupByOutputType[P]>
            : GetScalarType<T[P], TakedownRequestGroupByOutputType[P]>
        }
      >
    >


  export type TakedownRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    reason?: boolean
    contactInfo?: boolean
    additionalInfo?: boolean
    requestType?: boolean
    status?: boolean
    adminNotes?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resource?: boolean | SharedBbcResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takedownRequest"]>

  export type TakedownRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    reason?: boolean
    contactInfo?: boolean
    additionalInfo?: boolean
    requestType?: boolean
    status?: boolean
    adminNotes?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resource?: boolean | SharedBbcResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takedownRequest"]>

  export type TakedownRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceId?: boolean
    reason?: boolean
    contactInfo?: boolean
    additionalInfo?: boolean
    requestType?: boolean
    status?: boolean
    adminNotes?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resource?: boolean | SharedBbcResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["takedownRequest"]>

  export type TakedownRequestSelectScalar = {
    id?: boolean
    resourceId?: boolean
    reason?: boolean
    contactInfo?: boolean
    additionalInfo?: boolean
    requestType?: boolean
    status?: boolean
    adminNotes?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TakedownRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resourceId" | "reason" | "contactInfo" | "additionalInfo" | "requestType" | "status" | "adminNotes" | "resolvedAt" | "resolvedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["takedownRequest"]>
  export type TakedownRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | SharedBbcResourceDefaultArgs<ExtArgs>
  }
  export type TakedownRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | SharedBbcResourceDefaultArgs<ExtArgs>
  }
  export type TakedownRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | SharedBbcResourceDefaultArgs<ExtArgs>
  }

  export type $TakedownRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TakedownRequest"
    objects: {
      resource: Prisma.$SharedBbcResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resourceId: string
      reason: string
      contactInfo: string
      additionalInfo: string | null
      requestType: string
      status: string
      adminNotes: string | null
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["takedownRequest"]>
    composites: {}
  }

  type TakedownRequestGetPayload<S extends boolean | null | undefined | TakedownRequestDefaultArgs> = $Result.GetResult<Prisma.$TakedownRequestPayload, S>

  type TakedownRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TakedownRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TakedownRequestCountAggregateInputType | true
    }

  export interface TakedownRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TakedownRequest'], meta: { name: 'TakedownRequest' } }
    /**
     * Find zero or one TakedownRequest that matches the filter.
     * @param {TakedownRequestFindUniqueArgs} args - Arguments to find a TakedownRequest
     * @example
     * // Get one TakedownRequest
     * const takedownRequest = await prisma.takedownRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TakedownRequestFindUniqueArgs>(args: SelectSubset<T, TakedownRequestFindUniqueArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TakedownRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TakedownRequestFindUniqueOrThrowArgs} args - Arguments to find a TakedownRequest
     * @example
     * // Get one TakedownRequest
     * const takedownRequest = await prisma.takedownRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TakedownRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, TakedownRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TakedownRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestFindFirstArgs} args - Arguments to find a TakedownRequest
     * @example
     * // Get one TakedownRequest
     * const takedownRequest = await prisma.takedownRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TakedownRequestFindFirstArgs>(args?: SelectSubset<T, TakedownRequestFindFirstArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TakedownRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestFindFirstOrThrowArgs} args - Arguments to find a TakedownRequest
     * @example
     * // Get one TakedownRequest
     * const takedownRequest = await prisma.takedownRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TakedownRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, TakedownRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TakedownRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TakedownRequests
     * const takedownRequests = await prisma.takedownRequest.findMany()
     * 
     * // Get first 10 TakedownRequests
     * const takedownRequests = await prisma.takedownRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const takedownRequestWithIdOnly = await prisma.takedownRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TakedownRequestFindManyArgs>(args?: SelectSubset<T, TakedownRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TakedownRequest.
     * @param {TakedownRequestCreateArgs} args - Arguments to create a TakedownRequest.
     * @example
     * // Create one TakedownRequest
     * const TakedownRequest = await prisma.takedownRequest.create({
     *   data: {
     *     // ... data to create a TakedownRequest
     *   }
     * })
     * 
     */
    create<T extends TakedownRequestCreateArgs>(args: SelectSubset<T, TakedownRequestCreateArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TakedownRequests.
     * @param {TakedownRequestCreateManyArgs} args - Arguments to create many TakedownRequests.
     * @example
     * // Create many TakedownRequests
     * const takedownRequest = await prisma.takedownRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TakedownRequestCreateManyArgs>(args?: SelectSubset<T, TakedownRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TakedownRequests and returns the data saved in the database.
     * @param {TakedownRequestCreateManyAndReturnArgs} args - Arguments to create many TakedownRequests.
     * @example
     * // Create many TakedownRequests
     * const takedownRequest = await prisma.takedownRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TakedownRequests and only return the `id`
     * const takedownRequestWithIdOnly = await prisma.takedownRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TakedownRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, TakedownRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TakedownRequest.
     * @param {TakedownRequestDeleteArgs} args - Arguments to delete one TakedownRequest.
     * @example
     * // Delete one TakedownRequest
     * const TakedownRequest = await prisma.takedownRequest.delete({
     *   where: {
     *     // ... filter to delete one TakedownRequest
     *   }
     * })
     * 
     */
    delete<T extends TakedownRequestDeleteArgs>(args: SelectSubset<T, TakedownRequestDeleteArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TakedownRequest.
     * @param {TakedownRequestUpdateArgs} args - Arguments to update one TakedownRequest.
     * @example
     * // Update one TakedownRequest
     * const takedownRequest = await prisma.takedownRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TakedownRequestUpdateArgs>(args: SelectSubset<T, TakedownRequestUpdateArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TakedownRequests.
     * @param {TakedownRequestDeleteManyArgs} args - Arguments to filter TakedownRequests to delete.
     * @example
     * // Delete a few TakedownRequests
     * const { count } = await prisma.takedownRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TakedownRequestDeleteManyArgs>(args?: SelectSubset<T, TakedownRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakedownRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TakedownRequests
     * const takedownRequest = await prisma.takedownRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TakedownRequestUpdateManyArgs>(args: SelectSubset<T, TakedownRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TakedownRequests and returns the data updated in the database.
     * @param {TakedownRequestUpdateManyAndReturnArgs} args - Arguments to update many TakedownRequests.
     * @example
     * // Update many TakedownRequests
     * const takedownRequest = await prisma.takedownRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TakedownRequests and only return the `id`
     * const takedownRequestWithIdOnly = await prisma.takedownRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TakedownRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, TakedownRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TakedownRequest.
     * @param {TakedownRequestUpsertArgs} args - Arguments to update or create a TakedownRequest.
     * @example
     * // Update or create a TakedownRequest
     * const takedownRequest = await prisma.takedownRequest.upsert({
     *   create: {
     *     // ... data to create a TakedownRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TakedownRequest we want to update
     *   }
     * })
     */
    upsert<T extends TakedownRequestUpsertArgs>(args: SelectSubset<T, TakedownRequestUpsertArgs<ExtArgs>>): Prisma__TakedownRequestClient<$Result.GetResult<Prisma.$TakedownRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TakedownRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestCountArgs} args - Arguments to filter TakedownRequests to count.
     * @example
     * // Count the number of TakedownRequests
     * const count = await prisma.takedownRequest.count({
     *   where: {
     *     // ... the filter for the TakedownRequests we want to count
     *   }
     * })
    **/
    count<T extends TakedownRequestCountArgs>(
      args?: Subset<T, TakedownRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TakedownRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TakedownRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TakedownRequestAggregateArgs>(args: Subset<T, TakedownRequestAggregateArgs>): Prisma.PrismaPromise<GetTakedownRequestAggregateType<T>>

    /**
     * Group by TakedownRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TakedownRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TakedownRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TakedownRequestGroupByArgs['orderBy'] }
        : { orderBy?: TakedownRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TakedownRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTakedownRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TakedownRequest model
   */
  readonly fields: TakedownRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TakedownRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TakedownRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends SharedBbcResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SharedBbcResourceDefaultArgs<ExtArgs>>): Prisma__SharedBbcResourceClient<$Result.GetResult<Prisma.$SharedBbcResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TakedownRequest model
   */
  interface TakedownRequestFieldRefs {
    readonly id: FieldRef<"TakedownRequest", 'String'>
    readonly resourceId: FieldRef<"TakedownRequest", 'String'>
    readonly reason: FieldRef<"TakedownRequest", 'String'>
    readonly contactInfo: FieldRef<"TakedownRequest", 'String'>
    readonly additionalInfo: FieldRef<"TakedownRequest", 'String'>
    readonly requestType: FieldRef<"TakedownRequest", 'String'>
    readonly status: FieldRef<"TakedownRequest", 'String'>
    readonly adminNotes: FieldRef<"TakedownRequest", 'String'>
    readonly resolvedAt: FieldRef<"TakedownRequest", 'DateTime'>
    readonly resolvedBy: FieldRef<"TakedownRequest", 'String'>
    readonly createdAt: FieldRef<"TakedownRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"TakedownRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TakedownRequest findUnique
   */
  export type TakedownRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * Filter, which TakedownRequest to fetch.
     */
    where: TakedownRequestWhereUniqueInput
  }

  /**
   * TakedownRequest findUniqueOrThrow
   */
  export type TakedownRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * Filter, which TakedownRequest to fetch.
     */
    where: TakedownRequestWhereUniqueInput
  }

  /**
   * TakedownRequest findFirst
   */
  export type TakedownRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * Filter, which TakedownRequest to fetch.
     */
    where?: TakedownRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakedownRequests to fetch.
     */
    orderBy?: TakedownRequestOrderByWithRelationInput | TakedownRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakedownRequests.
     */
    cursor?: TakedownRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakedownRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakedownRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakedownRequests.
     */
    distinct?: TakedownRequestScalarFieldEnum | TakedownRequestScalarFieldEnum[]
  }

  /**
   * TakedownRequest findFirstOrThrow
   */
  export type TakedownRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * Filter, which TakedownRequest to fetch.
     */
    where?: TakedownRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakedownRequests to fetch.
     */
    orderBy?: TakedownRequestOrderByWithRelationInput | TakedownRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TakedownRequests.
     */
    cursor?: TakedownRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakedownRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakedownRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TakedownRequests.
     */
    distinct?: TakedownRequestScalarFieldEnum | TakedownRequestScalarFieldEnum[]
  }

  /**
   * TakedownRequest findMany
   */
  export type TakedownRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * Filter, which TakedownRequests to fetch.
     */
    where?: TakedownRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TakedownRequests to fetch.
     */
    orderBy?: TakedownRequestOrderByWithRelationInput | TakedownRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TakedownRequests.
     */
    cursor?: TakedownRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TakedownRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TakedownRequests.
     */
    skip?: number
    distinct?: TakedownRequestScalarFieldEnum | TakedownRequestScalarFieldEnum[]
  }

  /**
   * TakedownRequest create
   */
  export type TakedownRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a TakedownRequest.
     */
    data: XOR<TakedownRequestCreateInput, TakedownRequestUncheckedCreateInput>
  }

  /**
   * TakedownRequest createMany
   */
  export type TakedownRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TakedownRequests.
     */
    data: TakedownRequestCreateManyInput | TakedownRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TakedownRequest createManyAndReturn
   */
  export type TakedownRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * The data used to create many TakedownRequests.
     */
    data: TakedownRequestCreateManyInput | TakedownRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TakedownRequest update
   */
  export type TakedownRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a TakedownRequest.
     */
    data: XOR<TakedownRequestUpdateInput, TakedownRequestUncheckedUpdateInput>
    /**
     * Choose, which TakedownRequest to update.
     */
    where: TakedownRequestWhereUniqueInput
  }

  /**
   * TakedownRequest updateMany
   */
  export type TakedownRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TakedownRequests.
     */
    data: XOR<TakedownRequestUpdateManyMutationInput, TakedownRequestUncheckedUpdateManyInput>
    /**
     * Filter which TakedownRequests to update
     */
    where?: TakedownRequestWhereInput
    /**
     * Limit how many TakedownRequests to update.
     */
    limit?: number
  }

  /**
   * TakedownRequest updateManyAndReturn
   */
  export type TakedownRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * The data used to update TakedownRequests.
     */
    data: XOR<TakedownRequestUpdateManyMutationInput, TakedownRequestUncheckedUpdateManyInput>
    /**
     * Filter which TakedownRequests to update
     */
    where?: TakedownRequestWhereInput
    /**
     * Limit how many TakedownRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TakedownRequest upsert
   */
  export type TakedownRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the TakedownRequest to update in case it exists.
     */
    where: TakedownRequestWhereUniqueInput
    /**
     * In case the TakedownRequest found by the `where` argument doesn't exist, create a new TakedownRequest with this data.
     */
    create: XOR<TakedownRequestCreateInput, TakedownRequestUncheckedCreateInput>
    /**
     * In case the TakedownRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TakedownRequestUpdateInput, TakedownRequestUncheckedUpdateInput>
  }

  /**
   * TakedownRequest delete
   */
  export type TakedownRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
    /**
     * Filter which TakedownRequest to delete.
     */
    where: TakedownRequestWhereUniqueInput
  }

  /**
   * TakedownRequest deleteMany
   */
  export type TakedownRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TakedownRequests to delete
     */
    where?: TakedownRequestWhereInput
    /**
     * Limit how many TakedownRequests to delete.
     */
    limit?: number
  }

  /**
   * TakedownRequest without action
   */
  export type TakedownRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TakedownRequest
     */
    select?: TakedownRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TakedownRequest
     */
    omit?: TakedownRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TakedownRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    emailVerified: 'emailVerified',
    settings: 'settings',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AuthSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type AuthSessionScalarFieldEnum = (typeof AuthSessionScalarFieldEnum)[keyof typeof AuthSessionScalarFieldEnum]


  export const AudioFileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gcsUri: 'gcsUri',
    filename: 'filename',
    durationMs: 'durationMs',
    sizeBytes: 'sizeBytes',
    language: 'language',
    mode: 'mode',
    gapSec: 'gapSec',
    status: 'status',
    errorMessage: 'errorMessage',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AudioFileScalarFieldEnum = (typeof AudioFileScalarFieldEnum)[keyof typeof AudioFileScalarFieldEnum]


  export const TranscriptRunScalarFieldEnum: {
    id: 'id',
    audioId: 'audioId',
    authorId: 'authorId',
    version: 'version',
    engine: 'engine',
    params: 'params',
    paramsHash: 'paramsHash',
    status: 'status',
    error: 'error',
    text: 'text',
    segments: 'segments',
    speakerCount: 'speakerCount',
    confidence: 'confidence',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type TranscriptRunScalarFieldEnum = (typeof TranscriptRunScalarFieldEnum)[keyof typeof TranscriptRunScalarFieldEnum]


  export const TranscriptRevisionScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    title: 'title',
    text: 'text',
    segments: 'segments',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type TranscriptRevisionScalarFieldEnum = (typeof TranscriptRevisionScalarFieldEnum)[keyof typeof TranscriptRevisionScalarFieldEnum]


  export const AnalysisScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    segmentIndex: 'segmentIndex',
    kind: 'kind',
    engine: 'engine',
    params: 'params',
    paramsHash: 'paramsHash',
    status: 'status',
    summary: 'summary',
    score: 'score',
    result: 'result',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type AnalysisScalarFieldEnum = (typeof AnalysisScalarFieldEnum)[keyof typeof AnalysisScalarFieldEnum]


  export const AnnotationScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    userId: 'userId',
    content: 'content',
    anchorType: 'anchorType',
    anchorValue: 'anchorValue',
    createdAt: 'createdAt',
    isDeleted: 'isDeleted'
  };

  export type AnnotationScalarFieldEnum = (typeof AnnotationScalarFieldEnum)[keyof typeof AnnotationScalarFieldEnum]


  export const AudioTagScalarFieldEnum: {
    id: 'id',
    audioId: 'audioId',
    key: 'key',
    createdAt: 'createdAt'
  };

  export type AudioTagScalarFieldEnum = (typeof AudioTagScalarFieldEnum)[keyof typeof AudioTagScalarFieldEnum]


  export const UsageLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    day: 'day',
    uploadCount: 'uploadCount',
    durationMs: 'durationMs',
    createdAt: 'createdAt'
  };

  export type UsageLogScalarFieldEnum = (typeof UsageLogScalarFieldEnum)[keyof typeof UsageLogScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    audioId: 'audioId',
    runId: 'runId',
    jobType: 'jobType',
    providerJobId: 'providerJobId',
    status: 'status',
    retryCount: 'retryCount',
    nextRetryAt: 'nextRetryAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    kind: 'kind',
    targetId: 'targetId',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    planType: 'planType',
    startedAt: 'startedAt',
    expiresAt: 'expiresAt',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SharedBbcResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    externalUrl: 'externalUrl',
    durationMs: 'durationMs',
    transcript: 'transcript',
    segments: 'segments',
    uploadedById: 'uploadedById',
    isPublished: 'isPublished',
    publishDate: 'publishDate',
    episodeNumber: 'episodeNumber',
    seasonNumber: 'seasonNumber',
    bbcUrl: 'bbcUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sourceType: 'sourceType',
    licenseInfo: 'licenseInfo'
  };

  export type SharedBbcResourceScalarFieldEnum = (typeof SharedBbcResourceScalarFieldEnum)[keyof typeof SharedBbcResourceScalarFieldEnum]


  export const LearningSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    audioId: 'audioId',
    transcriptRunId: 'transcriptRunId',
    completedSegments: 'completedSegments',
    totalSegments: 'totalSegments',
    listeningTimeMs: 'listeningTimeMs',
    practiceTimeMs: 'practiceTimeMs',
    loopCount: 'loopCount',
    recordingCount: 'recordingCount',
    score: 'score',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LearningSessionScalarFieldEnum = (typeof LearningSessionScalarFieldEnum)[keyof typeof LearningSessionScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const TakedownRequestScalarFieldEnum: {
    id: 'id',
    resourceId: 'resourceId',
    reason: 'reason',
    contactInfo: 'contactInfo',
    additionalInfo: 'additionalInfo',
    requestType: 'requestType',
    status: 'status',
    adminNotes: 'adminNotes',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TakedownRequestScalarFieldEnum = (typeof TakedownRequestScalarFieldEnum)[keyof typeof TakedownRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    settings?: JsonNullableFilter<"User">
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    audioFiles?: AudioFileListRelationFilter
    transcriptRuns?: TranscriptRunListRelationFilter
    annotations?: AnnotationListRelationFilter
    usageLogs?: UsageLogListRelationFilter
    authSessions?: AuthSessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    sharedBbcResources?: SharedBbcResourceListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    settings?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    audioFiles?: AudioFileOrderByRelationAggregateInput
    transcriptRuns?: TranscriptRunOrderByRelationAggregateInput
    annotations?: AnnotationOrderByRelationAggregateInput
    usageLogs?: UsageLogOrderByRelationAggregateInput
    authSessions?: AuthSessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    sharedBbcResources?: SharedBbcResourceOrderByRelationAggregateInput
    learningSessions?: LearningSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    settings?: JsonNullableFilter<"User">
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    audioFiles?: AudioFileListRelationFilter
    transcriptRuns?: TranscriptRunListRelationFilter
    annotations?: AnnotationListRelationFilter
    usageLogs?: UsageLogListRelationFilter
    authSessions?: AuthSessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    sharedBbcResources?: SharedBbcResourceListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    settings?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    settings?: JsonNullableWithAggregatesFilter<"User">
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AuthSessionWhereInput = {
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    id?: StringFilter<"AuthSession"> | string
    userId?: StringFilter<"AuthSession"> | string
    refreshToken?: StringFilter<"AuthSession"> | string
    expiresAt?: DateTimeFilter<"AuthSession"> | Date | string
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    userId?: StringFilter<"AuthSession"> | string
    expiresAt?: DateTimeFilter<"AuthSession"> | Date | string
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "refreshToken">

  export type AuthSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: AuthSessionCountOrderByAggregateInput
    _max?: AuthSessionMaxOrderByAggregateInput
    _min?: AuthSessionMinOrderByAggregateInput
  }

  export type AuthSessionScalarWhereWithAggregatesInput = {
    AND?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    OR?: AuthSessionScalarWhereWithAggregatesInput[]
    NOT?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthSession"> | string
    userId?: StringWithAggregatesFilter<"AuthSession"> | string
    refreshToken?: StringWithAggregatesFilter<"AuthSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
  }

  export type AudioFileWhereInput = {
    AND?: AudioFileWhereInput | AudioFileWhereInput[]
    OR?: AudioFileWhereInput[]
    NOT?: AudioFileWhereInput | AudioFileWhereInput[]
    id?: StringFilter<"AudioFile"> | string
    userId?: StringFilter<"AudioFile"> | string
    gcsUri?: StringFilter<"AudioFile"> | string
    filename?: StringFilter<"AudioFile"> | string
    durationMs?: IntNullableFilter<"AudioFile"> | number | null
    sizeBytes?: BigIntNullableFilter<"AudioFile"> | bigint | number | null
    language?: StringNullableFilter<"AudioFile"> | string | null
    mode?: StringNullableFilter<"AudioFile"> | string | null
    gapSec?: FloatNullableFilter<"AudioFile"> | number | null
    status?: StringFilter<"AudioFile"> | string
    errorMessage?: StringNullableFilter<"AudioFile"> | string | null
    meta?: JsonNullableFilter<"AudioFile">
    createdAt?: DateTimeFilter<"AudioFile"> | Date | string
    updatedAt?: DateTimeFilter<"AudioFile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AudioFile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transcriptRuns?: TranscriptRunListRelationFilter
    tags?: AudioTagListRelationFilter
    Job?: JobListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
  }

  export type AudioFileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gcsUri?: SortOrder
    filename?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    gapSec?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    transcriptRuns?: TranscriptRunOrderByRelationAggregateInput
    tags?: AudioTagOrderByRelationAggregateInput
    Job?: JobOrderByRelationAggregateInput
    learningSessions?: LearningSessionOrderByRelationAggregateInput
  }

  export type AudioFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioFileWhereInput | AudioFileWhereInput[]
    OR?: AudioFileWhereInput[]
    NOT?: AudioFileWhereInput | AudioFileWhereInput[]
    userId?: StringFilter<"AudioFile"> | string
    gcsUri?: StringFilter<"AudioFile"> | string
    filename?: StringFilter<"AudioFile"> | string
    durationMs?: IntNullableFilter<"AudioFile"> | number | null
    sizeBytes?: BigIntNullableFilter<"AudioFile"> | bigint | number | null
    language?: StringNullableFilter<"AudioFile"> | string | null
    mode?: StringNullableFilter<"AudioFile"> | string | null
    gapSec?: FloatNullableFilter<"AudioFile"> | number | null
    status?: StringFilter<"AudioFile"> | string
    errorMessage?: StringNullableFilter<"AudioFile"> | string | null
    meta?: JsonNullableFilter<"AudioFile">
    createdAt?: DateTimeFilter<"AudioFile"> | Date | string
    updatedAt?: DateTimeFilter<"AudioFile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AudioFile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transcriptRuns?: TranscriptRunListRelationFilter
    tags?: AudioTagListRelationFilter
    Job?: JobListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
  }, "id">

  export type AudioFileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gcsUri?: SortOrder
    filename?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    gapSec?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AudioFileCountOrderByAggregateInput
    _avg?: AudioFileAvgOrderByAggregateInput
    _max?: AudioFileMaxOrderByAggregateInput
    _min?: AudioFileMinOrderByAggregateInput
    _sum?: AudioFileSumOrderByAggregateInput
  }

  export type AudioFileScalarWhereWithAggregatesInput = {
    AND?: AudioFileScalarWhereWithAggregatesInput | AudioFileScalarWhereWithAggregatesInput[]
    OR?: AudioFileScalarWhereWithAggregatesInput[]
    NOT?: AudioFileScalarWhereWithAggregatesInput | AudioFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioFile"> | string
    userId?: StringWithAggregatesFilter<"AudioFile"> | string
    gcsUri?: StringWithAggregatesFilter<"AudioFile"> | string
    filename?: StringWithAggregatesFilter<"AudioFile"> | string
    durationMs?: IntNullableWithAggregatesFilter<"AudioFile"> | number | null
    sizeBytes?: BigIntNullableWithAggregatesFilter<"AudioFile"> | bigint | number | null
    language?: StringNullableWithAggregatesFilter<"AudioFile"> | string | null
    mode?: StringNullableWithAggregatesFilter<"AudioFile"> | string | null
    gapSec?: FloatNullableWithAggregatesFilter<"AudioFile"> | number | null
    status?: StringWithAggregatesFilter<"AudioFile"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"AudioFile"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"AudioFile">
    createdAt?: DateTimeWithAggregatesFilter<"AudioFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AudioFile"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"AudioFile"> | Date | string | null
  }

  export type TranscriptRunWhereInput = {
    AND?: TranscriptRunWhereInput | TranscriptRunWhereInput[]
    OR?: TranscriptRunWhereInput[]
    NOT?: TranscriptRunWhereInput | TranscriptRunWhereInput[]
    id?: StringFilter<"TranscriptRun"> | string
    audioId?: StringFilter<"TranscriptRun"> | string
    authorId?: StringNullableFilter<"TranscriptRun"> | string | null
    version?: IntFilter<"TranscriptRun"> | number
    engine?: StringFilter<"TranscriptRun"> | string
    params?: JsonNullableFilter<"TranscriptRun">
    paramsHash?: StringFilter<"TranscriptRun"> | string
    status?: StringFilter<"TranscriptRun"> | string
    error?: StringNullableFilter<"TranscriptRun"> | string | null
    text?: StringNullableFilter<"TranscriptRun"> | string | null
    segments?: JsonNullableFilter<"TranscriptRun">
    speakerCount?: IntNullableFilter<"TranscriptRun"> | number | null
    confidence?: FloatNullableFilter<"TranscriptRun"> | number | null
    createdAt?: DateTimeFilter<"TranscriptRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"TranscriptRun"> | Date | string | null
    audio?: XOR<AudioFileScalarRelationFilter, AudioFileWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    revisions?: TranscriptRevisionListRelationFilter
    annotations?: AnnotationListRelationFilter
    jobs?: JobListRelationFilter
    analyses?: AnalysisListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
  }

  export type TranscriptRunOrderByWithRelationInput = {
    id?: SortOrder
    audioId?: SortOrder
    authorId?: SortOrderInput | SortOrder
    version?: SortOrder
    engine?: SortOrder
    params?: SortOrderInput | SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    segments?: SortOrderInput | SortOrder
    speakerCount?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    audio?: AudioFileOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    revisions?: TranscriptRevisionOrderByRelationAggregateInput
    annotations?: AnnotationOrderByRelationAggregateInput
    jobs?: JobOrderByRelationAggregateInput
    analyses?: AnalysisOrderByRelationAggregateInput
    learningSessions?: LearningSessionOrderByRelationAggregateInput
  }

  export type TranscriptRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    audioId_paramsHash?: TranscriptRunAudioIdParamsHashCompoundUniqueInput
    AND?: TranscriptRunWhereInput | TranscriptRunWhereInput[]
    OR?: TranscriptRunWhereInput[]
    NOT?: TranscriptRunWhereInput | TranscriptRunWhereInput[]
    audioId?: StringFilter<"TranscriptRun"> | string
    authorId?: StringNullableFilter<"TranscriptRun"> | string | null
    version?: IntFilter<"TranscriptRun"> | number
    engine?: StringFilter<"TranscriptRun"> | string
    params?: JsonNullableFilter<"TranscriptRun">
    paramsHash?: StringFilter<"TranscriptRun"> | string
    status?: StringFilter<"TranscriptRun"> | string
    error?: StringNullableFilter<"TranscriptRun"> | string | null
    text?: StringNullableFilter<"TranscriptRun"> | string | null
    segments?: JsonNullableFilter<"TranscriptRun">
    speakerCount?: IntNullableFilter<"TranscriptRun"> | number | null
    confidence?: FloatNullableFilter<"TranscriptRun"> | number | null
    createdAt?: DateTimeFilter<"TranscriptRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"TranscriptRun"> | Date | string | null
    audio?: XOR<AudioFileScalarRelationFilter, AudioFileWhereInput>
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    revisions?: TranscriptRevisionListRelationFilter
    annotations?: AnnotationListRelationFilter
    jobs?: JobListRelationFilter
    analyses?: AnalysisListRelationFilter
    learningSessions?: LearningSessionListRelationFilter
  }, "id" | "audioId_paramsHash">

  export type TranscriptRunOrderByWithAggregationInput = {
    id?: SortOrder
    audioId?: SortOrder
    authorId?: SortOrderInput | SortOrder
    version?: SortOrder
    engine?: SortOrder
    params?: SortOrderInput | SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    segments?: SortOrderInput | SortOrder
    speakerCount?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: TranscriptRunCountOrderByAggregateInput
    _avg?: TranscriptRunAvgOrderByAggregateInput
    _max?: TranscriptRunMaxOrderByAggregateInput
    _min?: TranscriptRunMinOrderByAggregateInput
    _sum?: TranscriptRunSumOrderByAggregateInput
  }

  export type TranscriptRunScalarWhereWithAggregatesInput = {
    AND?: TranscriptRunScalarWhereWithAggregatesInput | TranscriptRunScalarWhereWithAggregatesInput[]
    OR?: TranscriptRunScalarWhereWithAggregatesInput[]
    NOT?: TranscriptRunScalarWhereWithAggregatesInput | TranscriptRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranscriptRun"> | string
    audioId?: StringWithAggregatesFilter<"TranscriptRun"> | string
    authorId?: StringNullableWithAggregatesFilter<"TranscriptRun"> | string | null
    version?: IntWithAggregatesFilter<"TranscriptRun"> | number
    engine?: StringWithAggregatesFilter<"TranscriptRun"> | string
    params?: JsonNullableWithAggregatesFilter<"TranscriptRun">
    paramsHash?: StringWithAggregatesFilter<"TranscriptRun"> | string
    status?: StringWithAggregatesFilter<"TranscriptRun"> | string
    error?: StringNullableWithAggregatesFilter<"TranscriptRun"> | string | null
    text?: StringNullableWithAggregatesFilter<"TranscriptRun"> | string | null
    segments?: JsonNullableWithAggregatesFilter<"TranscriptRun">
    speakerCount?: IntNullableWithAggregatesFilter<"TranscriptRun"> | number | null
    confidence?: FloatNullableWithAggregatesFilter<"TranscriptRun"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TranscriptRun"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TranscriptRun"> | Date | string | null
  }

  export type TranscriptRevisionWhereInput = {
    AND?: TranscriptRevisionWhereInput | TranscriptRevisionWhereInput[]
    OR?: TranscriptRevisionWhereInput[]
    NOT?: TranscriptRevisionWhereInput | TranscriptRevisionWhereInput[]
    id?: StringFilter<"TranscriptRevision"> | string
    runId?: StringFilter<"TranscriptRevision"> | string
    title?: StringNullableFilter<"TranscriptRevision"> | string | null
    text?: StringFilter<"TranscriptRevision"> | string
    segments?: JsonNullableFilter<"TranscriptRevision">
    createdBy?: StringNullableFilter<"TranscriptRevision"> | string | null
    createdAt?: DateTimeFilter<"TranscriptRevision"> | Date | string
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
  }

  export type TranscriptRevisionOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrder
    segments?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    run?: TranscriptRunOrderByWithRelationInput
  }

  export type TranscriptRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptRevisionWhereInput | TranscriptRevisionWhereInput[]
    OR?: TranscriptRevisionWhereInput[]
    NOT?: TranscriptRevisionWhereInput | TranscriptRevisionWhereInput[]
    runId?: StringFilter<"TranscriptRevision"> | string
    title?: StringNullableFilter<"TranscriptRevision"> | string | null
    text?: StringFilter<"TranscriptRevision"> | string
    segments?: JsonNullableFilter<"TranscriptRevision">
    createdBy?: StringNullableFilter<"TranscriptRevision"> | string | null
    createdAt?: DateTimeFilter<"TranscriptRevision"> | Date | string
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
  }, "id">

  export type TranscriptRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrder
    segments?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TranscriptRevisionCountOrderByAggregateInput
    _max?: TranscriptRevisionMaxOrderByAggregateInput
    _min?: TranscriptRevisionMinOrderByAggregateInput
  }

  export type TranscriptRevisionScalarWhereWithAggregatesInput = {
    AND?: TranscriptRevisionScalarWhereWithAggregatesInput | TranscriptRevisionScalarWhereWithAggregatesInput[]
    OR?: TranscriptRevisionScalarWhereWithAggregatesInput[]
    NOT?: TranscriptRevisionScalarWhereWithAggregatesInput | TranscriptRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranscriptRevision"> | string
    runId?: StringWithAggregatesFilter<"TranscriptRevision"> | string
    title?: StringNullableWithAggregatesFilter<"TranscriptRevision"> | string | null
    text?: StringWithAggregatesFilter<"TranscriptRevision"> | string
    segments?: JsonNullableWithAggregatesFilter<"TranscriptRevision">
    createdBy?: StringNullableWithAggregatesFilter<"TranscriptRevision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TranscriptRevision"> | Date | string
  }

  export type AnalysisWhereInput = {
    AND?: AnalysisWhereInput | AnalysisWhereInput[]
    OR?: AnalysisWhereInput[]
    NOT?: AnalysisWhereInput | AnalysisWhereInput[]
    id?: StringFilter<"Analysis"> | string
    runId?: StringFilter<"Analysis"> | string
    segmentIndex?: IntNullableFilter<"Analysis"> | number | null
    kind?: StringFilter<"Analysis"> | string
    engine?: StringFilter<"Analysis"> | string
    params?: JsonNullableFilter<"Analysis">
    paramsHash?: StringFilter<"Analysis"> | string
    status?: StringFilter<"Analysis"> | string
    summary?: StringNullableFilter<"Analysis"> | string | null
    score?: FloatNullableFilter<"Analysis"> | number | null
    result?: JsonNullableFilter<"Analysis">
    error?: StringNullableFilter<"Analysis"> | string | null
    createdAt?: DateTimeFilter<"Analysis"> | Date | string
    updatedAt?: DateTimeFilter<"Analysis"> | Date | string
    completedAt?: DateTimeNullableFilter<"Analysis"> | Date | string | null
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
  }

  export type AnalysisOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    segmentIndex?: SortOrderInput | SortOrder
    kind?: SortOrder
    engine?: SortOrder
    params?: SortOrderInput | SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    run?: TranscriptRunOrderByWithRelationInput
  }

  export type AnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    runId_segmentIndex_kind_engine_paramsHash?: AnalysisRunIdSegmentIndexKindEngineParamsHashCompoundUniqueInput
    AND?: AnalysisWhereInput | AnalysisWhereInput[]
    OR?: AnalysisWhereInput[]
    NOT?: AnalysisWhereInput | AnalysisWhereInput[]
    runId?: StringFilter<"Analysis"> | string
    segmentIndex?: IntNullableFilter<"Analysis"> | number | null
    kind?: StringFilter<"Analysis"> | string
    engine?: StringFilter<"Analysis"> | string
    params?: JsonNullableFilter<"Analysis">
    paramsHash?: StringFilter<"Analysis"> | string
    status?: StringFilter<"Analysis"> | string
    summary?: StringNullableFilter<"Analysis"> | string | null
    score?: FloatNullableFilter<"Analysis"> | number | null
    result?: JsonNullableFilter<"Analysis">
    error?: StringNullableFilter<"Analysis"> | string | null
    createdAt?: DateTimeFilter<"Analysis"> | Date | string
    updatedAt?: DateTimeFilter<"Analysis"> | Date | string
    completedAt?: DateTimeNullableFilter<"Analysis"> | Date | string | null
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
  }, "id" | "runId_segmentIndex_kind_engine_paramsHash">

  export type AnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    segmentIndex?: SortOrderInput | SortOrder
    kind?: SortOrder
    engine?: SortOrder
    params?: SortOrderInput | SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AnalysisCountOrderByAggregateInput
    _avg?: AnalysisAvgOrderByAggregateInput
    _max?: AnalysisMaxOrderByAggregateInput
    _min?: AnalysisMinOrderByAggregateInput
    _sum?: AnalysisSumOrderByAggregateInput
  }

  export type AnalysisScalarWhereWithAggregatesInput = {
    AND?: AnalysisScalarWhereWithAggregatesInput | AnalysisScalarWhereWithAggregatesInput[]
    OR?: AnalysisScalarWhereWithAggregatesInput[]
    NOT?: AnalysisScalarWhereWithAggregatesInput | AnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analysis"> | string
    runId?: StringWithAggregatesFilter<"Analysis"> | string
    segmentIndex?: IntNullableWithAggregatesFilter<"Analysis"> | number | null
    kind?: StringWithAggregatesFilter<"Analysis"> | string
    engine?: StringWithAggregatesFilter<"Analysis"> | string
    params?: JsonNullableWithAggregatesFilter<"Analysis">
    paramsHash?: StringWithAggregatesFilter<"Analysis"> | string
    status?: StringWithAggregatesFilter<"Analysis"> | string
    summary?: StringNullableWithAggregatesFilter<"Analysis"> | string | null
    score?: FloatNullableWithAggregatesFilter<"Analysis"> | number | null
    result?: JsonNullableWithAggregatesFilter<"Analysis">
    error?: StringNullableWithAggregatesFilter<"Analysis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Analysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Analysis"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Analysis"> | Date | string | null
  }

  export type AnnotationWhereInput = {
    AND?: AnnotationWhereInput | AnnotationWhereInput[]
    OR?: AnnotationWhereInput[]
    NOT?: AnnotationWhereInput | AnnotationWhereInput[]
    id?: StringFilter<"Annotation"> | string
    runId?: StringFilter<"Annotation"> | string
    userId?: StringFilter<"Annotation"> | string
    content?: StringFilter<"Annotation"> | string
    anchorType?: StringFilter<"Annotation"> | string
    anchorValue?: StringFilter<"Annotation"> | string
    createdAt?: DateTimeFilter<"Annotation"> | Date | string
    isDeleted?: BoolFilter<"Annotation"> | boolean
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnnotationOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    anchorType?: SortOrder
    anchorValue?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    run?: TranscriptRunOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AnnotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnotationWhereInput | AnnotationWhereInput[]
    OR?: AnnotationWhereInput[]
    NOT?: AnnotationWhereInput | AnnotationWhereInput[]
    runId?: StringFilter<"Annotation"> | string
    userId?: StringFilter<"Annotation"> | string
    content?: StringFilter<"Annotation"> | string
    anchorType?: StringFilter<"Annotation"> | string
    anchorValue?: StringFilter<"Annotation"> | string
    createdAt?: DateTimeFilter<"Annotation"> | Date | string
    isDeleted?: BoolFilter<"Annotation"> | boolean
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnnotationOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    anchorType?: SortOrder
    anchorValue?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
    _count?: AnnotationCountOrderByAggregateInput
    _max?: AnnotationMaxOrderByAggregateInput
    _min?: AnnotationMinOrderByAggregateInput
  }

  export type AnnotationScalarWhereWithAggregatesInput = {
    AND?: AnnotationScalarWhereWithAggregatesInput | AnnotationScalarWhereWithAggregatesInput[]
    OR?: AnnotationScalarWhereWithAggregatesInput[]
    NOT?: AnnotationScalarWhereWithAggregatesInput | AnnotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Annotation"> | string
    runId?: StringWithAggregatesFilter<"Annotation"> | string
    userId?: StringWithAggregatesFilter<"Annotation"> | string
    content?: StringWithAggregatesFilter<"Annotation"> | string
    anchorType?: StringWithAggregatesFilter<"Annotation"> | string
    anchorValue?: StringWithAggregatesFilter<"Annotation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Annotation"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Annotation"> | boolean
  }

  export type AudioTagWhereInput = {
    AND?: AudioTagWhereInput | AudioTagWhereInput[]
    OR?: AudioTagWhereInput[]
    NOT?: AudioTagWhereInput | AudioTagWhereInput[]
    id?: StringFilter<"AudioTag"> | string
    audioId?: StringFilter<"AudioTag"> | string
    key?: StringFilter<"AudioTag"> | string
    createdAt?: DateTimeFilter<"AudioTag"> | Date | string
    audio?: XOR<AudioFileScalarRelationFilter, AudioFileWhereInput>
  }

  export type AudioTagOrderByWithRelationInput = {
    id?: SortOrder
    audioId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    audio?: AudioFileOrderByWithRelationInput
  }

  export type AudioTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    audioId_key?: AudioTagAudioIdKeyCompoundUniqueInput
    AND?: AudioTagWhereInput | AudioTagWhereInput[]
    OR?: AudioTagWhereInput[]
    NOT?: AudioTagWhereInput | AudioTagWhereInput[]
    audioId?: StringFilter<"AudioTag"> | string
    key?: StringFilter<"AudioTag"> | string
    createdAt?: DateTimeFilter<"AudioTag"> | Date | string
    audio?: XOR<AudioFileScalarRelationFilter, AudioFileWhereInput>
  }, "id" | "audioId_key">

  export type AudioTagOrderByWithAggregationInput = {
    id?: SortOrder
    audioId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    _count?: AudioTagCountOrderByAggregateInput
    _max?: AudioTagMaxOrderByAggregateInput
    _min?: AudioTagMinOrderByAggregateInput
  }

  export type AudioTagScalarWhereWithAggregatesInput = {
    AND?: AudioTagScalarWhereWithAggregatesInput | AudioTagScalarWhereWithAggregatesInput[]
    OR?: AudioTagScalarWhereWithAggregatesInput[]
    NOT?: AudioTagScalarWhereWithAggregatesInput | AudioTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioTag"> | string
    audioId?: StringWithAggregatesFilter<"AudioTag"> | string
    key?: StringWithAggregatesFilter<"AudioTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AudioTag"> | Date | string
  }

  export type UsageLogWhereInput = {
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringFilter<"UsageLog"> | string
    day?: DateTimeFilter<"UsageLog"> | Date | string
    uploadCount?: IntFilter<"UsageLog"> | number
    durationMs?: IntFilter<"UsageLog"> | number
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UsageLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    uploadCount?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_day?: UsageLogUserIdDayCompoundUniqueInput
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    userId?: StringFilter<"UsageLog"> | string
    day?: DateTimeFilter<"UsageLog"> | Date | string
    uploadCount?: IntFilter<"UsageLog"> | number
    durationMs?: IntFilter<"UsageLog"> | number
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_day">

  export type UsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    uploadCount?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    _count?: UsageLogCountOrderByAggregateInput
    _avg?: UsageLogAvgOrderByAggregateInput
    _max?: UsageLogMaxOrderByAggregateInput
    _min?: UsageLogMinOrderByAggregateInput
    _sum?: UsageLogSumOrderByAggregateInput
  }

  export type UsageLogScalarWhereWithAggregatesInput = {
    AND?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    OR?: UsageLogScalarWhereWithAggregatesInput[]
    NOT?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageLog"> | string
    userId?: StringWithAggregatesFilter<"UsageLog"> | string
    day?: DateTimeWithAggregatesFilter<"UsageLog"> | Date | string
    uploadCount?: IntWithAggregatesFilter<"UsageLog"> | number
    durationMs?: IntWithAggregatesFilter<"UsageLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UsageLog"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    audioId?: StringNullableFilter<"Job"> | string | null
    runId?: StringFilter<"Job"> | string
    jobType?: StringFilter<"Job"> | string
    providerJobId?: StringNullableFilter<"Job"> | string | null
    status?: StringFilter<"Job"> | string
    retryCount?: IntFilter<"Job"> | number
    nextRetryAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    errorMessage?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    audio?: XOR<AudioFileNullableScalarRelationFilter, AudioFileWhereInput> | null
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    audioId?: SortOrderInput | SortOrder
    runId?: SortOrder
    jobType?: SortOrder
    providerJobId?: SortOrderInput | SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audio?: AudioFileOrderByWithRelationInput
    run?: TranscriptRunOrderByWithRelationInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    audioId?: StringNullableFilter<"Job"> | string | null
    runId?: StringFilter<"Job"> | string
    jobType?: StringFilter<"Job"> | string
    providerJobId?: StringNullableFilter<"Job"> | string | null
    status?: StringFilter<"Job"> | string
    retryCount?: IntFilter<"Job"> | number
    nextRetryAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    errorMessage?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    audio?: XOR<AudioFileNullableScalarRelationFilter, AudioFileWhereInput> | null
    run?: XOR<TranscriptRunScalarRelationFilter, TranscriptRunWhereInput>
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    audioId?: SortOrderInput | SortOrder
    runId?: SortOrder
    jobType?: SortOrder
    providerJobId?: SortOrderInput | SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    audioId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    runId?: StringWithAggregatesFilter<"Job"> | string
    jobType?: StringWithAggregatesFilter<"Job"> | string
    providerJobId?: StringNullableWithAggregatesFilter<"Job"> | string | null
    status?: StringWithAggregatesFilter<"Job"> | string
    retryCount?: IntWithAggregatesFilter<"Job"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Job"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    kind?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    meta?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    kind?: SortOrder
    targetId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    kind?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    meta?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    kind?: SortOrder
    targetId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    kind?: StringWithAggregatesFilter<"AuditLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    planType?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    expiresAt?: DateTimeFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    planType?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    expiresAt?: DateTimeFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    planType?: StringWithAggregatesFilter<"Subscription"> | string
    startedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type SharedBbcResourceWhereInput = {
    AND?: SharedBbcResourceWhereInput | SharedBbcResourceWhereInput[]
    OR?: SharedBbcResourceWhereInput[]
    NOT?: SharedBbcResourceWhereInput | SharedBbcResourceWhereInput[]
    id?: StringFilter<"SharedBbcResource"> | string
    title?: StringFilter<"SharedBbcResource"> | string
    description?: StringNullableFilter<"SharedBbcResource"> | string | null
    externalUrl?: StringNullableFilter<"SharedBbcResource"> | string | null
    durationMs?: IntNullableFilter<"SharedBbcResource"> | number | null
    transcript?: StringNullableFilter<"SharedBbcResource"> | string | null
    segments?: JsonNullableFilter<"SharedBbcResource">
    uploadedById?: StringFilter<"SharedBbcResource"> | string
    isPublished?: BoolFilter<"SharedBbcResource"> | boolean
    publishDate?: DateTimeNullableFilter<"SharedBbcResource"> | Date | string | null
    episodeNumber?: IntNullableFilter<"SharedBbcResource"> | number | null
    seasonNumber?: IntNullableFilter<"SharedBbcResource"> | number | null
    bbcUrl?: StringNullableFilter<"SharedBbcResource"> | string | null
    createdAt?: DateTimeFilter<"SharedBbcResource"> | Date | string
    updatedAt?: DateTimeFilter<"SharedBbcResource"> | Date | string
    sourceType?: StringFilter<"SharedBbcResource"> | string
    licenseInfo?: StringNullableFilter<"SharedBbcResource"> | string | null
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    takedownRequests?: TakedownRequestListRelationFilter
  }

  export type SharedBbcResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    segments?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    isPublished?: SortOrder
    publishDate?: SortOrderInput | SortOrder
    episodeNumber?: SortOrderInput | SortOrder
    seasonNumber?: SortOrderInput | SortOrder
    bbcUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceType?: SortOrder
    licenseInfo?: SortOrderInput | SortOrder
    uploadedBy?: UserOrderByWithRelationInput
    takedownRequests?: TakedownRequestOrderByRelationAggregateInput
  }

  export type SharedBbcResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharedBbcResourceWhereInput | SharedBbcResourceWhereInput[]
    OR?: SharedBbcResourceWhereInput[]
    NOT?: SharedBbcResourceWhereInput | SharedBbcResourceWhereInput[]
    title?: StringFilter<"SharedBbcResource"> | string
    description?: StringNullableFilter<"SharedBbcResource"> | string | null
    externalUrl?: StringNullableFilter<"SharedBbcResource"> | string | null
    durationMs?: IntNullableFilter<"SharedBbcResource"> | number | null
    transcript?: StringNullableFilter<"SharedBbcResource"> | string | null
    segments?: JsonNullableFilter<"SharedBbcResource">
    uploadedById?: StringFilter<"SharedBbcResource"> | string
    isPublished?: BoolFilter<"SharedBbcResource"> | boolean
    publishDate?: DateTimeNullableFilter<"SharedBbcResource"> | Date | string | null
    episodeNumber?: IntNullableFilter<"SharedBbcResource"> | number | null
    seasonNumber?: IntNullableFilter<"SharedBbcResource"> | number | null
    bbcUrl?: StringNullableFilter<"SharedBbcResource"> | string | null
    createdAt?: DateTimeFilter<"SharedBbcResource"> | Date | string
    updatedAt?: DateTimeFilter<"SharedBbcResource"> | Date | string
    sourceType?: StringFilter<"SharedBbcResource"> | string
    licenseInfo?: StringNullableFilter<"SharedBbcResource"> | string | null
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    takedownRequests?: TakedownRequestListRelationFilter
  }, "id">

  export type SharedBbcResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    externalUrl?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    segments?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    isPublished?: SortOrder
    publishDate?: SortOrderInput | SortOrder
    episodeNumber?: SortOrderInput | SortOrder
    seasonNumber?: SortOrderInput | SortOrder
    bbcUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceType?: SortOrder
    licenseInfo?: SortOrderInput | SortOrder
    _count?: SharedBbcResourceCountOrderByAggregateInput
    _avg?: SharedBbcResourceAvgOrderByAggregateInput
    _max?: SharedBbcResourceMaxOrderByAggregateInput
    _min?: SharedBbcResourceMinOrderByAggregateInput
    _sum?: SharedBbcResourceSumOrderByAggregateInput
  }

  export type SharedBbcResourceScalarWhereWithAggregatesInput = {
    AND?: SharedBbcResourceScalarWhereWithAggregatesInput | SharedBbcResourceScalarWhereWithAggregatesInput[]
    OR?: SharedBbcResourceScalarWhereWithAggregatesInput[]
    NOT?: SharedBbcResourceScalarWhereWithAggregatesInput | SharedBbcResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedBbcResource"> | string
    title?: StringWithAggregatesFilter<"SharedBbcResource"> | string
    description?: StringNullableWithAggregatesFilter<"SharedBbcResource"> | string | null
    externalUrl?: StringNullableWithAggregatesFilter<"SharedBbcResource"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"SharedBbcResource"> | number | null
    transcript?: StringNullableWithAggregatesFilter<"SharedBbcResource"> | string | null
    segments?: JsonNullableWithAggregatesFilter<"SharedBbcResource">
    uploadedById?: StringWithAggregatesFilter<"SharedBbcResource"> | string
    isPublished?: BoolWithAggregatesFilter<"SharedBbcResource"> | boolean
    publishDate?: DateTimeNullableWithAggregatesFilter<"SharedBbcResource"> | Date | string | null
    episodeNumber?: IntNullableWithAggregatesFilter<"SharedBbcResource"> | number | null
    seasonNumber?: IntNullableWithAggregatesFilter<"SharedBbcResource"> | number | null
    bbcUrl?: StringNullableWithAggregatesFilter<"SharedBbcResource"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SharedBbcResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SharedBbcResource"> | Date | string
    sourceType?: StringWithAggregatesFilter<"SharedBbcResource"> | string
    licenseInfo?: StringNullableWithAggregatesFilter<"SharedBbcResource"> | string | null
  }

  export type LearningSessionWhereInput = {
    AND?: LearningSessionWhereInput | LearningSessionWhereInput[]
    OR?: LearningSessionWhereInput[]
    NOT?: LearningSessionWhereInput | LearningSessionWhereInput[]
    id?: StringFilter<"LearningSession"> | string
    userId?: StringFilter<"LearningSession"> | string
    audioId?: StringFilter<"LearningSession"> | string
    transcriptRunId?: StringNullableFilter<"LearningSession"> | string | null
    completedSegments?: IntFilter<"LearningSession"> | number
    totalSegments?: IntFilter<"LearningSession"> | number
    listeningTimeMs?: IntFilter<"LearningSession"> | number
    practiceTimeMs?: IntFilter<"LearningSession"> | number
    loopCount?: IntFilter<"LearningSession"> | number
    recordingCount?: IntFilter<"LearningSession"> | number
    score?: FloatNullableFilter<"LearningSession"> | number | null
    completedAt?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    createdAt?: DateTimeFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeFilter<"LearningSession"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    audioFile?: XOR<AudioFileScalarRelationFilter, AudioFileWhereInput>
    transcriptRun?: XOR<TranscriptRunNullableScalarRelationFilter, TranscriptRunWhereInput> | null
  }

  export type LearningSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    audioId?: SortOrder
    transcriptRunId?: SortOrderInput | SortOrder
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    audioFile?: AudioFileOrderByWithRelationInput
    transcriptRun?: TranscriptRunOrderByWithRelationInput
  }

  export type LearningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningSessionWhereInput | LearningSessionWhereInput[]
    OR?: LearningSessionWhereInput[]
    NOT?: LearningSessionWhereInput | LearningSessionWhereInput[]
    userId?: StringFilter<"LearningSession"> | string
    audioId?: StringFilter<"LearningSession"> | string
    transcriptRunId?: StringNullableFilter<"LearningSession"> | string | null
    completedSegments?: IntFilter<"LearningSession"> | number
    totalSegments?: IntFilter<"LearningSession"> | number
    listeningTimeMs?: IntFilter<"LearningSession"> | number
    practiceTimeMs?: IntFilter<"LearningSession"> | number
    loopCount?: IntFilter<"LearningSession"> | number
    recordingCount?: IntFilter<"LearningSession"> | number
    score?: FloatNullableFilter<"LearningSession"> | number | null
    completedAt?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    createdAt?: DateTimeFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeFilter<"LearningSession"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    audioFile?: XOR<AudioFileScalarRelationFilter, AudioFileWhereInput>
    transcriptRun?: XOR<TranscriptRunNullableScalarRelationFilter, TranscriptRunWhereInput> | null
  }, "id">

  export type LearningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    audioId?: SortOrder
    transcriptRunId?: SortOrderInput | SortOrder
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LearningSessionCountOrderByAggregateInput
    _avg?: LearningSessionAvgOrderByAggregateInput
    _max?: LearningSessionMaxOrderByAggregateInput
    _min?: LearningSessionMinOrderByAggregateInput
    _sum?: LearningSessionSumOrderByAggregateInput
  }

  export type LearningSessionScalarWhereWithAggregatesInput = {
    AND?: LearningSessionScalarWhereWithAggregatesInput | LearningSessionScalarWhereWithAggregatesInput[]
    OR?: LearningSessionScalarWhereWithAggregatesInput[]
    NOT?: LearningSessionScalarWhereWithAggregatesInput | LearningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningSession"> | string
    userId?: StringWithAggregatesFilter<"LearningSession"> | string
    audioId?: StringWithAggregatesFilter<"LearningSession"> | string
    transcriptRunId?: StringNullableWithAggregatesFilter<"LearningSession"> | string | null
    completedSegments?: IntWithAggregatesFilter<"LearningSession"> | number
    totalSegments?: IntWithAggregatesFilter<"LearningSession"> | number
    listeningTimeMs?: IntWithAggregatesFilter<"LearningSession"> | number
    practiceTimeMs?: IntWithAggregatesFilter<"LearningSession"> | number
    loopCount?: IntWithAggregatesFilter<"LearningSession"> | number
    recordingCount?: IntWithAggregatesFilter<"LearningSession"> | number
    score?: FloatNullableWithAggregatesFilter<"LearningSession"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"LearningSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LearningSession"> | Date | string | null
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    tokenHash?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type TakedownRequestWhereInput = {
    AND?: TakedownRequestWhereInput | TakedownRequestWhereInput[]
    OR?: TakedownRequestWhereInput[]
    NOT?: TakedownRequestWhereInput | TakedownRequestWhereInput[]
    id?: StringFilter<"TakedownRequest"> | string
    resourceId?: StringFilter<"TakedownRequest"> | string
    reason?: StringFilter<"TakedownRequest"> | string
    contactInfo?: StringFilter<"TakedownRequest"> | string
    additionalInfo?: StringNullableFilter<"TakedownRequest"> | string | null
    requestType?: StringFilter<"TakedownRequest"> | string
    status?: StringFilter<"TakedownRequest"> | string
    adminNotes?: StringNullableFilter<"TakedownRequest"> | string | null
    resolvedAt?: DateTimeNullableFilter<"TakedownRequest"> | Date | string | null
    resolvedBy?: StringNullableFilter<"TakedownRequest"> | string | null
    createdAt?: DateTimeFilter<"TakedownRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TakedownRequest"> | Date | string
    resource?: XOR<SharedBbcResourceScalarRelationFilter, SharedBbcResourceWhereInput>
  }

  export type TakedownRequestOrderByWithRelationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    reason?: SortOrder
    contactInfo?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    requestType?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resource?: SharedBbcResourceOrderByWithRelationInput
  }

  export type TakedownRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TakedownRequestWhereInput | TakedownRequestWhereInput[]
    OR?: TakedownRequestWhereInput[]
    NOT?: TakedownRequestWhereInput | TakedownRequestWhereInput[]
    resourceId?: StringFilter<"TakedownRequest"> | string
    reason?: StringFilter<"TakedownRequest"> | string
    contactInfo?: StringFilter<"TakedownRequest"> | string
    additionalInfo?: StringNullableFilter<"TakedownRequest"> | string | null
    requestType?: StringFilter<"TakedownRequest"> | string
    status?: StringFilter<"TakedownRequest"> | string
    adminNotes?: StringNullableFilter<"TakedownRequest"> | string | null
    resolvedAt?: DateTimeNullableFilter<"TakedownRequest"> | Date | string | null
    resolvedBy?: StringNullableFilter<"TakedownRequest"> | string | null
    createdAt?: DateTimeFilter<"TakedownRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TakedownRequest"> | Date | string
    resource?: XOR<SharedBbcResourceScalarRelationFilter, SharedBbcResourceWhereInput>
  }, "id">

  export type TakedownRequestOrderByWithAggregationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    reason?: SortOrder
    contactInfo?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    requestType?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TakedownRequestCountOrderByAggregateInput
    _max?: TakedownRequestMaxOrderByAggregateInput
    _min?: TakedownRequestMinOrderByAggregateInput
  }

  export type TakedownRequestScalarWhereWithAggregatesInput = {
    AND?: TakedownRequestScalarWhereWithAggregatesInput | TakedownRequestScalarWhereWithAggregatesInput[]
    OR?: TakedownRequestScalarWhereWithAggregatesInput[]
    NOT?: TakedownRequestScalarWhereWithAggregatesInput | TakedownRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TakedownRequest"> | string
    resourceId?: StringWithAggregatesFilter<"TakedownRequest"> | string
    reason?: StringWithAggregatesFilter<"TakedownRequest"> | string
    contactInfo?: StringWithAggregatesFilter<"TakedownRequest"> | string
    additionalInfo?: StringNullableWithAggregatesFilter<"TakedownRequest"> | string | null
    requestType?: StringWithAggregatesFilter<"TakedownRequest"> | string
    status?: StringWithAggregatesFilter<"TakedownRequest"> | string
    adminNotes?: StringNullableWithAggregatesFilter<"TakedownRequest"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"TakedownRequest"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"TakedownRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TakedownRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TakedownRequest"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuthSessionsInput
  }

  export type AuthSessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuthSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthSessionsNestedInput
  }

  export type AuthSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateManyInput = {
    id?: string
    userId: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuthSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioFileCreateInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioFilesInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAudioInput
    tags?: AudioTagCreateNestedManyWithoutAudioInput
    Job?: JobCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileUncheckedCreateInput = {
    id?: string
    userId: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAudioInput
    tags?: AudioTagUncheckedCreateNestedManyWithoutAudioInput
    Job?: JobUncheckedCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioFilesNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUpdateManyWithoutAudioNestedInput
    Job?: JobUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUncheckedUpdateManyWithoutAudioNestedInput
    Job?: JobUncheckedUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileCreateManyInput = {
    id?: string
    userId: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AudioFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptRunCreateInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunCreateManyInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TranscriptRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptRevisionCreateInput = {
    id?: string
    title?: string | null
    text: string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
    run: TranscriptRunCreateNestedOneWithoutRevisionsInput
  }

  export type TranscriptRevisionUncheckedCreateInput = {
    id?: string
    runId: string
    title?: string | null
    text: string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TranscriptRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: TranscriptRunUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type TranscriptRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptRevisionCreateManyInput = {
    id?: string
    runId: string
    title?: string | null
    text: string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TranscriptRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisCreateInput = {
    id?: string
    segmentIndex?: number | null
    kind: string
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    summary?: string | null
    score?: number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    run: TranscriptRunCreateNestedOneWithoutAnalysesInput
  }

  export type AnalysisUncheckedCreateInput = {
    id?: string
    runId: string
    segmentIndex?: number | null
    kind: string
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    summary?: string | null
    score?: number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    run?: TranscriptRunUpdateOneRequiredWithoutAnalysesNestedInput
  }

  export type AnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnalysisCreateManyInput = {
    id?: string
    runId: string
    segmentIndex?: number | null
    kind: string
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    summary?: string | null
    score?: number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnotationCreateInput = {
    id?: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
    run: TranscriptRunCreateNestedOneWithoutAnnotationsInput
    user: UserCreateNestedOneWithoutAnnotationsInput
  }

  export type AnnotationUncheckedCreateInput = {
    id?: string
    runId: string
    userId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type AnnotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    run?: TranscriptRunUpdateOneRequiredWithoutAnnotationsNestedInput
    user?: UserUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type AnnotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationCreateManyInput = {
    id?: string
    runId: string
    userId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type AnnotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AudioTagCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    audio: AudioFileCreateNestedOneWithoutTagsInput
  }

  export type AudioTagUncheckedCreateInput = {
    id?: string
    audioId: string
    key: string
    createdAt?: Date | string
  }

  export type AudioTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audio?: AudioFileUpdateOneRequiredWithoutTagsNestedInput
  }

  export type AudioTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTagCreateManyInput = {
    id?: string
    audioId: string
    key: string
    createdAt?: Date | string
  }

  export type AudioTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateInput = {
    id?: string
    day: Date | string
    uploadCount?: number
    durationMs?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUsageLogsInput
  }

  export type UsageLogUncheckedCreateInput = {
    id?: string
    userId: string
    day: Date | string
    uploadCount?: number
    durationMs?: number
    createdAt?: Date | string
  }

  export type UsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type UsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateManyInput = {
    id?: string
    userId: string
    day: Date | string
    uploadCount?: number
    durationMs?: number
    createdAt?: Date | string
  }

  export type UsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    id?: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audio?: AudioFileCreateNestedOneWithoutJobInput
    run: TranscriptRunCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    audioId?: string | null
    runId: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audio?: AudioFileUpdateOneWithoutJobNestedInput
    run?: TranscriptRunUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: NullableStringFieldUpdateOperationsInput | string | null
    runId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyInput = {
    id?: string
    audioId?: string | null
    runId: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: NullableStringFieldUpdateOperationsInput | string | null
    runId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    kind: string
    targetId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    kind: string
    targetId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    kind: string
    targetId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    planType?: string
    startedAt?: Date | string
    expiresAt: Date | string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.SubscriptionStatus
    planType?: string
    startedAt?: Date | string
    expiresAt: Date | string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planType?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planType?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.SubscriptionStatus
    planType?: string
    startedAt?: Date | string
    expiresAt: Date | string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planType?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planType?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedBbcResourceCreateInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
    uploadedBy: UserCreateNestedOneWithoutSharedBbcResourcesInput
    takedownRequests?: TakedownRequestCreateNestedManyWithoutResourceInput
  }

  export type SharedBbcResourceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
    takedownRequests?: TakedownRequestUncheckedCreateNestedManyWithoutResourceInput
  }

  export type SharedBbcResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: UserUpdateOneRequiredWithoutSharedBbcResourcesNestedInput
    takedownRequests?: TakedownRequestUpdateManyWithoutResourceNestedInput
  }

  export type SharedBbcResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
    takedownRequests?: TakedownRequestUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type SharedBbcResourceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
  }

  export type SharedBbcResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharedBbcResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningSessionCreateInput = {
    id?: string
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningSessionsInput
    audioFile: AudioFileCreateNestedOneWithoutLearningSessionsInput
    transcriptRun?: TranscriptRunCreateNestedOneWithoutLearningSessionsInput
  }

  export type LearningSessionUncheckedCreateInput = {
    id?: string
    userId: string
    audioId: string
    transcriptRunId?: string | null
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningSessionsNestedInput
    audioFile?: AudioFileUpdateOneRequiredWithoutLearningSessionsNestedInput
    transcriptRun?: TranscriptRunUpdateOneWithoutLearningSessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    transcriptRunId?: NullableStringFieldUpdateOperationsInput | string | null
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionCreateManyInput = {
    id?: string
    userId: string
    audioId: string
    transcriptRunId?: string | null
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    transcriptRunId?: NullableStringFieldUpdateOperationsInput | string | null
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakedownRequestCreateInput = {
    id?: string
    reason: string
    contactInfo: string
    additionalInfo?: string | null
    requestType?: string
    status?: string
    adminNotes?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resource: SharedBbcResourceCreateNestedOneWithoutTakedownRequestsInput
  }

  export type TakedownRequestUncheckedCreateInput = {
    id?: string
    resourceId: string
    reason: string
    contactInfo: string
    additionalInfo?: string | null
    requestType?: string
    status?: string
    adminNotes?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakedownRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: SharedBbcResourceUpdateOneRequiredWithoutTakedownRequestsNestedInput
  }

  export type TakedownRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakedownRequestCreateManyInput = {
    id?: string
    resourceId: string
    reason: string
    contactInfo: string
    additionalInfo?: string | null
    requestType?: string
    status?: string
    adminNotes?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakedownRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakedownRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type AudioFileListRelationFilter = {
    every?: AudioFileWhereInput
    some?: AudioFileWhereInput
    none?: AudioFileWhereInput
  }

  export type TranscriptRunListRelationFilter = {
    every?: TranscriptRunWhereInput
    some?: TranscriptRunWhereInput
    none?: TranscriptRunWhereInput
  }

  export type AnnotationListRelationFilter = {
    every?: AnnotationWhereInput
    some?: AnnotationWhereInput
    none?: AnnotationWhereInput
  }

  export type UsageLogListRelationFilter = {
    every?: UsageLogWhereInput
    some?: UsageLogWhereInput
    none?: UsageLogWhereInput
  }

  export type AuthSessionListRelationFilter = {
    every?: AuthSessionWhereInput
    some?: AuthSessionWhereInput
    none?: AuthSessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SharedBbcResourceListRelationFilter = {
    every?: SharedBbcResourceWhereInput
    some?: SharedBbcResourceWhereInput
    none?: SharedBbcResourceWhereInput
  }

  export type LearningSessionListRelationFilter = {
    every?: LearningSessionWhereInput
    some?: LearningSessionWhereInput
    none?: LearningSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AudioFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedBbcResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    emailVerified?: SortOrder
    settings?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuthSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AuthSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AuthSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AudioTagListRelationFilter = {
    every?: AudioTagWhereInput
    some?: AudioTagWhereInput
    none?: AudioTagWhereInput
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type AudioTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioFileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gcsUri?: SortOrder
    filename?: SortOrder
    durationMs?: SortOrder
    sizeBytes?: SortOrder
    language?: SortOrder
    mode?: SortOrder
    gapSec?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AudioFileAvgOrderByAggregateInput = {
    durationMs?: SortOrder
    sizeBytes?: SortOrder
    gapSec?: SortOrder
  }

  export type AudioFileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gcsUri?: SortOrder
    filename?: SortOrder
    durationMs?: SortOrder
    sizeBytes?: SortOrder
    language?: SortOrder
    mode?: SortOrder
    gapSec?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AudioFileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gcsUri?: SortOrder
    filename?: SortOrder
    durationMs?: SortOrder
    sizeBytes?: SortOrder
    language?: SortOrder
    mode?: SortOrder
    gapSec?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AudioFileSumOrderByAggregateInput = {
    durationMs?: SortOrder
    sizeBytes?: SortOrder
    gapSec?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AudioFileScalarRelationFilter = {
    is?: AudioFileWhereInput
    isNot?: AudioFileWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TranscriptRevisionListRelationFilter = {
    every?: TranscriptRevisionWhereInput
    some?: TranscriptRevisionWhereInput
    none?: TranscriptRevisionWhereInput
  }

  export type AnalysisListRelationFilter = {
    every?: AnalysisWhereInput
    some?: AnalysisWhereInput
    none?: AnalysisWhereInput
  }

  export type TranscriptRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptRunAudioIdParamsHashCompoundUniqueInput = {
    audioId: string
    paramsHash: string
  }

  export type TranscriptRunCountOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    authorId?: SortOrder
    version?: SortOrder
    engine?: SortOrder
    params?: SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    error?: SortOrder
    text?: SortOrder
    segments?: SortOrder
    speakerCount?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TranscriptRunAvgOrderByAggregateInput = {
    version?: SortOrder
    speakerCount?: SortOrder
    confidence?: SortOrder
  }

  export type TranscriptRunMaxOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    authorId?: SortOrder
    version?: SortOrder
    engine?: SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    error?: SortOrder
    text?: SortOrder
    speakerCount?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TranscriptRunMinOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    authorId?: SortOrder
    version?: SortOrder
    engine?: SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    error?: SortOrder
    text?: SortOrder
    speakerCount?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TranscriptRunSumOrderByAggregateInput = {
    version?: SortOrder
    speakerCount?: SortOrder
    confidence?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TranscriptRunScalarRelationFilter = {
    is?: TranscriptRunWhereInput
    isNot?: TranscriptRunWhereInput
  }

  export type TranscriptRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    segments?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TranscriptRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalysisRunIdSegmentIndexKindEngineParamsHashCompoundUniqueInput = {
    runId: string
    segmentIndex: number
    kind: string
    engine: string
    paramsHash: string
  }

  export type AnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    segmentIndex?: SortOrder
    kind?: SortOrder
    engine?: SortOrder
    params?: SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    score?: SortOrder
    result?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AnalysisAvgOrderByAggregateInput = {
    segmentIndex?: SortOrder
    score?: SortOrder
  }

  export type AnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    segmentIndex?: SortOrder
    kind?: SortOrder
    engine?: SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    score?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    segmentIndex?: SortOrder
    kind?: SortOrder
    engine?: SortOrder
    paramsHash?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    score?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AnalysisSumOrderByAggregateInput = {
    segmentIndex?: SortOrder
    score?: SortOrder
  }

  export type AnnotationCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    anchorType?: SortOrder
    anchorValue?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    anchorType?: SortOrder
    anchorValue?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AnnotationMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    anchorType?: SortOrder
    anchorValue?: SortOrder
    createdAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type AudioTagAudioIdKeyCompoundUniqueInput = {
    audioId: string
    key: string
  }

  export type AudioTagCountOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioTagMaxOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type AudioTagMinOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogUserIdDayCompoundUniqueInput = {
    userId: string
    day: Date | string
  }

  export type UsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    uploadCount?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogAvgOrderByAggregateInput = {
    uploadCount?: SortOrder
    durationMs?: SortOrder
  }

  export type UsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    uploadCount?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    day?: SortOrder
    uploadCount?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogSumOrderByAggregateInput = {
    uploadCount?: SortOrder
    durationMs?: SortOrder
  }

  export type AudioFileNullableScalarRelationFilter = {
    is?: AudioFileWhereInput | null
    isNot?: AudioFileWhereInput | null
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    runId?: SortOrder
    jobType?: SortOrder
    providerJobId?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    runId?: SortOrder
    jobType?: SortOrder
    providerJobId?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    audioId?: SortOrder
    runId?: SortOrder
    jobType?: SortOrder
    providerJobId?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    nextRetryAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    targetId?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type TakedownRequestListRelationFilter = {
    every?: TakedownRequestWhereInput
    some?: TakedownRequestWhereInput
    none?: TakedownRequestWhereInput
  }

  export type TakedownRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedBbcResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    externalUrl?: SortOrder
    durationMs?: SortOrder
    transcript?: SortOrder
    segments?: SortOrder
    uploadedById?: SortOrder
    isPublished?: SortOrder
    publishDate?: SortOrder
    episodeNumber?: SortOrder
    seasonNumber?: SortOrder
    bbcUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceType?: SortOrder
    licenseInfo?: SortOrder
  }

  export type SharedBbcResourceAvgOrderByAggregateInput = {
    durationMs?: SortOrder
    episodeNumber?: SortOrder
    seasonNumber?: SortOrder
  }

  export type SharedBbcResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    externalUrl?: SortOrder
    durationMs?: SortOrder
    transcript?: SortOrder
    uploadedById?: SortOrder
    isPublished?: SortOrder
    publishDate?: SortOrder
    episodeNumber?: SortOrder
    seasonNumber?: SortOrder
    bbcUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceType?: SortOrder
    licenseInfo?: SortOrder
  }

  export type SharedBbcResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    externalUrl?: SortOrder
    durationMs?: SortOrder
    transcript?: SortOrder
    uploadedById?: SortOrder
    isPublished?: SortOrder
    publishDate?: SortOrder
    episodeNumber?: SortOrder
    seasonNumber?: SortOrder
    bbcUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceType?: SortOrder
    licenseInfo?: SortOrder
  }

  export type SharedBbcResourceSumOrderByAggregateInput = {
    durationMs?: SortOrder
    episodeNumber?: SortOrder
    seasonNumber?: SortOrder
  }

  export type TranscriptRunNullableScalarRelationFilter = {
    is?: TranscriptRunWhereInput | null
    isNot?: TranscriptRunWhereInput | null
  }

  export type LearningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    audioId?: SortOrder
    transcriptRunId?: SortOrder
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LearningSessionAvgOrderByAggregateInput = {
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrder
  }

  export type LearningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    audioId?: SortOrder
    transcriptRunId?: SortOrder
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LearningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    audioId?: SortOrder
    transcriptRunId?: SortOrder
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LearningSessionSumOrderByAggregateInput = {
    completedSegments?: SortOrder
    totalSegments?: SortOrder
    listeningTimeMs?: SortOrder
    practiceTimeMs?: SortOrder
    loopCount?: SortOrder
    recordingCount?: SortOrder
    score?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedBbcResourceScalarRelationFilter = {
    is?: SharedBbcResourceWhereInput
    isNot?: SharedBbcResourceWhereInput
  }

  export type TakedownRequestCountOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    reason?: SortOrder
    contactInfo?: SortOrder
    additionalInfo?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakedownRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    reason?: SortOrder
    contactInfo?: SortOrder
    additionalInfo?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TakedownRequestMinOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    reason?: SortOrder
    contactInfo?: SortOrder
    additionalInfo?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AudioFileCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioFileCreateWithoutUserInput, AudioFileUncheckedCreateWithoutUserInput> | AudioFileCreateWithoutUserInput[] | AudioFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioFileCreateOrConnectWithoutUserInput | AudioFileCreateOrConnectWithoutUserInput[]
    createMany?: AudioFileCreateManyUserInputEnvelope
    connect?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
  }

  export type TranscriptRunCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TranscriptRunCreateWithoutAuthorInput, TranscriptRunUncheckedCreateWithoutAuthorInput> | TranscriptRunCreateWithoutAuthorInput[] | TranscriptRunUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAuthorInput | TranscriptRunCreateOrConnectWithoutAuthorInput[]
    createMany?: TranscriptRunCreateManyAuthorInputEnvelope
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
  }

  export type AnnotationCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type UsageLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type AuthSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SharedBbcResourceCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<SharedBbcResourceCreateWithoutUploadedByInput, SharedBbcResourceUncheckedCreateWithoutUploadedByInput> | SharedBbcResourceCreateWithoutUploadedByInput[] | SharedBbcResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: SharedBbcResourceCreateOrConnectWithoutUploadedByInput | SharedBbcResourceCreateOrConnectWithoutUploadedByInput[]
    createMany?: SharedBbcResourceCreateManyUploadedByInputEnvelope
    connect?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
  }

  export type LearningSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AudioFileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AudioFileCreateWithoutUserInput, AudioFileUncheckedCreateWithoutUserInput> | AudioFileCreateWithoutUserInput[] | AudioFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioFileCreateOrConnectWithoutUserInput | AudioFileCreateOrConnectWithoutUserInput[]
    createMany?: AudioFileCreateManyUserInputEnvelope
    connect?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
  }

  export type TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TranscriptRunCreateWithoutAuthorInput, TranscriptRunUncheckedCreateWithoutAuthorInput> | TranscriptRunCreateWithoutAuthorInput[] | TranscriptRunUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAuthorInput | TranscriptRunCreateOrConnectWithoutAuthorInput[]
    createMany?: TranscriptRunCreateManyAuthorInputEnvelope
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
  }

  export type AnnotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type UsageLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type AuthSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<SharedBbcResourceCreateWithoutUploadedByInput, SharedBbcResourceUncheckedCreateWithoutUploadedByInput> | SharedBbcResourceCreateWithoutUploadedByInput[] | SharedBbcResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: SharedBbcResourceCreateOrConnectWithoutUploadedByInput | SharedBbcResourceCreateOrConnectWithoutUploadedByInput[]
    createMany?: SharedBbcResourceCreateManyUploadedByInputEnvelope
    connect?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
  }

  export type LearningSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type AudioFileUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioFileCreateWithoutUserInput, AudioFileUncheckedCreateWithoutUserInput> | AudioFileCreateWithoutUserInput[] | AudioFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioFileCreateOrConnectWithoutUserInput | AudioFileCreateOrConnectWithoutUserInput[]
    upsert?: AudioFileUpsertWithWhereUniqueWithoutUserInput | AudioFileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioFileCreateManyUserInputEnvelope
    set?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    disconnect?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    delete?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    connect?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    update?: AudioFileUpdateWithWhereUniqueWithoutUserInput | AudioFileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioFileUpdateManyWithWhereWithoutUserInput | AudioFileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioFileScalarWhereInput | AudioFileScalarWhereInput[]
  }

  export type TranscriptRunUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutAuthorInput, TranscriptRunUncheckedCreateWithoutAuthorInput> | TranscriptRunCreateWithoutAuthorInput[] | TranscriptRunUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAuthorInput | TranscriptRunCreateOrConnectWithoutAuthorInput[]
    upsert?: TranscriptRunUpsertWithWhereUniqueWithoutAuthorInput | TranscriptRunUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TranscriptRunCreateManyAuthorInputEnvelope
    set?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    disconnect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    delete?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    update?: TranscriptRunUpdateWithWhereUniqueWithoutAuthorInput | TranscriptRunUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TranscriptRunUpdateManyWithWhereWithoutAuthorInput | TranscriptRunUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TranscriptRunScalarWhereInput | TranscriptRunScalarWhereInput[]
  }

  export type AnnotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutUserInput | AnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutUserInput | AnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutUserInput | AnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type UsageLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutUserInput | UsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutUserInput | UsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutUserInput | UsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type AuthSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SharedBbcResourceUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<SharedBbcResourceCreateWithoutUploadedByInput, SharedBbcResourceUncheckedCreateWithoutUploadedByInput> | SharedBbcResourceCreateWithoutUploadedByInput[] | SharedBbcResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: SharedBbcResourceCreateOrConnectWithoutUploadedByInput | SharedBbcResourceCreateOrConnectWithoutUploadedByInput[]
    upsert?: SharedBbcResourceUpsertWithWhereUniqueWithoutUploadedByInput | SharedBbcResourceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: SharedBbcResourceCreateManyUploadedByInputEnvelope
    set?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    disconnect?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    delete?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    connect?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    update?: SharedBbcResourceUpdateWithWhereUniqueWithoutUploadedByInput | SharedBbcResourceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: SharedBbcResourceUpdateManyWithWhereWithoutUploadedByInput | SharedBbcResourceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: SharedBbcResourceScalarWhereInput | SharedBbcResourceScalarWhereInput[]
  }

  export type LearningSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutUserInput | LearningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutUserInput | LearningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutUserInput | LearningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type AudioFileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AudioFileCreateWithoutUserInput, AudioFileUncheckedCreateWithoutUserInput> | AudioFileCreateWithoutUserInput[] | AudioFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AudioFileCreateOrConnectWithoutUserInput | AudioFileCreateOrConnectWithoutUserInput[]
    upsert?: AudioFileUpsertWithWhereUniqueWithoutUserInput | AudioFileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AudioFileCreateManyUserInputEnvelope
    set?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    disconnect?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    delete?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    connect?: AudioFileWhereUniqueInput | AudioFileWhereUniqueInput[]
    update?: AudioFileUpdateWithWhereUniqueWithoutUserInput | AudioFileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AudioFileUpdateManyWithWhereWithoutUserInput | AudioFileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AudioFileScalarWhereInput | AudioFileScalarWhereInput[]
  }

  export type TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutAuthorInput, TranscriptRunUncheckedCreateWithoutAuthorInput> | TranscriptRunCreateWithoutAuthorInput[] | TranscriptRunUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAuthorInput | TranscriptRunCreateOrConnectWithoutAuthorInput[]
    upsert?: TranscriptRunUpsertWithWhereUniqueWithoutAuthorInput | TranscriptRunUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TranscriptRunCreateManyAuthorInputEnvelope
    set?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    disconnect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    delete?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    update?: TranscriptRunUpdateWithWhereUniqueWithoutAuthorInput | TranscriptRunUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TranscriptRunUpdateManyWithWhereWithoutAuthorInput | TranscriptRunUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TranscriptRunScalarWhereInput | TranscriptRunScalarWhereInput[]
  }

  export type AnnotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput> | AnnotationCreateWithoutUserInput[] | AnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutUserInput | AnnotationCreateOrConnectWithoutUserInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutUserInput | AnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnnotationCreateManyUserInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutUserInput | AnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutUserInput | AnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type UsageLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutUserInput | UsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutUserInput | UsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutUserInput | UsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<SharedBbcResourceCreateWithoutUploadedByInput, SharedBbcResourceUncheckedCreateWithoutUploadedByInput> | SharedBbcResourceCreateWithoutUploadedByInput[] | SharedBbcResourceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: SharedBbcResourceCreateOrConnectWithoutUploadedByInput | SharedBbcResourceCreateOrConnectWithoutUploadedByInput[]
    upsert?: SharedBbcResourceUpsertWithWhereUniqueWithoutUploadedByInput | SharedBbcResourceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: SharedBbcResourceCreateManyUploadedByInputEnvelope
    set?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    disconnect?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    delete?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    connect?: SharedBbcResourceWhereUniqueInput | SharedBbcResourceWhereUniqueInput[]
    update?: SharedBbcResourceUpdateWithWhereUniqueWithoutUploadedByInput | SharedBbcResourceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: SharedBbcResourceUpdateManyWithWhereWithoutUploadedByInput | SharedBbcResourceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: SharedBbcResourceScalarWhereInput | SharedBbcResourceScalarWhereInput[]
  }

  export type LearningSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutUserInput | LearningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutUserInput | LearningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutUserInput | LearningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuthSessionsInput = {
    create?: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthSessionsInput
    upsert?: UserUpsertWithoutAuthSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthSessionsInput, UserUpdateWithoutAuthSessionsInput>, UserUncheckedUpdateWithoutAuthSessionsInput>
  }

  export type UserCreateNestedOneWithoutAudioFilesInput = {
    create?: XOR<UserCreateWithoutAudioFilesInput, UserUncheckedCreateWithoutAudioFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioFilesInput
    connect?: UserWhereUniqueInput
  }

  export type TranscriptRunCreateNestedManyWithoutAudioInput = {
    create?: XOR<TranscriptRunCreateWithoutAudioInput, TranscriptRunUncheckedCreateWithoutAudioInput> | TranscriptRunCreateWithoutAudioInput[] | TranscriptRunUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAudioInput | TranscriptRunCreateOrConnectWithoutAudioInput[]
    createMany?: TranscriptRunCreateManyAudioInputEnvelope
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
  }

  export type AudioTagCreateNestedManyWithoutAudioInput = {
    create?: XOR<AudioTagCreateWithoutAudioInput, AudioTagUncheckedCreateWithoutAudioInput> | AudioTagCreateWithoutAudioInput[] | AudioTagUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: AudioTagCreateOrConnectWithoutAudioInput | AudioTagCreateOrConnectWithoutAudioInput[]
    createMany?: AudioTagCreateManyAudioInputEnvelope
    connect?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutAudioInput = {
    create?: XOR<JobCreateWithoutAudioInput, JobUncheckedCreateWithoutAudioInput> | JobCreateWithoutAudioInput[] | JobUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAudioInput | JobCreateOrConnectWithoutAudioInput[]
    createMany?: JobCreateManyAudioInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type LearningSessionCreateNestedManyWithoutAudioFileInput = {
    create?: XOR<LearningSessionCreateWithoutAudioFileInput, LearningSessionUncheckedCreateWithoutAudioFileInput> | LearningSessionCreateWithoutAudioFileInput[] | LearningSessionUncheckedCreateWithoutAudioFileInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutAudioFileInput | LearningSessionCreateOrConnectWithoutAudioFileInput[]
    createMany?: LearningSessionCreateManyAudioFileInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type TranscriptRunUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<TranscriptRunCreateWithoutAudioInput, TranscriptRunUncheckedCreateWithoutAudioInput> | TranscriptRunCreateWithoutAudioInput[] | TranscriptRunUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAudioInput | TranscriptRunCreateOrConnectWithoutAudioInput[]
    createMany?: TranscriptRunCreateManyAudioInputEnvelope
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
  }

  export type AudioTagUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<AudioTagCreateWithoutAudioInput, AudioTagUncheckedCreateWithoutAudioInput> | AudioTagCreateWithoutAudioInput[] | AudioTagUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: AudioTagCreateOrConnectWithoutAudioInput | AudioTagCreateOrConnectWithoutAudioInput[]
    createMany?: AudioTagCreateManyAudioInputEnvelope
    connect?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<JobCreateWithoutAudioInput, JobUncheckedCreateWithoutAudioInput> | JobCreateWithoutAudioInput[] | JobUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAudioInput | JobCreateOrConnectWithoutAudioInput[]
    createMany?: JobCreateManyAudioInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type LearningSessionUncheckedCreateNestedManyWithoutAudioFileInput = {
    create?: XOR<LearningSessionCreateWithoutAudioFileInput, LearningSessionUncheckedCreateWithoutAudioFileInput> | LearningSessionCreateWithoutAudioFileInput[] | LearningSessionUncheckedCreateWithoutAudioFileInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutAudioFileInput | LearningSessionCreateOrConnectWithoutAudioFileInput[]
    createMany?: LearningSessionCreateManyAudioFileInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAudioFilesNestedInput = {
    create?: XOR<UserCreateWithoutAudioFilesInput, UserUncheckedCreateWithoutAudioFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAudioFilesInput
    upsert?: UserUpsertWithoutAudioFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAudioFilesInput, UserUpdateWithoutAudioFilesInput>, UserUncheckedUpdateWithoutAudioFilesInput>
  }

  export type TranscriptRunUpdateManyWithoutAudioNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutAudioInput, TranscriptRunUncheckedCreateWithoutAudioInput> | TranscriptRunCreateWithoutAudioInput[] | TranscriptRunUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAudioInput | TranscriptRunCreateOrConnectWithoutAudioInput[]
    upsert?: TranscriptRunUpsertWithWhereUniqueWithoutAudioInput | TranscriptRunUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: TranscriptRunCreateManyAudioInputEnvelope
    set?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    disconnect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    delete?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    update?: TranscriptRunUpdateWithWhereUniqueWithoutAudioInput | TranscriptRunUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: TranscriptRunUpdateManyWithWhereWithoutAudioInput | TranscriptRunUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: TranscriptRunScalarWhereInput | TranscriptRunScalarWhereInput[]
  }

  export type AudioTagUpdateManyWithoutAudioNestedInput = {
    create?: XOR<AudioTagCreateWithoutAudioInput, AudioTagUncheckedCreateWithoutAudioInput> | AudioTagCreateWithoutAudioInput[] | AudioTagUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: AudioTagCreateOrConnectWithoutAudioInput | AudioTagCreateOrConnectWithoutAudioInput[]
    upsert?: AudioTagUpsertWithWhereUniqueWithoutAudioInput | AudioTagUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: AudioTagCreateManyAudioInputEnvelope
    set?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    disconnect?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    delete?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    connect?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    update?: AudioTagUpdateWithWhereUniqueWithoutAudioInput | AudioTagUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: AudioTagUpdateManyWithWhereWithoutAudioInput | AudioTagUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: AudioTagScalarWhereInput | AudioTagScalarWhereInput[]
  }

  export type JobUpdateManyWithoutAudioNestedInput = {
    create?: XOR<JobCreateWithoutAudioInput, JobUncheckedCreateWithoutAudioInput> | JobCreateWithoutAudioInput[] | JobUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAudioInput | JobCreateOrConnectWithoutAudioInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutAudioInput | JobUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: JobCreateManyAudioInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutAudioInput | JobUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: JobUpdateManyWithWhereWithoutAudioInput | JobUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type LearningSessionUpdateManyWithoutAudioFileNestedInput = {
    create?: XOR<LearningSessionCreateWithoutAudioFileInput, LearningSessionUncheckedCreateWithoutAudioFileInput> | LearningSessionCreateWithoutAudioFileInput[] | LearningSessionUncheckedCreateWithoutAudioFileInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutAudioFileInput | LearningSessionCreateOrConnectWithoutAudioFileInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutAudioFileInput | LearningSessionUpsertWithWhereUniqueWithoutAudioFileInput[]
    createMany?: LearningSessionCreateManyAudioFileInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutAudioFileInput | LearningSessionUpdateWithWhereUniqueWithoutAudioFileInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutAudioFileInput | LearningSessionUpdateManyWithWhereWithoutAudioFileInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type TranscriptRunUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutAudioInput, TranscriptRunUncheckedCreateWithoutAudioInput> | TranscriptRunCreateWithoutAudioInput[] | TranscriptRunUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAudioInput | TranscriptRunCreateOrConnectWithoutAudioInput[]
    upsert?: TranscriptRunUpsertWithWhereUniqueWithoutAudioInput | TranscriptRunUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: TranscriptRunCreateManyAudioInputEnvelope
    set?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    disconnect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    delete?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    connect?: TranscriptRunWhereUniqueInput | TranscriptRunWhereUniqueInput[]
    update?: TranscriptRunUpdateWithWhereUniqueWithoutAudioInput | TranscriptRunUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: TranscriptRunUpdateManyWithWhereWithoutAudioInput | TranscriptRunUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: TranscriptRunScalarWhereInput | TranscriptRunScalarWhereInput[]
  }

  export type AudioTagUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<AudioTagCreateWithoutAudioInput, AudioTagUncheckedCreateWithoutAudioInput> | AudioTagCreateWithoutAudioInput[] | AudioTagUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: AudioTagCreateOrConnectWithoutAudioInput | AudioTagCreateOrConnectWithoutAudioInput[]
    upsert?: AudioTagUpsertWithWhereUniqueWithoutAudioInput | AudioTagUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: AudioTagCreateManyAudioInputEnvelope
    set?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    disconnect?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    delete?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    connect?: AudioTagWhereUniqueInput | AudioTagWhereUniqueInput[]
    update?: AudioTagUpdateWithWhereUniqueWithoutAudioInput | AudioTagUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: AudioTagUpdateManyWithWhereWithoutAudioInput | AudioTagUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: AudioTagScalarWhereInput | AudioTagScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<JobCreateWithoutAudioInput, JobUncheckedCreateWithoutAudioInput> | JobCreateWithoutAudioInput[] | JobUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAudioInput | JobCreateOrConnectWithoutAudioInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutAudioInput | JobUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: JobCreateManyAudioInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutAudioInput | JobUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: JobUpdateManyWithWhereWithoutAudioInput | JobUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type LearningSessionUncheckedUpdateManyWithoutAudioFileNestedInput = {
    create?: XOR<LearningSessionCreateWithoutAudioFileInput, LearningSessionUncheckedCreateWithoutAudioFileInput> | LearningSessionCreateWithoutAudioFileInput[] | LearningSessionUncheckedCreateWithoutAudioFileInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutAudioFileInput | LearningSessionCreateOrConnectWithoutAudioFileInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutAudioFileInput | LearningSessionUpsertWithWhereUniqueWithoutAudioFileInput[]
    createMany?: LearningSessionCreateManyAudioFileInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutAudioFileInput | LearningSessionUpdateWithWhereUniqueWithoutAudioFileInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutAudioFileInput | LearningSessionUpdateManyWithWhereWithoutAudioFileInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type AudioFileCreateNestedOneWithoutTranscriptRunsInput = {
    create?: XOR<AudioFileCreateWithoutTranscriptRunsInput, AudioFileUncheckedCreateWithoutTranscriptRunsInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutTranscriptRunsInput
    connect?: AudioFileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTranscriptRunsInput = {
    create?: XOR<UserCreateWithoutTranscriptRunsInput, UserUncheckedCreateWithoutTranscriptRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTranscriptRunsInput
    connect?: UserWhereUniqueInput
  }

  export type TranscriptRevisionCreateNestedManyWithoutRunInput = {
    create?: XOR<TranscriptRevisionCreateWithoutRunInput, TranscriptRevisionUncheckedCreateWithoutRunInput> | TranscriptRevisionCreateWithoutRunInput[] | TranscriptRevisionUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TranscriptRevisionCreateOrConnectWithoutRunInput | TranscriptRevisionCreateOrConnectWithoutRunInput[]
    createMany?: TranscriptRevisionCreateManyRunInputEnvelope
    connect?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
  }

  export type AnnotationCreateNestedManyWithoutRunInput = {
    create?: XOR<AnnotationCreateWithoutRunInput, AnnotationUncheckedCreateWithoutRunInput> | AnnotationCreateWithoutRunInput[] | AnnotationUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutRunInput | AnnotationCreateOrConnectWithoutRunInput[]
    createMany?: AnnotationCreateManyRunInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type JobCreateNestedManyWithoutRunInput = {
    create?: XOR<JobCreateWithoutRunInput, JobUncheckedCreateWithoutRunInput> | JobCreateWithoutRunInput[] | JobUncheckedCreateWithoutRunInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRunInput | JobCreateOrConnectWithoutRunInput[]
    createMany?: JobCreateManyRunInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type AnalysisCreateNestedManyWithoutRunInput = {
    create?: XOR<AnalysisCreateWithoutRunInput, AnalysisUncheckedCreateWithoutRunInput> | AnalysisCreateWithoutRunInput[] | AnalysisUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnalysisCreateOrConnectWithoutRunInput | AnalysisCreateOrConnectWithoutRunInput[]
    createMany?: AnalysisCreateManyRunInputEnvelope
    connect?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
  }

  export type LearningSessionCreateNestedManyWithoutTranscriptRunInput = {
    create?: XOR<LearningSessionCreateWithoutTranscriptRunInput, LearningSessionUncheckedCreateWithoutTranscriptRunInput> | LearningSessionCreateWithoutTranscriptRunInput[] | LearningSessionUncheckedCreateWithoutTranscriptRunInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutTranscriptRunInput | LearningSessionCreateOrConnectWithoutTranscriptRunInput[]
    createMany?: LearningSessionCreateManyTranscriptRunInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<TranscriptRevisionCreateWithoutRunInput, TranscriptRevisionUncheckedCreateWithoutRunInput> | TranscriptRevisionCreateWithoutRunInput[] | TranscriptRevisionUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TranscriptRevisionCreateOrConnectWithoutRunInput | TranscriptRevisionCreateOrConnectWithoutRunInput[]
    createMany?: TranscriptRevisionCreateManyRunInputEnvelope
    connect?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
  }

  export type AnnotationUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<AnnotationCreateWithoutRunInput, AnnotationUncheckedCreateWithoutRunInput> | AnnotationCreateWithoutRunInput[] | AnnotationUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutRunInput | AnnotationCreateOrConnectWithoutRunInput[]
    createMany?: AnnotationCreateManyRunInputEnvelope
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<JobCreateWithoutRunInput, JobUncheckedCreateWithoutRunInput> | JobCreateWithoutRunInput[] | JobUncheckedCreateWithoutRunInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRunInput | JobCreateOrConnectWithoutRunInput[]
    createMany?: JobCreateManyRunInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type AnalysisUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<AnalysisCreateWithoutRunInput, AnalysisUncheckedCreateWithoutRunInput> | AnalysisCreateWithoutRunInput[] | AnalysisUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnalysisCreateOrConnectWithoutRunInput | AnalysisCreateOrConnectWithoutRunInput[]
    createMany?: AnalysisCreateManyRunInputEnvelope
    connect?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
  }

  export type LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput = {
    create?: XOR<LearningSessionCreateWithoutTranscriptRunInput, LearningSessionUncheckedCreateWithoutTranscriptRunInput> | LearningSessionCreateWithoutTranscriptRunInput[] | LearningSessionUncheckedCreateWithoutTranscriptRunInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutTranscriptRunInput | LearningSessionCreateOrConnectWithoutTranscriptRunInput[]
    createMany?: LearningSessionCreateManyTranscriptRunInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput = {
    create?: XOR<AudioFileCreateWithoutTranscriptRunsInput, AudioFileUncheckedCreateWithoutTranscriptRunsInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutTranscriptRunsInput
    upsert?: AudioFileUpsertWithoutTranscriptRunsInput
    connect?: AudioFileWhereUniqueInput
    update?: XOR<XOR<AudioFileUpdateToOneWithWhereWithoutTranscriptRunsInput, AudioFileUpdateWithoutTranscriptRunsInput>, AudioFileUncheckedUpdateWithoutTranscriptRunsInput>
  }

  export type UserUpdateOneWithoutTranscriptRunsNestedInput = {
    create?: XOR<UserCreateWithoutTranscriptRunsInput, UserUncheckedCreateWithoutTranscriptRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTranscriptRunsInput
    upsert?: UserUpsertWithoutTranscriptRunsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTranscriptRunsInput, UserUpdateWithoutTranscriptRunsInput>, UserUncheckedUpdateWithoutTranscriptRunsInput>
  }

  export type TranscriptRevisionUpdateManyWithoutRunNestedInput = {
    create?: XOR<TranscriptRevisionCreateWithoutRunInput, TranscriptRevisionUncheckedCreateWithoutRunInput> | TranscriptRevisionCreateWithoutRunInput[] | TranscriptRevisionUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TranscriptRevisionCreateOrConnectWithoutRunInput | TranscriptRevisionCreateOrConnectWithoutRunInput[]
    upsert?: TranscriptRevisionUpsertWithWhereUniqueWithoutRunInput | TranscriptRevisionUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: TranscriptRevisionCreateManyRunInputEnvelope
    set?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    disconnect?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    delete?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    connect?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    update?: TranscriptRevisionUpdateWithWhereUniqueWithoutRunInput | TranscriptRevisionUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: TranscriptRevisionUpdateManyWithWhereWithoutRunInput | TranscriptRevisionUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: TranscriptRevisionScalarWhereInput | TranscriptRevisionScalarWhereInput[]
  }

  export type AnnotationUpdateManyWithoutRunNestedInput = {
    create?: XOR<AnnotationCreateWithoutRunInput, AnnotationUncheckedCreateWithoutRunInput> | AnnotationCreateWithoutRunInput[] | AnnotationUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutRunInput | AnnotationCreateOrConnectWithoutRunInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutRunInput | AnnotationUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AnnotationCreateManyRunInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutRunInput | AnnotationUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutRunInput | AnnotationUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type JobUpdateManyWithoutRunNestedInput = {
    create?: XOR<JobCreateWithoutRunInput, JobUncheckedCreateWithoutRunInput> | JobCreateWithoutRunInput[] | JobUncheckedCreateWithoutRunInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRunInput | JobCreateOrConnectWithoutRunInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutRunInput | JobUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: JobCreateManyRunInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutRunInput | JobUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: JobUpdateManyWithWhereWithoutRunInput | JobUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type AnalysisUpdateManyWithoutRunNestedInput = {
    create?: XOR<AnalysisCreateWithoutRunInput, AnalysisUncheckedCreateWithoutRunInput> | AnalysisCreateWithoutRunInput[] | AnalysisUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnalysisCreateOrConnectWithoutRunInput | AnalysisCreateOrConnectWithoutRunInput[]
    upsert?: AnalysisUpsertWithWhereUniqueWithoutRunInput | AnalysisUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AnalysisCreateManyRunInputEnvelope
    set?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    disconnect?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    delete?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    connect?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    update?: AnalysisUpdateWithWhereUniqueWithoutRunInput | AnalysisUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AnalysisUpdateManyWithWhereWithoutRunInput | AnalysisUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AnalysisScalarWhereInput | AnalysisScalarWhereInput[]
  }

  export type LearningSessionUpdateManyWithoutTranscriptRunNestedInput = {
    create?: XOR<LearningSessionCreateWithoutTranscriptRunInput, LearningSessionUncheckedCreateWithoutTranscriptRunInput> | LearningSessionCreateWithoutTranscriptRunInput[] | LearningSessionUncheckedCreateWithoutTranscriptRunInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutTranscriptRunInput | LearningSessionCreateOrConnectWithoutTranscriptRunInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutTranscriptRunInput | LearningSessionUpsertWithWhereUniqueWithoutTranscriptRunInput[]
    createMany?: LearningSessionCreateManyTranscriptRunInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutTranscriptRunInput | LearningSessionUpdateWithWhereUniqueWithoutTranscriptRunInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutTranscriptRunInput | LearningSessionUpdateManyWithWhereWithoutTranscriptRunInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<TranscriptRevisionCreateWithoutRunInput, TranscriptRevisionUncheckedCreateWithoutRunInput> | TranscriptRevisionCreateWithoutRunInput[] | TranscriptRevisionUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TranscriptRevisionCreateOrConnectWithoutRunInput | TranscriptRevisionCreateOrConnectWithoutRunInput[]
    upsert?: TranscriptRevisionUpsertWithWhereUniqueWithoutRunInput | TranscriptRevisionUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: TranscriptRevisionCreateManyRunInputEnvelope
    set?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    disconnect?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    delete?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    connect?: TranscriptRevisionWhereUniqueInput | TranscriptRevisionWhereUniqueInput[]
    update?: TranscriptRevisionUpdateWithWhereUniqueWithoutRunInput | TranscriptRevisionUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: TranscriptRevisionUpdateManyWithWhereWithoutRunInput | TranscriptRevisionUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: TranscriptRevisionScalarWhereInput | TranscriptRevisionScalarWhereInput[]
  }

  export type AnnotationUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<AnnotationCreateWithoutRunInput, AnnotationUncheckedCreateWithoutRunInput> | AnnotationCreateWithoutRunInput[] | AnnotationUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnnotationCreateOrConnectWithoutRunInput | AnnotationCreateOrConnectWithoutRunInput[]
    upsert?: AnnotationUpsertWithWhereUniqueWithoutRunInput | AnnotationUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AnnotationCreateManyRunInputEnvelope
    set?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    disconnect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    delete?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    connect?: AnnotationWhereUniqueInput | AnnotationWhereUniqueInput[]
    update?: AnnotationUpdateWithWhereUniqueWithoutRunInput | AnnotationUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AnnotationUpdateManyWithWhereWithoutRunInput | AnnotationUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<JobCreateWithoutRunInput, JobUncheckedCreateWithoutRunInput> | JobCreateWithoutRunInput[] | JobUncheckedCreateWithoutRunInput[]
    connectOrCreate?: JobCreateOrConnectWithoutRunInput | JobCreateOrConnectWithoutRunInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutRunInput | JobUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: JobCreateManyRunInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutRunInput | JobUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: JobUpdateManyWithWhereWithoutRunInput | JobUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type AnalysisUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<AnalysisCreateWithoutRunInput, AnalysisUncheckedCreateWithoutRunInput> | AnalysisCreateWithoutRunInput[] | AnalysisUncheckedCreateWithoutRunInput[]
    connectOrCreate?: AnalysisCreateOrConnectWithoutRunInput | AnalysisCreateOrConnectWithoutRunInput[]
    upsert?: AnalysisUpsertWithWhereUniqueWithoutRunInput | AnalysisUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: AnalysisCreateManyRunInputEnvelope
    set?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    disconnect?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    delete?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    connect?: AnalysisWhereUniqueInput | AnalysisWhereUniqueInput[]
    update?: AnalysisUpdateWithWhereUniqueWithoutRunInput | AnalysisUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: AnalysisUpdateManyWithWhereWithoutRunInput | AnalysisUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: AnalysisScalarWhereInput | AnalysisScalarWhereInput[]
  }

  export type LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput = {
    create?: XOR<LearningSessionCreateWithoutTranscriptRunInput, LearningSessionUncheckedCreateWithoutTranscriptRunInput> | LearningSessionCreateWithoutTranscriptRunInput[] | LearningSessionUncheckedCreateWithoutTranscriptRunInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutTranscriptRunInput | LearningSessionCreateOrConnectWithoutTranscriptRunInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutTranscriptRunInput | LearningSessionUpsertWithWhereUniqueWithoutTranscriptRunInput[]
    createMany?: LearningSessionCreateManyTranscriptRunInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutTranscriptRunInput | LearningSessionUpdateWithWhereUniqueWithoutTranscriptRunInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutTranscriptRunInput | LearningSessionUpdateManyWithWhereWithoutTranscriptRunInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type TranscriptRunCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<TranscriptRunCreateWithoutRevisionsInput, TranscriptRunUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutRevisionsInput
    connect?: TranscriptRunWhereUniqueInput
  }

  export type TranscriptRunUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutRevisionsInput, TranscriptRunUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutRevisionsInput
    upsert?: TranscriptRunUpsertWithoutRevisionsInput
    connect?: TranscriptRunWhereUniqueInput
    update?: XOR<XOR<TranscriptRunUpdateToOneWithWhereWithoutRevisionsInput, TranscriptRunUpdateWithoutRevisionsInput>, TranscriptRunUncheckedUpdateWithoutRevisionsInput>
  }

  export type TranscriptRunCreateNestedOneWithoutAnalysesInput = {
    create?: XOR<TranscriptRunCreateWithoutAnalysesInput, TranscriptRunUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAnalysesInput
    connect?: TranscriptRunWhereUniqueInput
  }

  export type TranscriptRunUpdateOneRequiredWithoutAnalysesNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutAnalysesInput, TranscriptRunUncheckedCreateWithoutAnalysesInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAnalysesInput
    upsert?: TranscriptRunUpsertWithoutAnalysesInput
    connect?: TranscriptRunWhereUniqueInput
    update?: XOR<XOR<TranscriptRunUpdateToOneWithWhereWithoutAnalysesInput, TranscriptRunUpdateWithoutAnalysesInput>, TranscriptRunUncheckedUpdateWithoutAnalysesInput>
  }

  export type TranscriptRunCreateNestedOneWithoutAnnotationsInput = {
    create?: XOR<TranscriptRunCreateWithoutAnnotationsInput, TranscriptRunUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAnnotationsInput
    connect?: TranscriptRunWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnotationsInput = {
    create?: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationsInput
    connect?: UserWhereUniqueInput
  }

  export type TranscriptRunUpdateOneRequiredWithoutAnnotationsNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutAnnotationsInput, TranscriptRunUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutAnnotationsInput
    upsert?: TranscriptRunUpsertWithoutAnnotationsInput
    connect?: TranscriptRunWhereUniqueInput
    update?: XOR<XOR<TranscriptRunUpdateToOneWithWhereWithoutAnnotationsInput, TranscriptRunUpdateWithoutAnnotationsInput>, TranscriptRunUncheckedUpdateWithoutAnnotationsInput>
  }

  export type UserUpdateOneRequiredWithoutAnnotationsNestedInput = {
    create?: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationsInput
    upsert?: UserUpsertWithoutAnnotationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnotationsInput, UserUpdateWithoutAnnotationsInput>, UserUncheckedUpdateWithoutAnnotationsInput>
  }

  export type AudioFileCreateNestedOneWithoutTagsInput = {
    create?: XOR<AudioFileCreateWithoutTagsInput, AudioFileUncheckedCreateWithoutTagsInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutTagsInput
    connect?: AudioFileWhereUniqueInput
  }

  export type AudioFileUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<AudioFileCreateWithoutTagsInput, AudioFileUncheckedCreateWithoutTagsInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutTagsInput
    upsert?: AudioFileUpsertWithoutTagsInput
    connect?: AudioFileWhereUniqueInput
    update?: XOR<XOR<AudioFileUpdateToOneWithWhereWithoutTagsInput, AudioFileUpdateWithoutTagsInput>, AudioFileUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageLogsInput
    upsert?: UserUpsertWithoutUsageLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageLogsInput, UserUpdateWithoutUsageLogsInput>, UserUncheckedUpdateWithoutUsageLogsInput>
  }

  export type AudioFileCreateNestedOneWithoutJobInput = {
    create?: XOR<AudioFileCreateWithoutJobInput, AudioFileUncheckedCreateWithoutJobInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutJobInput
    connect?: AudioFileWhereUniqueInput
  }

  export type TranscriptRunCreateNestedOneWithoutJobsInput = {
    create?: XOR<TranscriptRunCreateWithoutJobsInput, TranscriptRunUncheckedCreateWithoutJobsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutJobsInput
    connect?: TranscriptRunWhereUniqueInput
  }

  export type AudioFileUpdateOneWithoutJobNestedInput = {
    create?: XOR<AudioFileCreateWithoutJobInput, AudioFileUncheckedCreateWithoutJobInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutJobInput
    upsert?: AudioFileUpsertWithoutJobInput
    disconnect?: AudioFileWhereInput | boolean
    delete?: AudioFileWhereInput | boolean
    connect?: AudioFileWhereUniqueInput
    update?: XOR<XOR<AudioFileUpdateToOneWithWhereWithoutJobInput, AudioFileUpdateWithoutJobInput>, AudioFileUncheckedUpdateWithoutJobInput>
  }

  export type TranscriptRunUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutJobsInput, TranscriptRunUncheckedCreateWithoutJobsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutJobsInput
    upsert?: TranscriptRunUpsertWithoutJobsInput
    connect?: TranscriptRunWhereUniqueInput
    update?: XOR<XOR<TranscriptRunUpdateToOneWithWhereWithoutJobsInput, TranscriptRunUpdateWithoutJobsInput>, TranscriptRunUncheckedUpdateWithoutJobsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutSharedBbcResourcesInput = {
    create?: XOR<UserCreateWithoutSharedBbcResourcesInput, UserUncheckedCreateWithoutSharedBbcResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedBbcResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type TakedownRequestCreateNestedManyWithoutResourceInput = {
    create?: XOR<TakedownRequestCreateWithoutResourceInput, TakedownRequestUncheckedCreateWithoutResourceInput> | TakedownRequestCreateWithoutResourceInput[] | TakedownRequestUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TakedownRequestCreateOrConnectWithoutResourceInput | TakedownRequestCreateOrConnectWithoutResourceInput[]
    createMany?: TakedownRequestCreateManyResourceInputEnvelope
    connect?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
  }

  export type TakedownRequestUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<TakedownRequestCreateWithoutResourceInput, TakedownRequestUncheckedCreateWithoutResourceInput> | TakedownRequestCreateWithoutResourceInput[] | TakedownRequestUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TakedownRequestCreateOrConnectWithoutResourceInput | TakedownRequestCreateOrConnectWithoutResourceInput[]
    createMany?: TakedownRequestCreateManyResourceInputEnvelope
    connect?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSharedBbcResourcesNestedInput = {
    create?: XOR<UserCreateWithoutSharedBbcResourcesInput, UserUncheckedCreateWithoutSharedBbcResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedBbcResourcesInput
    upsert?: UserUpsertWithoutSharedBbcResourcesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedBbcResourcesInput, UserUpdateWithoutSharedBbcResourcesInput>, UserUncheckedUpdateWithoutSharedBbcResourcesInput>
  }

  export type TakedownRequestUpdateManyWithoutResourceNestedInput = {
    create?: XOR<TakedownRequestCreateWithoutResourceInput, TakedownRequestUncheckedCreateWithoutResourceInput> | TakedownRequestCreateWithoutResourceInput[] | TakedownRequestUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TakedownRequestCreateOrConnectWithoutResourceInput | TakedownRequestCreateOrConnectWithoutResourceInput[]
    upsert?: TakedownRequestUpsertWithWhereUniqueWithoutResourceInput | TakedownRequestUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: TakedownRequestCreateManyResourceInputEnvelope
    set?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    disconnect?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    delete?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    connect?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    update?: TakedownRequestUpdateWithWhereUniqueWithoutResourceInput | TakedownRequestUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: TakedownRequestUpdateManyWithWhereWithoutResourceInput | TakedownRequestUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: TakedownRequestScalarWhereInput | TakedownRequestScalarWhereInput[]
  }

  export type TakedownRequestUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<TakedownRequestCreateWithoutResourceInput, TakedownRequestUncheckedCreateWithoutResourceInput> | TakedownRequestCreateWithoutResourceInput[] | TakedownRequestUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TakedownRequestCreateOrConnectWithoutResourceInput | TakedownRequestCreateOrConnectWithoutResourceInput[]
    upsert?: TakedownRequestUpsertWithWhereUniqueWithoutResourceInput | TakedownRequestUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: TakedownRequestCreateManyResourceInputEnvelope
    set?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    disconnect?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    delete?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    connect?: TakedownRequestWhereUniqueInput | TakedownRequestWhereUniqueInput[]
    update?: TakedownRequestUpdateWithWhereUniqueWithoutResourceInput | TakedownRequestUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: TakedownRequestUpdateManyWithWhereWithoutResourceInput | TakedownRequestUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: TakedownRequestScalarWhereInput | TakedownRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLearningSessionsInput = {
    create?: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type AudioFileCreateNestedOneWithoutLearningSessionsInput = {
    create?: XOR<AudioFileCreateWithoutLearningSessionsInput, AudioFileUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutLearningSessionsInput
    connect?: AudioFileWhereUniqueInput
  }

  export type TranscriptRunCreateNestedOneWithoutLearningSessionsInput = {
    create?: XOR<TranscriptRunCreateWithoutLearningSessionsInput, TranscriptRunUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutLearningSessionsInput
    connect?: TranscriptRunWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLearningSessionsNestedInput = {
    create?: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningSessionsInput
    upsert?: UserUpsertWithoutLearningSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningSessionsInput, UserUpdateWithoutLearningSessionsInput>, UserUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type AudioFileUpdateOneRequiredWithoutLearningSessionsNestedInput = {
    create?: XOR<AudioFileCreateWithoutLearningSessionsInput, AudioFileUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: AudioFileCreateOrConnectWithoutLearningSessionsInput
    upsert?: AudioFileUpsertWithoutLearningSessionsInput
    connect?: AudioFileWhereUniqueInput
    update?: XOR<XOR<AudioFileUpdateToOneWithWhereWithoutLearningSessionsInput, AudioFileUpdateWithoutLearningSessionsInput>, AudioFileUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type TranscriptRunUpdateOneWithoutLearningSessionsNestedInput = {
    create?: XOR<TranscriptRunCreateWithoutLearningSessionsInput, TranscriptRunUncheckedCreateWithoutLearningSessionsInput>
    connectOrCreate?: TranscriptRunCreateOrConnectWithoutLearningSessionsInput
    upsert?: TranscriptRunUpsertWithoutLearningSessionsInput
    disconnect?: TranscriptRunWhereInput | boolean
    delete?: TranscriptRunWhereInput | boolean
    connect?: TranscriptRunWhereUniqueInput
    update?: XOR<XOR<TranscriptRunUpdateToOneWithWhereWithoutLearningSessionsInput, TranscriptRunUpdateWithoutLearningSessionsInput>, TranscriptRunUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type SharedBbcResourceCreateNestedOneWithoutTakedownRequestsInput = {
    create?: XOR<SharedBbcResourceCreateWithoutTakedownRequestsInput, SharedBbcResourceUncheckedCreateWithoutTakedownRequestsInput>
    connectOrCreate?: SharedBbcResourceCreateOrConnectWithoutTakedownRequestsInput
    connect?: SharedBbcResourceWhereUniqueInput
  }

  export type SharedBbcResourceUpdateOneRequiredWithoutTakedownRequestsNestedInput = {
    create?: XOR<SharedBbcResourceCreateWithoutTakedownRequestsInput, SharedBbcResourceUncheckedCreateWithoutTakedownRequestsInput>
    connectOrCreate?: SharedBbcResourceCreateOrConnectWithoutTakedownRequestsInput
    upsert?: SharedBbcResourceUpsertWithoutTakedownRequestsInput
    connect?: SharedBbcResourceWhereUniqueInput
    update?: XOR<XOR<SharedBbcResourceUpdateToOneWithWhereWithoutTakedownRequestsInput, SharedBbcResourceUpdateWithoutTakedownRequestsInput>, SharedBbcResourceUncheckedUpdateWithoutTakedownRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    planType?: string
    startedAt?: Date | string
    expiresAt: Date | string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    planType?: string
    startedAt?: Date | string
    expiresAt: Date | string
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type AudioFileCreateWithoutUserInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAudioInput
    tags?: AudioTagCreateNestedManyWithoutAudioInput
    Job?: JobCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileUncheckedCreateWithoutUserInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAudioInput
    tags?: AudioTagUncheckedCreateNestedManyWithoutAudioInput
    Job?: JobUncheckedCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileCreateOrConnectWithoutUserInput = {
    where: AudioFileWhereUniqueInput
    create: XOR<AudioFileCreateWithoutUserInput, AudioFileUncheckedCreateWithoutUserInput>
  }

  export type AudioFileCreateManyUserInputEnvelope = {
    data: AudioFileCreateManyUserInput | AudioFileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptRunCreateWithoutAuthorInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutAuthorInput = {
    id?: string
    audioId: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutAuthorInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutAuthorInput, TranscriptRunUncheckedCreateWithoutAuthorInput>
  }

  export type TranscriptRunCreateManyAuthorInputEnvelope = {
    data: TranscriptRunCreateManyAuthorInput | TranscriptRunCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutUserInput = {
    id?: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
    run: TranscriptRunCreateNestedOneWithoutAnnotationsInput
  }

  export type AnnotationUncheckedCreateWithoutUserInput = {
    id?: string
    runId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type AnnotationCreateOrConnectWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationCreateManyUserInputEnvelope = {
    data: AnnotationCreateManyUserInput | AnnotationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageLogCreateWithoutUserInput = {
    id?: string
    day: Date | string
    uploadCount?: number
    durationMs?: number
    createdAt?: Date | string
  }

  export type UsageLogUncheckedCreateWithoutUserInput = {
    id?: string
    day: Date | string
    uploadCount?: number
    durationMs?: number
    createdAt?: Date | string
  }

  export type UsageLogCreateOrConnectWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    create: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput>
  }

  export type UsageLogCreateManyUserInputEnvelope = {
    data: UsageLogCreateManyUserInput | UsageLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthSessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuthSessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuthSessionCreateOrConnectWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionCreateManyUserInputEnvelope = {
    data: AuthSessionCreateManyUserInput | AuthSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    kind: string
    targetId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    kind: string
    targetId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedBbcResourceCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
    takedownRequests?: TakedownRequestCreateNestedManyWithoutResourceInput
  }

  export type SharedBbcResourceUncheckedCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
    takedownRequests?: TakedownRequestUncheckedCreateNestedManyWithoutResourceInput
  }

  export type SharedBbcResourceCreateOrConnectWithoutUploadedByInput = {
    where: SharedBbcResourceWhereUniqueInput
    create: XOR<SharedBbcResourceCreateWithoutUploadedByInput, SharedBbcResourceUncheckedCreateWithoutUploadedByInput>
  }

  export type SharedBbcResourceCreateManyUploadedByInputEnvelope = {
    data: SharedBbcResourceCreateManyUploadedByInput | SharedBbcResourceCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type LearningSessionCreateWithoutUserInput = {
    id?: string
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    audioFile: AudioFileCreateNestedOneWithoutLearningSessionsInput
    transcriptRun?: TranscriptRunCreateNestedOneWithoutLearningSessionsInput
  }

  export type LearningSessionUncheckedCreateWithoutUserInput = {
    id?: string
    audioId: string
    transcriptRunId?: string | null
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningSessionCreateOrConnectWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput>
  }

  export type LearningSessionCreateManyUserInputEnvelope = {
    data: LearningSessionCreateManyUserInput | LearningSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planType?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    planType?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioFileUpsertWithWhereUniqueWithoutUserInput = {
    where: AudioFileWhereUniqueInput
    update: XOR<AudioFileUpdateWithoutUserInput, AudioFileUncheckedUpdateWithoutUserInput>
    create: XOR<AudioFileCreateWithoutUserInput, AudioFileUncheckedCreateWithoutUserInput>
  }

  export type AudioFileUpdateWithWhereUniqueWithoutUserInput = {
    where: AudioFileWhereUniqueInput
    data: XOR<AudioFileUpdateWithoutUserInput, AudioFileUncheckedUpdateWithoutUserInput>
  }

  export type AudioFileUpdateManyWithWhereWithoutUserInput = {
    where: AudioFileScalarWhereInput
    data: XOR<AudioFileUpdateManyMutationInput, AudioFileUncheckedUpdateManyWithoutUserInput>
  }

  export type AudioFileScalarWhereInput = {
    AND?: AudioFileScalarWhereInput | AudioFileScalarWhereInput[]
    OR?: AudioFileScalarWhereInput[]
    NOT?: AudioFileScalarWhereInput | AudioFileScalarWhereInput[]
    id?: StringFilter<"AudioFile"> | string
    userId?: StringFilter<"AudioFile"> | string
    gcsUri?: StringFilter<"AudioFile"> | string
    filename?: StringFilter<"AudioFile"> | string
    durationMs?: IntNullableFilter<"AudioFile"> | number | null
    sizeBytes?: BigIntNullableFilter<"AudioFile"> | bigint | number | null
    language?: StringNullableFilter<"AudioFile"> | string | null
    mode?: StringNullableFilter<"AudioFile"> | string | null
    gapSec?: FloatNullableFilter<"AudioFile"> | number | null
    status?: StringFilter<"AudioFile"> | string
    errorMessage?: StringNullableFilter<"AudioFile"> | string | null
    meta?: JsonNullableFilter<"AudioFile">
    createdAt?: DateTimeFilter<"AudioFile"> | Date | string
    updatedAt?: DateTimeFilter<"AudioFile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AudioFile"> | Date | string | null
  }

  export type TranscriptRunUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TranscriptRunWhereUniqueInput
    update: XOR<TranscriptRunUpdateWithoutAuthorInput, TranscriptRunUncheckedUpdateWithoutAuthorInput>
    create: XOR<TranscriptRunCreateWithoutAuthorInput, TranscriptRunUncheckedCreateWithoutAuthorInput>
  }

  export type TranscriptRunUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TranscriptRunWhereUniqueInput
    data: XOR<TranscriptRunUpdateWithoutAuthorInput, TranscriptRunUncheckedUpdateWithoutAuthorInput>
  }

  export type TranscriptRunUpdateManyWithWhereWithoutAuthorInput = {
    where: TranscriptRunScalarWhereInput
    data: XOR<TranscriptRunUpdateManyMutationInput, TranscriptRunUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TranscriptRunScalarWhereInput = {
    AND?: TranscriptRunScalarWhereInput | TranscriptRunScalarWhereInput[]
    OR?: TranscriptRunScalarWhereInput[]
    NOT?: TranscriptRunScalarWhereInput | TranscriptRunScalarWhereInput[]
    id?: StringFilter<"TranscriptRun"> | string
    audioId?: StringFilter<"TranscriptRun"> | string
    authorId?: StringNullableFilter<"TranscriptRun"> | string | null
    version?: IntFilter<"TranscriptRun"> | number
    engine?: StringFilter<"TranscriptRun"> | string
    params?: JsonNullableFilter<"TranscriptRun">
    paramsHash?: StringFilter<"TranscriptRun"> | string
    status?: StringFilter<"TranscriptRun"> | string
    error?: StringNullableFilter<"TranscriptRun"> | string | null
    text?: StringNullableFilter<"TranscriptRun"> | string | null
    segments?: JsonNullableFilter<"TranscriptRun">
    speakerCount?: IntNullableFilter<"TranscriptRun"> | number | null
    confidence?: FloatNullableFilter<"TranscriptRun"> | number | null
    createdAt?: DateTimeFilter<"TranscriptRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"TranscriptRun"> | Date | string | null
  }

  export type AnnotationUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
    create: XOR<AnnotationCreateWithoutUserInput, AnnotationUncheckedCreateWithoutUserInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutUserInput, AnnotationUncheckedUpdateWithoutUserInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutUserInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutUserInput>
  }

  export type AnnotationScalarWhereInput = {
    AND?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
    OR?: AnnotationScalarWhereInput[]
    NOT?: AnnotationScalarWhereInput | AnnotationScalarWhereInput[]
    id?: StringFilter<"Annotation"> | string
    runId?: StringFilter<"Annotation"> | string
    userId?: StringFilter<"Annotation"> | string
    content?: StringFilter<"Annotation"> | string
    anchorType?: StringFilter<"Annotation"> | string
    anchorValue?: StringFilter<"Annotation"> | string
    createdAt?: DateTimeFilter<"Annotation"> | Date | string
    isDeleted?: BoolFilter<"Annotation"> | boolean
  }

  export type UsageLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    update: XOR<UsageLogUpdateWithoutUserInput, UsageLogUncheckedUpdateWithoutUserInput>
    create: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput>
  }

  export type UsageLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    data: XOR<UsageLogUpdateWithoutUserInput, UsageLogUncheckedUpdateWithoutUserInput>
  }

  export type UsageLogUpdateManyWithWhereWithoutUserInput = {
    where: UsageLogScalarWhereInput
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageLogScalarWhereInput = {
    AND?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
    OR?: UsageLogScalarWhereInput[]
    NOT?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringFilter<"UsageLog"> | string
    day?: DateTimeFilter<"UsageLog"> | Date | string
    uploadCount?: IntFilter<"UsageLog"> | number
    durationMs?: IntFilter<"UsageLog"> | number
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
  }

  export type AuthSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    update: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    data: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
  }

  export type AuthSessionUpdateManyWithWhereWithoutUserInput = {
    where: AuthSessionScalarWhereInput
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthSessionScalarWhereInput = {
    AND?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    OR?: AuthSessionScalarWhereInput[]
    NOT?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    id?: StringFilter<"AuthSession"> | string
    userId?: StringFilter<"AuthSession"> | string
    refreshToken?: StringFilter<"AuthSession"> | string
    expiresAt?: DateTimeFilter<"AuthSession"> | Date | string
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    kind?: StringFilter<"AuditLog"> | string
    targetId?: StringNullableFilter<"AuditLog"> | string | null
    meta?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type SharedBbcResourceUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: SharedBbcResourceWhereUniqueInput
    update: XOR<SharedBbcResourceUpdateWithoutUploadedByInput, SharedBbcResourceUncheckedUpdateWithoutUploadedByInput>
    create: XOR<SharedBbcResourceCreateWithoutUploadedByInput, SharedBbcResourceUncheckedCreateWithoutUploadedByInput>
  }

  export type SharedBbcResourceUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: SharedBbcResourceWhereUniqueInput
    data: XOR<SharedBbcResourceUpdateWithoutUploadedByInput, SharedBbcResourceUncheckedUpdateWithoutUploadedByInput>
  }

  export type SharedBbcResourceUpdateManyWithWhereWithoutUploadedByInput = {
    where: SharedBbcResourceScalarWhereInput
    data: XOR<SharedBbcResourceUpdateManyMutationInput, SharedBbcResourceUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type SharedBbcResourceScalarWhereInput = {
    AND?: SharedBbcResourceScalarWhereInput | SharedBbcResourceScalarWhereInput[]
    OR?: SharedBbcResourceScalarWhereInput[]
    NOT?: SharedBbcResourceScalarWhereInput | SharedBbcResourceScalarWhereInput[]
    id?: StringFilter<"SharedBbcResource"> | string
    title?: StringFilter<"SharedBbcResource"> | string
    description?: StringNullableFilter<"SharedBbcResource"> | string | null
    externalUrl?: StringNullableFilter<"SharedBbcResource"> | string | null
    durationMs?: IntNullableFilter<"SharedBbcResource"> | number | null
    transcript?: StringNullableFilter<"SharedBbcResource"> | string | null
    segments?: JsonNullableFilter<"SharedBbcResource">
    uploadedById?: StringFilter<"SharedBbcResource"> | string
    isPublished?: BoolFilter<"SharedBbcResource"> | boolean
    publishDate?: DateTimeNullableFilter<"SharedBbcResource"> | Date | string | null
    episodeNumber?: IntNullableFilter<"SharedBbcResource"> | number | null
    seasonNumber?: IntNullableFilter<"SharedBbcResource"> | number | null
    bbcUrl?: StringNullableFilter<"SharedBbcResource"> | string | null
    createdAt?: DateTimeFilter<"SharedBbcResource"> | Date | string
    updatedAt?: DateTimeFilter<"SharedBbcResource"> | Date | string
    sourceType?: StringFilter<"SharedBbcResource"> | string
    licenseInfo?: StringNullableFilter<"SharedBbcResource"> | string | null
  }

  export type LearningSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    update: XOR<LearningSessionUpdateWithoutUserInput, LearningSessionUncheckedUpdateWithoutUserInput>
    create: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput>
  }

  export type LearningSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    data: XOR<LearningSessionUpdateWithoutUserInput, LearningSessionUncheckedUpdateWithoutUserInput>
  }

  export type LearningSessionUpdateManyWithWhereWithoutUserInput = {
    where: LearningSessionScalarWhereInput
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningSessionScalarWhereInput = {
    AND?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
    OR?: LearningSessionScalarWhereInput[]
    NOT?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
    id?: StringFilter<"LearningSession"> | string
    userId?: StringFilter<"LearningSession"> | string
    audioId?: StringFilter<"LearningSession"> | string
    transcriptRunId?: StringNullableFilter<"LearningSession"> | string | null
    completedSegments?: IntFilter<"LearningSession"> | number
    totalSegments?: IntFilter<"LearningSession"> | number
    listeningTimeMs?: IntFilter<"LearningSession"> | number
    practiceTimeMs?: IntFilter<"LearningSession"> | number
    loopCount?: IntFilter<"LearningSession"> | number
    recordingCount?: IntFilter<"LearningSession"> | number
    score?: FloatNullableFilter<"LearningSession"> | number | null
    completedAt?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
    createdAt?: DateTimeFilter<"LearningSession"> | Date | string
    updatedAt?: DateTimeFilter<"LearningSession"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LearningSession"> | Date | string | null
  }

  export type UserCreateWithoutAuthSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
  }

  export type UserUpsertWithoutAuthSessionsInput = {
    update: XOR<UserUpdateWithoutAuthSessionsInput, UserUncheckedUpdateWithoutAuthSessionsInput>
    create: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthSessionsInput, UserUncheckedUpdateWithoutAuthSessionsInput>
  }

  export type UserUpdateWithoutAuthSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAudioFilesInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAudioFilesInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAudioFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAudioFilesInput, UserUncheckedCreateWithoutAudioFilesInput>
  }

  export type TranscriptRunCreateWithoutAudioInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutAudioInput = {
    id?: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutAudioInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutAudioInput, TranscriptRunUncheckedCreateWithoutAudioInput>
  }

  export type TranscriptRunCreateManyAudioInputEnvelope = {
    data: TranscriptRunCreateManyAudioInput | TranscriptRunCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type AudioTagCreateWithoutAudioInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type AudioTagUncheckedCreateWithoutAudioInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type AudioTagCreateOrConnectWithoutAudioInput = {
    where: AudioTagWhereUniqueInput
    create: XOR<AudioTagCreateWithoutAudioInput, AudioTagUncheckedCreateWithoutAudioInput>
  }

  export type AudioTagCreateManyAudioInputEnvelope = {
    data: AudioTagCreateManyAudioInput | AudioTagCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutAudioInput = {
    id?: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    run: TranscriptRunCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutAudioInput = {
    id?: string
    runId: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutAudioInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutAudioInput, JobUncheckedCreateWithoutAudioInput>
  }

  export type JobCreateManyAudioInputEnvelope = {
    data: JobCreateManyAudioInput | JobCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type LearningSessionCreateWithoutAudioFileInput = {
    id?: string
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningSessionsInput
    transcriptRun?: TranscriptRunCreateNestedOneWithoutLearningSessionsInput
  }

  export type LearningSessionUncheckedCreateWithoutAudioFileInput = {
    id?: string
    userId: string
    transcriptRunId?: string | null
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningSessionCreateOrConnectWithoutAudioFileInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutAudioFileInput, LearningSessionUncheckedCreateWithoutAudioFileInput>
  }

  export type LearningSessionCreateManyAudioFileInputEnvelope = {
    data: LearningSessionCreateManyAudioFileInput | LearningSessionCreateManyAudioFileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAudioFilesInput = {
    update: XOR<UserUpdateWithoutAudioFilesInput, UserUncheckedUpdateWithoutAudioFilesInput>
    create: XOR<UserCreateWithoutAudioFilesInput, UserUncheckedCreateWithoutAudioFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAudioFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAudioFilesInput, UserUncheckedUpdateWithoutAudioFilesInput>
  }

  export type UserUpdateWithoutAudioFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAudioFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TranscriptRunUpsertWithWhereUniqueWithoutAudioInput = {
    where: TranscriptRunWhereUniqueInput
    update: XOR<TranscriptRunUpdateWithoutAudioInput, TranscriptRunUncheckedUpdateWithoutAudioInput>
    create: XOR<TranscriptRunCreateWithoutAudioInput, TranscriptRunUncheckedCreateWithoutAudioInput>
  }

  export type TranscriptRunUpdateWithWhereUniqueWithoutAudioInput = {
    where: TranscriptRunWhereUniqueInput
    data: XOR<TranscriptRunUpdateWithoutAudioInput, TranscriptRunUncheckedUpdateWithoutAudioInput>
  }

  export type TranscriptRunUpdateManyWithWhereWithoutAudioInput = {
    where: TranscriptRunScalarWhereInput
    data: XOR<TranscriptRunUpdateManyMutationInput, TranscriptRunUncheckedUpdateManyWithoutAudioInput>
  }

  export type AudioTagUpsertWithWhereUniqueWithoutAudioInput = {
    where: AudioTagWhereUniqueInput
    update: XOR<AudioTagUpdateWithoutAudioInput, AudioTagUncheckedUpdateWithoutAudioInput>
    create: XOR<AudioTagCreateWithoutAudioInput, AudioTagUncheckedCreateWithoutAudioInput>
  }

  export type AudioTagUpdateWithWhereUniqueWithoutAudioInput = {
    where: AudioTagWhereUniqueInput
    data: XOR<AudioTagUpdateWithoutAudioInput, AudioTagUncheckedUpdateWithoutAudioInput>
  }

  export type AudioTagUpdateManyWithWhereWithoutAudioInput = {
    where: AudioTagScalarWhereInput
    data: XOR<AudioTagUpdateManyMutationInput, AudioTagUncheckedUpdateManyWithoutAudioInput>
  }

  export type AudioTagScalarWhereInput = {
    AND?: AudioTagScalarWhereInput | AudioTagScalarWhereInput[]
    OR?: AudioTagScalarWhereInput[]
    NOT?: AudioTagScalarWhereInput | AudioTagScalarWhereInput[]
    id?: StringFilter<"AudioTag"> | string
    audioId?: StringFilter<"AudioTag"> | string
    key?: StringFilter<"AudioTag"> | string
    createdAt?: DateTimeFilter<"AudioTag"> | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutAudioInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutAudioInput, JobUncheckedUpdateWithoutAudioInput>
    create: XOR<JobCreateWithoutAudioInput, JobUncheckedCreateWithoutAudioInput>
  }

  export type JobUpdateWithWhereUniqueWithoutAudioInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutAudioInput, JobUncheckedUpdateWithoutAudioInput>
  }

  export type JobUpdateManyWithWhereWithoutAudioInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutAudioInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    audioId?: StringNullableFilter<"Job"> | string | null
    runId?: StringFilter<"Job"> | string
    jobType?: StringFilter<"Job"> | string
    providerJobId?: StringNullableFilter<"Job"> | string | null
    status?: StringFilter<"Job"> | string
    retryCount?: IntFilter<"Job"> | number
    nextRetryAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    errorMessage?: StringNullableFilter<"Job"> | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
  }

  export type LearningSessionUpsertWithWhereUniqueWithoutAudioFileInput = {
    where: LearningSessionWhereUniqueInput
    update: XOR<LearningSessionUpdateWithoutAudioFileInput, LearningSessionUncheckedUpdateWithoutAudioFileInput>
    create: XOR<LearningSessionCreateWithoutAudioFileInput, LearningSessionUncheckedCreateWithoutAudioFileInput>
  }

  export type LearningSessionUpdateWithWhereUniqueWithoutAudioFileInput = {
    where: LearningSessionWhereUniqueInput
    data: XOR<LearningSessionUpdateWithoutAudioFileInput, LearningSessionUncheckedUpdateWithoutAudioFileInput>
  }

  export type LearningSessionUpdateManyWithWhereWithoutAudioFileInput = {
    where: LearningSessionScalarWhereInput
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyWithoutAudioFileInput>
  }

  export type AudioFileCreateWithoutTranscriptRunsInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioFilesInput
    tags?: AudioTagCreateNestedManyWithoutAudioInput
    Job?: JobCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileUncheckedCreateWithoutTranscriptRunsInput = {
    id?: string
    userId: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tags?: AudioTagUncheckedCreateNestedManyWithoutAudioInput
    Job?: JobUncheckedCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileCreateOrConnectWithoutTranscriptRunsInput = {
    where: AudioFileWhereUniqueInput
    create: XOR<AudioFileCreateWithoutTranscriptRunsInput, AudioFileUncheckedCreateWithoutTranscriptRunsInput>
  }

  export type UserCreateWithoutTranscriptRunsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTranscriptRunsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTranscriptRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTranscriptRunsInput, UserUncheckedCreateWithoutTranscriptRunsInput>
  }

  export type TranscriptRevisionCreateWithoutRunInput = {
    id?: string
    title?: string | null
    text: string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TranscriptRevisionUncheckedCreateWithoutRunInput = {
    id?: string
    title?: string | null
    text: string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TranscriptRevisionCreateOrConnectWithoutRunInput = {
    where: TranscriptRevisionWhereUniqueInput
    create: XOR<TranscriptRevisionCreateWithoutRunInput, TranscriptRevisionUncheckedCreateWithoutRunInput>
  }

  export type TranscriptRevisionCreateManyRunInputEnvelope = {
    data: TranscriptRevisionCreateManyRunInput | TranscriptRevisionCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type AnnotationCreateWithoutRunInput = {
    id?: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
    user: UserCreateNestedOneWithoutAnnotationsInput
  }

  export type AnnotationUncheckedCreateWithoutRunInput = {
    id?: string
    userId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type AnnotationCreateOrConnectWithoutRunInput = {
    where: AnnotationWhereUniqueInput
    create: XOR<AnnotationCreateWithoutRunInput, AnnotationUncheckedCreateWithoutRunInput>
  }

  export type AnnotationCreateManyRunInputEnvelope = {
    data: AnnotationCreateManyRunInput | AnnotationCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type JobCreateWithoutRunInput = {
    id?: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audio?: AudioFileCreateNestedOneWithoutJobInput
  }

  export type JobUncheckedCreateWithoutRunInput = {
    id?: string
    audioId?: string | null
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutRunInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutRunInput, JobUncheckedCreateWithoutRunInput>
  }

  export type JobCreateManyRunInputEnvelope = {
    data: JobCreateManyRunInput | JobCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type AnalysisCreateWithoutRunInput = {
    id?: string
    segmentIndex?: number | null
    kind: string
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    summary?: string | null
    score?: number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AnalysisUncheckedCreateWithoutRunInput = {
    id?: string
    segmentIndex?: number | null
    kind: string
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    summary?: string | null
    score?: number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AnalysisCreateOrConnectWithoutRunInput = {
    where: AnalysisWhereUniqueInput
    create: XOR<AnalysisCreateWithoutRunInput, AnalysisUncheckedCreateWithoutRunInput>
  }

  export type AnalysisCreateManyRunInputEnvelope = {
    data: AnalysisCreateManyRunInput | AnalysisCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type LearningSessionCreateWithoutTranscriptRunInput = {
    id?: string
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningSessionsInput
    audioFile: AudioFileCreateNestedOneWithoutLearningSessionsInput
  }

  export type LearningSessionUncheckedCreateWithoutTranscriptRunInput = {
    id?: string
    userId: string
    audioId: string
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningSessionCreateOrConnectWithoutTranscriptRunInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutTranscriptRunInput, LearningSessionUncheckedCreateWithoutTranscriptRunInput>
  }

  export type LearningSessionCreateManyTranscriptRunInputEnvelope = {
    data: LearningSessionCreateManyTranscriptRunInput | LearningSessionCreateManyTranscriptRunInput[]
    skipDuplicates?: boolean
  }

  export type AudioFileUpsertWithoutTranscriptRunsInput = {
    update: XOR<AudioFileUpdateWithoutTranscriptRunsInput, AudioFileUncheckedUpdateWithoutTranscriptRunsInput>
    create: XOR<AudioFileCreateWithoutTranscriptRunsInput, AudioFileUncheckedCreateWithoutTranscriptRunsInput>
    where?: AudioFileWhereInput
  }

  export type AudioFileUpdateToOneWithWhereWithoutTranscriptRunsInput = {
    where?: AudioFileWhereInput
    data: XOR<AudioFileUpdateWithoutTranscriptRunsInput, AudioFileUncheckedUpdateWithoutTranscriptRunsInput>
  }

  export type AudioFileUpdateWithoutTranscriptRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioFilesNestedInput
    tags?: AudioTagUpdateManyWithoutAudioNestedInput
    Job?: JobUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileUncheckedUpdateWithoutTranscriptRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: AudioTagUncheckedUpdateManyWithoutAudioNestedInput
    Job?: JobUncheckedUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutAudioFileNestedInput
  }

  export type UserUpsertWithoutTranscriptRunsInput = {
    update: XOR<UserUpdateWithoutTranscriptRunsInput, UserUncheckedUpdateWithoutTranscriptRunsInput>
    create: XOR<UserCreateWithoutTranscriptRunsInput, UserUncheckedCreateWithoutTranscriptRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTranscriptRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTranscriptRunsInput, UserUncheckedUpdateWithoutTranscriptRunsInput>
  }

  export type UserUpdateWithoutTranscriptRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTranscriptRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TranscriptRevisionUpsertWithWhereUniqueWithoutRunInput = {
    where: TranscriptRevisionWhereUniqueInput
    update: XOR<TranscriptRevisionUpdateWithoutRunInput, TranscriptRevisionUncheckedUpdateWithoutRunInput>
    create: XOR<TranscriptRevisionCreateWithoutRunInput, TranscriptRevisionUncheckedCreateWithoutRunInput>
  }

  export type TranscriptRevisionUpdateWithWhereUniqueWithoutRunInput = {
    where: TranscriptRevisionWhereUniqueInput
    data: XOR<TranscriptRevisionUpdateWithoutRunInput, TranscriptRevisionUncheckedUpdateWithoutRunInput>
  }

  export type TranscriptRevisionUpdateManyWithWhereWithoutRunInput = {
    where: TranscriptRevisionScalarWhereInput
    data: XOR<TranscriptRevisionUpdateManyMutationInput, TranscriptRevisionUncheckedUpdateManyWithoutRunInput>
  }

  export type TranscriptRevisionScalarWhereInput = {
    AND?: TranscriptRevisionScalarWhereInput | TranscriptRevisionScalarWhereInput[]
    OR?: TranscriptRevisionScalarWhereInput[]
    NOT?: TranscriptRevisionScalarWhereInput | TranscriptRevisionScalarWhereInput[]
    id?: StringFilter<"TranscriptRevision"> | string
    runId?: StringFilter<"TranscriptRevision"> | string
    title?: StringNullableFilter<"TranscriptRevision"> | string | null
    text?: StringFilter<"TranscriptRevision"> | string
    segments?: JsonNullableFilter<"TranscriptRevision">
    createdBy?: StringNullableFilter<"TranscriptRevision"> | string | null
    createdAt?: DateTimeFilter<"TranscriptRevision"> | Date | string
  }

  export type AnnotationUpsertWithWhereUniqueWithoutRunInput = {
    where: AnnotationWhereUniqueInput
    update: XOR<AnnotationUpdateWithoutRunInput, AnnotationUncheckedUpdateWithoutRunInput>
    create: XOR<AnnotationCreateWithoutRunInput, AnnotationUncheckedCreateWithoutRunInput>
  }

  export type AnnotationUpdateWithWhereUniqueWithoutRunInput = {
    where: AnnotationWhereUniqueInput
    data: XOR<AnnotationUpdateWithoutRunInput, AnnotationUncheckedUpdateWithoutRunInput>
  }

  export type AnnotationUpdateManyWithWhereWithoutRunInput = {
    where: AnnotationScalarWhereInput
    data: XOR<AnnotationUpdateManyMutationInput, AnnotationUncheckedUpdateManyWithoutRunInput>
  }

  export type JobUpsertWithWhereUniqueWithoutRunInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutRunInput, JobUncheckedUpdateWithoutRunInput>
    create: XOR<JobCreateWithoutRunInput, JobUncheckedCreateWithoutRunInput>
  }

  export type JobUpdateWithWhereUniqueWithoutRunInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutRunInput, JobUncheckedUpdateWithoutRunInput>
  }

  export type JobUpdateManyWithWhereWithoutRunInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutRunInput>
  }

  export type AnalysisUpsertWithWhereUniqueWithoutRunInput = {
    where: AnalysisWhereUniqueInput
    update: XOR<AnalysisUpdateWithoutRunInput, AnalysisUncheckedUpdateWithoutRunInput>
    create: XOR<AnalysisCreateWithoutRunInput, AnalysisUncheckedCreateWithoutRunInput>
  }

  export type AnalysisUpdateWithWhereUniqueWithoutRunInput = {
    where: AnalysisWhereUniqueInput
    data: XOR<AnalysisUpdateWithoutRunInput, AnalysisUncheckedUpdateWithoutRunInput>
  }

  export type AnalysisUpdateManyWithWhereWithoutRunInput = {
    where: AnalysisScalarWhereInput
    data: XOR<AnalysisUpdateManyMutationInput, AnalysisUncheckedUpdateManyWithoutRunInput>
  }

  export type AnalysisScalarWhereInput = {
    AND?: AnalysisScalarWhereInput | AnalysisScalarWhereInput[]
    OR?: AnalysisScalarWhereInput[]
    NOT?: AnalysisScalarWhereInput | AnalysisScalarWhereInput[]
    id?: StringFilter<"Analysis"> | string
    runId?: StringFilter<"Analysis"> | string
    segmentIndex?: IntNullableFilter<"Analysis"> | number | null
    kind?: StringFilter<"Analysis"> | string
    engine?: StringFilter<"Analysis"> | string
    params?: JsonNullableFilter<"Analysis">
    paramsHash?: StringFilter<"Analysis"> | string
    status?: StringFilter<"Analysis"> | string
    summary?: StringNullableFilter<"Analysis"> | string | null
    score?: FloatNullableFilter<"Analysis"> | number | null
    result?: JsonNullableFilter<"Analysis">
    error?: StringNullableFilter<"Analysis"> | string | null
    createdAt?: DateTimeFilter<"Analysis"> | Date | string
    updatedAt?: DateTimeFilter<"Analysis"> | Date | string
    completedAt?: DateTimeNullableFilter<"Analysis"> | Date | string | null
  }

  export type LearningSessionUpsertWithWhereUniqueWithoutTranscriptRunInput = {
    where: LearningSessionWhereUniqueInput
    update: XOR<LearningSessionUpdateWithoutTranscriptRunInput, LearningSessionUncheckedUpdateWithoutTranscriptRunInput>
    create: XOR<LearningSessionCreateWithoutTranscriptRunInput, LearningSessionUncheckedCreateWithoutTranscriptRunInput>
  }

  export type LearningSessionUpdateWithWhereUniqueWithoutTranscriptRunInput = {
    where: LearningSessionWhereUniqueInput
    data: XOR<LearningSessionUpdateWithoutTranscriptRunInput, LearningSessionUncheckedUpdateWithoutTranscriptRunInput>
  }

  export type LearningSessionUpdateManyWithWhereWithoutTranscriptRunInput = {
    where: LearningSessionScalarWhereInput
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyWithoutTranscriptRunInput>
  }

  export type TranscriptRunCreateWithoutRevisionsInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutRevisionsInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutRevisionsInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutRevisionsInput, TranscriptRunUncheckedCreateWithoutRevisionsInput>
  }

  export type TranscriptRunUpsertWithoutRevisionsInput = {
    update: XOR<TranscriptRunUpdateWithoutRevisionsInput, TranscriptRunUncheckedUpdateWithoutRevisionsInput>
    create: XOR<TranscriptRunCreateWithoutRevisionsInput, TranscriptRunUncheckedCreateWithoutRevisionsInput>
    where?: TranscriptRunWhereInput
  }

  export type TranscriptRunUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: TranscriptRunWhereInput
    data: XOR<TranscriptRunUpdateWithoutRevisionsInput, TranscriptRunUncheckedUpdateWithoutRevisionsInput>
  }

  export type TranscriptRunUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunCreateWithoutAnalysesInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutAnalysesInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutAnalysesInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutAnalysesInput, TranscriptRunUncheckedCreateWithoutAnalysesInput>
  }

  export type TranscriptRunUpsertWithoutAnalysesInput = {
    update: XOR<TranscriptRunUpdateWithoutAnalysesInput, TranscriptRunUncheckedUpdateWithoutAnalysesInput>
    create: XOR<TranscriptRunCreateWithoutAnalysesInput, TranscriptRunUncheckedCreateWithoutAnalysesInput>
    where?: TranscriptRunWhereInput
  }

  export type TranscriptRunUpdateToOneWithWhereWithoutAnalysesInput = {
    where?: TranscriptRunWhereInput
    data: XOR<TranscriptRunUpdateWithoutAnalysesInput, TranscriptRunUncheckedUpdateWithoutAnalysesInput>
  }

  export type TranscriptRunUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunCreateWithoutAnnotationsInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutAnnotationsInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutAnnotationsInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutAnnotationsInput, TranscriptRunUncheckedCreateWithoutAnnotationsInput>
  }

  export type UserCreateWithoutAnnotationsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnotationsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
  }

  export type TranscriptRunUpsertWithoutAnnotationsInput = {
    update: XOR<TranscriptRunUpdateWithoutAnnotationsInput, TranscriptRunUncheckedUpdateWithoutAnnotationsInput>
    create: XOR<TranscriptRunCreateWithoutAnnotationsInput, TranscriptRunUncheckedCreateWithoutAnnotationsInput>
    where?: TranscriptRunWhereInput
  }

  export type TranscriptRunUpdateToOneWithWhereWithoutAnnotationsInput = {
    where?: TranscriptRunWhereInput
    data: XOR<TranscriptRunUpdateWithoutAnnotationsInput, TranscriptRunUncheckedUpdateWithoutAnnotationsInput>
  }

  export type TranscriptRunUpdateWithoutAnnotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutAnnotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type UserUpsertWithoutAnnotationsInput = {
    update: XOR<UserUpdateWithoutAnnotationsInput, UserUncheckedUpdateWithoutAnnotationsInput>
    create: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnotationsInput, UserUncheckedUpdateWithoutAnnotationsInput>
  }

  export type UserUpdateWithoutAnnotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AudioFileCreateWithoutTagsInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioFilesInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAudioInput
    Job?: JobCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAudioInput
    Job?: JobUncheckedCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileCreateOrConnectWithoutTagsInput = {
    where: AudioFileWhereUniqueInput
    create: XOR<AudioFileCreateWithoutTagsInput, AudioFileUncheckedCreateWithoutTagsInput>
  }

  export type AudioFileUpsertWithoutTagsInput = {
    update: XOR<AudioFileUpdateWithoutTagsInput, AudioFileUncheckedUpdateWithoutTagsInput>
    create: XOR<AudioFileCreateWithoutTagsInput, AudioFileUncheckedCreateWithoutTagsInput>
    where?: AudioFileWhereInput
  }

  export type AudioFileUpdateToOneWithWhereWithoutTagsInput = {
    where?: AudioFileWhereInput
    data: XOR<AudioFileUpdateWithoutTagsInput, AudioFileUncheckedUpdateWithoutTagsInput>
  }

  export type AudioFileUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioFilesNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAudioNestedInput
    Job?: JobUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAudioNestedInput
    Job?: JobUncheckedUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutAudioFileNestedInput
  }

  export type UserCreateWithoutUsageLogsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
  }

  export type UserUpsertWithoutUsageLogsInput = {
    update: XOR<UserUpdateWithoutUsageLogsInput, UserUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageLogsInput, UserUncheckedUpdateWithoutUsageLogsInput>
  }

  export type UserUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AudioFileCreateWithoutJobInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioFilesInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAudioInput
    tags?: AudioTagCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileUncheckedCreateWithoutJobInput = {
    id?: string
    userId: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAudioInput
    tags?: AudioTagUncheckedCreateNestedManyWithoutAudioInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutAudioFileInput
  }

  export type AudioFileCreateOrConnectWithoutJobInput = {
    where: AudioFileWhereUniqueInput
    create: XOR<AudioFileCreateWithoutJobInput, AudioFileUncheckedCreateWithoutJobInput>
  }

  export type TranscriptRunCreateWithoutJobsInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutJobsInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutTranscriptRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutJobsInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutJobsInput, TranscriptRunUncheckedCreateWithoutJobsInput>
  }

  export type AudioFileUpsertWithoutJobInput = {
    update: XOR<AudioFileUpdateWithoutJobInput, AudioFileUncheckedUpdateWithoutJobInput>
    create: XOR<AudioFileCreateWithoutJobInput, AudioFileUncheckedCreateWithoutJobInput>
    where?: AudioFileWhereInput
  }

  export type AudioFileUpdateToOneWithWhereWithoutJobInput = {
    where?: AudioFileWhereInput
    data: XOR<AudioFileUpdateWithoutJobInput, AudioFileUncheckedUpdateWithoutJobInput>
  }

  export type AudioFileUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioFilesNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUncheckedUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutAudioFileNestedInput
  }

  export type TranscriptRunUpsertWithoutJobsInput = {
    update: XOR<TranscriptRunUpdateWithoutJobsInput, TranscriptRunUncheckedUpdateWithoutJobsInput>
    create: XOR<TranscriptRunCreateWithoutJobsInput, TranscriptRunUncheckedCreateWithoutJobsInput>
    where?: TranscriptRunWhereInput
  }

  export type TranscriptRunUpdateToOneWithWhereWithoutJobsInput = {
    where?: TranscriptRunWhereInput
    data: XOR<TranscriptRunUpdateWithoutJobsInput, TranscriptRunUncheckedUpdateWithoutJobsInput>
  }

  export type TranscriptRunUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSharedBbcResourcesInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedBbcResourcesInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedBbcResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedBbcResourcesInput, UserUncheckedCreateWithoutSharedBbcResourcesInput>
  }

  export type TakedownRequestCreateWithoutResourceInput = {
    id?: string
    reason: string
    contactInfo: string
    additionalInfo?: string | null
    requestType?: string
    status?: string
    adminNotes?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakedownRequestUncheckedCreateWithoutResourceInput = {
    id?: string
    reason: string
    contactInfo: string
    additionalInfo?: string | null
    requestType?: string
    status?: string
    adminNotes?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakedownRequestCreateOrConnectWithoutResourceInput = {
    where: TakedownRequestWhereUniqueInput
    create: XOR<TakedownRequestCreateWithoutResourceInput, TakedownRequestUncheckedCreateWithoutResourceInput>
  }

  export type TakedownRequestCreateManyResourceInputEnvelope = {
    data: TakedownRequestCreateManyResourceInput | TakedownRequestCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSharedBbcResourcesInput = {
    update: XOR<UserUpdateWithoutSharedBbcResourcesInput, UserUncheckedUpdateWithoutSharedBbcResourcesInput>
    create: XOR<UserCreateWithoutSharedBbcResourcesInput, UserUncheckedCreateWithoutSharedBbcResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedBbcResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedBbcResourcesInput, UserUncheckedUpdateWithoutSharedBbcResourcesInput>
  }

  export type UserUpdateWithoutSharedBbcResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedBbcResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TakedownRequestUpsertWithWhereUniqueWithoutResourceInput = {
    where: TakedownRequestWhereUniqueInput
    update: XOR<TakedownRequestUpdateWithoutResourceInput, TakedownRequestUncheckedUpdateWithoutResourceInput>
    create: XOR<TakedownRequestCreateWithoutResourceInput, TakedownRequestUncheckedCreateWithoutResourceInput>
  }

  export type TakedownRequestUpdateWithWhereUniqueWithoutResourceInput = {
    where: TakedownRequestWhereUniqueInput
    data: XOR<TakedownRequestUpdateWithoutResourceInput, TakedownRequestUncheckedUpdateWithoutResourceInput>
  }

  export type TakedownRequestUpdateManyWithWhereWithoutResourceInput = {
    where: TakedownRequestScalarWhereInput
    data: XOR<TakedownRequestUpdateManyMutationInput, TakedownRequestUncheckedUpdateManyWithoutResourceInput>
  }

  export type TakedownRequestScalarWhereInput = {
    AND?: TakedownRequestScalarWhereInput | TakedownRequestScalarWhereInput[]
    OR?: TakedownRequestScalarWhereInput[]
    NOT?: TakedownRequestScalarWhereInput | TakedownRequestScalarWhereInput[]
    id?: StringFilter<"TakedownRequest"> | string
    resourceId?: StringFilter<"TakedownRequest"> | string
    reason?: StringFilter<"TakedownRequest"> | string
    contactInfo?: StringFilter<"TakedownRequest"> | string
    additionalInfo?: StringNullableFilter<"TakedownRequest"> | string | null
    requestType?: StringFilter<"TakedownRequest"> | string
    status?: StringFilter<"TakedownRequest"> | string
    adminNotes?: StringNullableFilter<"TakedownRequest"> | string | null
    resolvedAt?: DateTimeNullableFilter<"TakedownRequest"> | Date | string | null
    resolvedBy?: StringNullableFilter<"TakedownRequest"> | string | null
    createdAt?: DateTimeFilter<"TakedownRequest"> | Date | string
    updatedAt?: DateTimeFilter<"TakedownRequest"> | Date | string
  }

  export type UserCreateWithoutLearningSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutLearningSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutLearningSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
  }

  export type AudioFileCreateWithoutLearningSessionsInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAudioFilesInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAudioInput
    tags?: AudioTagCreateNestedManyWithoutAudioInput
    Job?: JobCreateNestedManyWithoutAudioInput
  }

  export type AudioFileUncheckedCreateWithoutLearningSessionsInput = {
    id?: string
    userId: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAudioInput
    tags?: AudioTagUncheckedCreateNestedManyWithoutAudioInput
    Job?: JobUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioFileCreateOrConnectWithoutLearningSessionsInput = {
    where: AudioFileWhereUniqueInput
    create: XOR<AudioFileCreateWithoutLearningSessionsInput, AudioFileUncheckedCreateWithoutLearningSessionsInput>
  }

  export type TranscriptRunCreateWithoutLearningSessionsInput = {
    id?: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    audio: AudioFileCreateNestedOneWithoutTranscriptRunsInput
    author?: UserCreateNestedOneWithoutTranscriptRunsInput
    revisions?: TranscriptRevisionCreateNestedManyWithoutRunInput
    annotations?: AnnotationCreateNestedManyWithoutRunInput
    jobs?: JobCreateNestedManyWithoutRunInput
    analyses?: AnalysisCreateNestedManyWithoutRunInput
  }

  export type TranscriptRunUncheckedCreateWithoutLearningSessionsInput = {
    id?: string
    audioId: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    revisions?: TranscriptRevisionUncheckedCreateNestedManyWithoutRunInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutRunInput
    jobs?: JobUncheckedCreateNestedManyWithoutRunInput
    analyses?: AnalysisUncheckedCreateNestedManyWithoutRunInput
  }

  export type TranscriptRunCreateOrConnectWithoutLearningSessionsInput = {
    where: TranscriptRunWhereUniqueInput
    create: XOR<TranscriptRunCreateWithoutLearningSessionsInput, TranscriptRunUncheckedCreateWithoutLearningSessionsInput>
  }

  export type UserUpsertWithoutLearningSessionsInput = {
    update: XOR<UserUpdateWithoutLearningSessionsInput, UserUncheckedUpdateWithoutLearningSessionsInput>
    create: XOR<UserCreateWithoutLearningSessionsInput, UserUncheckedCreateWithoutLearningSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningSessionsInput, UserUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type UserUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AudioFileUpsertWithoutLearningSessionsInput = {
    update: XOR<AudioFileUpdateWithoutLearningSessionsInput, AudioFileUncheckedUpdateWithoutLearningSessionsInput>
    create: XOR<AudioFileCreateWithoutLearningSessionsInput, AudioFileUncheckedCreateWithoutLearningSessionsInput>
    where?: AudioFileWhereInput
  }

  export type AudioFileUpdateToOneWithWhereWithoutLearningSessionsInput = {
    where?: AudioFileWhereInput
    data: XOR<AudioFileUpdateWithoutLearningSessionsInput, AudioFileUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type AudioFileUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAudioFilesNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUpdateManyWithoutAudioNestedInput
    Job?: JobUpdateManyWithoutAudioNestedInput
  }

  export type AudioFileUncheckedUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUncheckedUpdateManyWithoutAudioNestedInput
    Job?: JobUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type TranscriptRunUpsertWithoutLearningSessionsInput = {
    update: XOR<TranscriptRunUpdateWithoutLearningSessionsInput, TranscriptRunUncheckedUpdateWithoutLearningSessionsInput>
    create: XOR<TranscriptRunCreateWithoutLearningSessionsInput, TranscriptRunUncheckedCreateWithoutLearningSessionsInput>
    where?: TranscriptRunWhereInput
  }

  export type TranscriptRunUpdateToOneWithWhereWithoutLearningSessionsInput = {
    where?: TranscriptRunWhereInput
    data: XOR<TranscriptRunUpdateWithoutLearningSessionsInput, TranscriptRunUncheckedUpdateWithoutLearningSessionsInput>
  }

  export type TranscriptRunUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutLearningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    passwordHash: string
    displayName?: string | null
    avatarUrl?: string | null
    emailVerified?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    audioFiles?: AudioFileUncheckedCreateNestedManyWithoutUserInput
    transcriptRuns?: TranscriptRunUncheckedCreateNestedManyWithoutAuthorInput
    annotations?: AnnotationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sharedBbcResources?: SharedBbcResourceUncheckedCreateNestedManyWithoutUploadedByInput
    learningSessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    audioFiles?: AudioFileUncheckedUpdateManyWithoutUserNestedInput
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAuthorNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sharedBbcResources?: SharedBbcResourceUncheckedUpdateManyWithoutUploadedByNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SharedBbcResourceCreateWithoutTakedownRequestsInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
    uploadedBy: UserCreateNestedOneWithoutSharedBbcResourcesInput
  }

  export type SharedBbcResourceUncheckedCreateWithoutTakedownRequestsInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
  }

  export type SharedBbcResourceCreateOrConnectWithoutTakedownRequestsInput = {
    where: SharedBbcResourceWhereUniqueInput
    create: XOR<SharedBbcResourceCreateWithoutTakedownRequestsInput, SharedBbcResourceUncheckedCreateWithoutTakedownRequestsInput>
  }

  export type SharedBbcResourceUpsertWithoutTakedownRequestsInput = {
    update: XOR<SharedBbcResourceUpdateWithoutTakedownRequestsInput, SharedBbcResourceUncheckedUpdateWithoutTakedownRequestsInput>
    create: XOR<SharedBbcResourceCreateWithoutTakedownRequestsInput, SharedBbcResourceUncheckedCreateWithoutTakedownRequestsInput>
    where?: SharedBbcResourceWhereInput
  }

  export type SharedBbcResourceUpdateToOneWithWhereWithoutTakedownRequestsInput = {
    where?: SharedBbcResourceWhereInput
    data: XOR<SharedBbcResourceUpdateWithoutTakedownRequestsInput, SharedBbcResourceUncheckedUpdateWithoutTakedownRequestsInput>
  }

  export type SharedBbcResourceUpdateWithoutTakedownRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: UserUpdateOneRequiredWithoutSharedBbcResourcesNestedInput
  }

  export type SharedBbcResourceUncheckedUpdateWithoutTakedownRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AudioFileCreateManyUserInput = {
    id?: string
    gcsUri: string
    filename: string
    durationMs?: number | null
    sizeBytes?: bigint | number | null
    language?: string | null
    mode?: string | null
    gapSec?: number | null
    status: string
    errorMessage?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TranscriptRunCreateManyAuthorInput = {
    id?: string
    audioId: string
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AnnotationCreateManyUserInput = {
    id?: string
    runId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type UsageLogCreateManyUserInput = {
    id?: string
    day: Date | string
    uploadCount?: number
    durationMs?: number
    createdAt?: Date | string
  }

  export type AuthSessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    kind: string
    targetId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SharedBbcResourceCreateManyUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    externalUrl?: string | null
    durationMs?: number | null
    transcript?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: boolean
    publishDate?: Date | string | null
    episodeNumber?: number | null
    seasonNumber?: number | null
    bbcUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceType?: string
    licenseInfo?: string | null
  }

  export type LearningSessionCreateManyUserInput = {
    id?: string
    audioId: string
    transcriptRunId?: string | null
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AudioFileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transcriptRuns?: TranscriptRunUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUpdateManyWithoutAudioNestedInput
    Job?: JobUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transcriptRuns?: TranscriptRunUncheckedUpdateManyWithoutAudioNestedInput
    tags?: AudioTagUncheckedUpdateManyWithoutAudioNestedInput
    Job?: JobUncheckedUpdateManyWithoutAudioNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutAudioFileNestedInput
  }

  export type AudioFileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gcsUri?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    gapSec?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptRunUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audio?: AudioFileUpdateOneRequiredWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnotationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    run?: TranscriptRunUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type AnnotationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsageLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadCount?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedBbcResourceUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
    takedownRequests?: TakedownRequestUpdateManyWithoutResourceNestedInput
  }

  export type SharedBbcResourceUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
    takedownRequests?: TakedownRequestUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type SharedBbcResourceUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    episodeNumber?: NullableIntFieldUpdateOperationsInput | number | null
    seasonNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bbcUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceType?: StringFieldUpdateOperationsInput | string
    licenseInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LearningSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audioFile?: AudioFileUpdateOneRequiredWithoutLearningSessionsNestedInput
    transcriptRun?: TranscriptRunUpdateOneWithoutLearningSessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    transcriptRunId?: NullableStringFieldUpdateOperationsInput | string | null
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    transcriptRunId?: NullableStringFieldUpdateOperationsInput | string | null
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptRunCreateManyAudioInput = {
    id?: string
    authorId?: string | null
    version: number
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    error?: string | null
    text?: string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: number | null
    confidence?: number | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AudioTagCreateManyAudioInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type JobCreateManyAudioInput = {
    id?: string
    runId: string
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningSessionCreateManyAudioFileInput = {
    id?: string
    userId: string
    transcriptRunId?: string | null
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TranscriptRunUpdateWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneWithoutTranscriptRunsNestedInput
    revisions?: TranscriptRevisionUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUpdateManyWithoutRunNestedInput
    jobs?: JobUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: TranscriptRevisionUncheckedUpdateManyWithoutRunNestedInput
    annotations?: AnnotationUncheckedUpdateManyWithoutRunNestedInput
    jobs?: JobUncheckedUpdateManyWithoutRunNestedInput
    analyses?: AnalysisUncheckedUpdateManyWithoutRunNestedInput
    learningSessions?: LearningSessionUncheckedUpdateManyWithoutTranscriptRunNestedInput
  }

  export type TranscriptRunUncheckedUpdateManyWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    segments?: NullableJsonNullValueInput | InputJsonValue
    speakerCount?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioTagUpdateWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTagUncheckedUpdateWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTagUncheckedUpdateManyWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: TranscriptRunUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyWithoutAudioInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUpdateWithoutAudioFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningSessionsNestedInput
    transcriptRun?: TranscriptRunUpdateOneWithoutLearningSessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutAudioFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transcriptRunId?: NullableStringFieldUpdateOperationsInput | string | null
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionUncheckedUpdateManyWithoutAudioFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transcriptRunId?: NullableStringFieldUpdateOperationsInput | string | null
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TranscriptRevisionCreateManyRunInput = {
    id?: string
    title?: string | null
    text: string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type AnnotationCreateManyRunInput = {
    id?: string
    userId: string
    content: string
    anchorType: string
    anchorValue: string
    createdAt?: Date | string
    isDeleted?: boolean
  }

  export type JobCreateManyRunInput = {
    id?: string
    audioId?: string | null
    jobType: string
    providerJobId?: string | null
    status: string
    retryCount?: number
    nextRetryAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisCreateManyRunInput = {
    id?: string
    segmentIndex?: number | null
    kind: string
    engine: string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash: string
    status: string
    summary?: string | null
    score?: number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LearningSessionCreateManyTranscriptRunInput = {
    id?: string
    userId: string
    audioId: string
    completedSegments?: number
    totalSegments?: number
    listeningTimeMs?: number
    practiceTimeMs?: number
    loopCount?: number
    recordingCount?: number
    score?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TranscriptRevisionUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptRevisionUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranscriptRevisionUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    segments?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnotationUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type AnnotationUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnnotationUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    anchorType?: StringFieldUpdateOperationsInput | string
    anchorValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audio?: AudioFileUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioId?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    providerJobId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnalysisUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnalysisUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIndex?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    engine?: StringFieldUpdateOperationsInput | string
    params?: NullableJsonNullValueInput | InputJsonValue
    paramsHash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionUpdateWithoutTranscriptRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningSessionsNestedInput
    audioFile?: AudioFileUpdateOneRequiredWithoutLearningSessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutTranscriptRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionUncheckedUpdateManyWithoutTranscriptRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    audioId?: StringFieldUpdateOperationsInput | string
    completedSegments?: IntFieldUpdateOperationsInput | number
    totalSegments?: IntFieldUpdateOperationsInput | number
    listeningTimeMs?: IntFieldUpdateOperationsInput | number
    practiceTimeMs?: IntFieldUpdateOperationsInput | number
    loopCount?: IntFieldUpdateOperationsInput | number
    recordingCount?: IntFieldUpdateOperationsInput | number
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TakedownRequestCreateManyResourceInput = {
    id?: string
    reason: string
    contactInfo: string
    additionalInfo?: string | null
    requestType?: string
    status?: string
    adminNotes?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TakedownRequestUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakedownRequestUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TakedownRequestUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}